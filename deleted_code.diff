diff --git a/server/server.cjs b/server/server.cjs
index 8a8a265..0519bbf 100644
--- a/server/server.cjs
+++ b/server/server.cjs
@@ -4,8 +4,8 @@ const mysql = require('mysql2/promise');
 const multer = require('multer');
 const fs = require('fs');
 const path = require('path');
-const crypto = require('crypto');
-require('dotenv').config({ override: true });
+const jwt = require('jsonwebtoken');
+require('dotenv').config();
 
 console.log('üîß Iniciando servidor...');
 
@@ -17,8 +17,6 @@ const {
   createAccountLimiter,
   cartLimiter,
   productsLimiter,
-  highFrequencyLimiter,
-  authRoutesLimiter,
   helmetConfig,
   sanitizeObject
 } = require('../config/security.cjs');
@@ -27,7 +25,6 @@ const { initializeScheduler, scheduleMonthlyCleanup } = require('../config/cartR
 const { setDoubleSubmitCookie, getCsrfTokenEndpoint } = require('../config/csrfProtection.cjs');
 const redisCache = require('../config/redisCache.cjs');
 const sentry = require('../config/sentry.cjs');
-const { authenticateAdmin } = require('./middleware/auth.cjs');
 
 const app = express();
 const PORT = process.env.SERVER_PORT || 3001;
@@ -48,7 +45,8 @@ app.use(cors({
     'http://localhost:8040',
     'http://localhost:3000',
     'http://127.0.0.1:8040',
-    'http://localhost:8040',
+    'capacitor://localhost',
+    'http://localhost',
     'http://172.16.0.15:8040',
     'http://172.17.0.1:8040',
     'http://172.18.0.1:8040',
@@ -58,6 +56,7 @@ app.use(cors({
   ],
   credentials: true
 }));
+
 app.use(express.json({ limit: '10mb' }));
 app.use(express.urlencoded({ extended: true, limit: '10mb' }));
 
@@ -88,196 +87,8 @@ app.use((req, res, next) => {
   next();
 });
 
-// =========================
-// Rotas alternativas para servir uploads (m√∫ltiplas rotas para garantir funcionamento)
-// IMPORTANTE: Estas rotas devem vir ANTES de /lovable-uploads para ter prioridade
-// =========================
-
-// Fun√ß√£o auxiliar para servir arquivo
-function serveUploadFile(req, res, filename, routeName) {
-  // Log detalhado para debug
-  console.log(`üîç [${routeName}] Requisi√ß√£o recebida: ${req.method} ${req.path}`);
-  console.log(`   Filename: ${filename}`);
-  console.log(`   Original URL: ${req.originalUrl}`);
-  console.log(`   IP: ${req.ip || req.headers['x-forwarded-for'] || req.connection.remoteAddress}`);
-
-  // Validar filename para evitar path traversal
-  if (!filename || filename.includes('..') || filename.includes('/') || filename.includes('\\')) {
-    console.warn(`‚ö†Ô∏è [${routeName}] Filename inv√°lido: ${filename}`);
-    return res.status(400).json({ error: 'Filename inv√°lido' });
-  }
-
-  const filePath = path.join(__dirname, '../public/lovable-uploads', filename);
-
-  console.log(`   Caminho completo: ${filePath}`);
-  console.log(`   Existe? ${fs.existsSync(filePath)}`);
-
-  // Verificar se o arquivo existe
-  if (fs.existsSync(filePath)) {
-    const stats = fs.statSync(filePath);
-    if (!stats.isFile()) {
-      console.warn(`‚ö†Ô∏è [${routeName}] Caminho n√£o √© arquivo: ${filePath}`);
-      return res.status(404).json({ error: 'Arquivo n√£o encontrado', filename });
-    }
-
-    const ext = path.extname(filename).toLowerCase();
-    const mimeTypes = {
-      '.png': 'image/png',
-      '.jpg': 'image/jpeg',
-      '.jpeg': 'image/jpeg',
-      '.gif': 'image/gif',
-      '.webp': 'image/webp',
-      '.svg': 'image/svg+xml',
-      '.avif': 'image/avif',
-      '.bmp': 'image/bmp',
-      '.mp4': 'video/mp4',
-      '.webm': 'video/webm',
-      '.ogg': 'video/ogg'
-    };
-    const contentType = mimeTypes[ext] || 'application/octet-stream';
-
-    // Headers para CORS e cache
-    res.setHeader('Content-Type', contentType);
-    res.setHeader('Cache-Control', 'public, max-age=31536000');
-    res.setHeader('Cross-Origin-Resource-Policy', 'cross-origin');
-    res.setHeader('Access-Control-Allow-Origin', '*');
-
-    console.log(`‚úÖ [${routeName}] Servindo: ${filename} (${stats.size} bytes, ${contentType})`);
-    return res.sendFile(path.resolve(filePath));
-  } else {
-    console.warn(`‚ö†Ô∏è [${routeName}] Arquivo n√£o encontrado: ${filename}`);
-    console.warn(`   Tentando buscar em: ${path.dirname(filePath)}`);
-    console.warn(`   Diret√≥rio existe? ${fs.existsSync(path.dirname(filePath))}`);
-
-    // Listar arquivos no diret√≥rio para debug
-    try {
-      const dirFiles = fs.readdirSync(path.dirname(filePath));
-      console.warn(`   Arquivos no diret√≥rio (primeiros 10): ${dirFiles.slice(0, 10).join(', ')}`);
-    } catch (e) {
-      console.warn(`   Erro ao listar diret√≥rio: ${e.message}`);
-    }
-
-    return res.status(404).json({ error: 'Arquivo n√£o encontrado', filename, path: filePath });
-  }
-}
-
-// IMPORTANTE: Estas rotas devem vir ANTES de qualquer middleware que possa interceptar
-// Ordem de prioridade: rotas espec√≠ficas primeiro, depois middlewares gen√©ricos
-
-// Rota 1: /api/uploads/:filename (padr√£o) - PRIMEIRA PRIORIDADE
-app.get('/api/uploads/:filename', (req, res) => {
-  serveUploadFile(req, res, req.params.filename, 'api/uploads');
-});
-
-// Rota 2: /api/files/:filename (alternativa)
-app.get('/api/files/:filename', (req, res) => {
-  serveUploadFile(req, res, req.params.filename, 'api/files');
-});
-
-// Rota 3: /api/media/:filename (alternativa)
-app.get('/api/media/:filename', (req, res) => {
-  serveUploadFile(req, res, req.params.filename, 'api/media');
-});
-
-// Rota 4: /api/static/:filename (alternativa)
-app.get('/api/static/:filename', (req, res) => {
-  serveUploadFile(req, res, req.params.filename, 'api/static');
-});
-
-// Rota 5: /api/img/:filename (alternativa)
-app.get('/api/img/:filename', (req, res) => {
-  serveUploadFile(req, res, req.params.filename, 'api/img');
-});
-
-// Rota 6: /api/file/:filename (alternativa adicional)
-app.get('/api/file/:filename', (req, res) => {
-  serveUploadFile(req, res, req.params.filename, 'api/file');
-});
-
-// Rota 7: /api/asset/:filename (alternativa adicional)
-app.get('/api/asset/:filename', (req, res) => {
-  serveUploadFile(req, res, req.params.filename, 'api/asset');
-});
-
-// =========================
-// Static - lovable uploads
-// =========================
-try {
-  const uploadsDir = path.join(process.cwd(), 'public', 'lovable-uploads');
-  if (!fs.existsSync(uploadsDir)) {
-    fs.mkdirSync(uploadsDir, { recursive: true });
-    console.log('üìÅ Diret√≥rio criado:', uploadsDir);
-  }
-  app.use('/lovable-uploads', (req, res, next) => {
-    // req.path j√° inclui /lovable-uploads, ent√£o precisamos remover esse prefixo
-    const pathWithoutPrefix = req.path.replace(/^\/lovable-uploads\/?/, '');
-    const filename = pathWithoutPrefix.split('/').pop(); // Pegar apenas o nome do arquivo
-    const target = path.join(uploadsDir, filename);
-
-    // Log para debug
-    console.log(`üîç [lovable-uploads] Requisi√ß√£o: ${req.method} ${req.path}`);
-    console.log(`   Filename: ${filename}`);
-    console.log(`   Target: ${target}`);
-    console.log(`   Existe? ${fs.existsSync(target)}`);
-
-    if (fs.existsSync(target)) {
-      // Verificar se √© um arquivo (n√£o diret√≥rio)
-      const stats = fs.statSync(target);
-      if (stats.isFile()) {
-        // Determinar Content-Type baseado na extens√£o
-        const ext = path.extname(filename).toLowerCase();
-        const mimeTypes = {
-          '.png': 'image/png',
-          '.jpg': 'image/jpeg',
-          '.jpeg': 'image/jpeg',
-          '.gif': 'image/gif',
-          '.webp': 'image/webp',
-          '.svg': 'image/svg+xml',
-          '.avif': 'image/avif',
-          '.bmp': 'image/bmp',
-          '.mp4': 'video/mp4',
-          '.webm': 'video/webm',
-          '.ogg': 'video/ogg'
-        };
-
-        const contentType = mimeTypes[ext] || 'application/octet-stream';
-        res.setHeader('Content-Type', contentType);
-        res.setHeader('Cross-Origin-Resource-Policy', 'cross-origin');
-        res.setHeader('Access-Control-Allow-Origin', '*');
-        res.setHeader('Cache-Control', 'public, max-age=31536000'); // Cache por 1 ano
-
-        console.log(`‚úÖ Servindo arquivo: ${filename} (Content-Type: ${contentType}, Size: ${stats.size} bytes)`);
-        return res.sendFile(path.resolve(target));
-      } else {
-        console.warn(`‚ö†Ô∏è Caminho n√£o √© arquivo: ${target}`);
-      }
-    } else {
-      console.warn(`‚ö†Ô∏è Arquivo n√£o encontrado: ${target}`);
-      console.warn(`   Tentando buscar em: ${uploadsDir}`);
-    }
-
-    // Fallback para placeholder se arquivo n√£o existir
-    const placeholderPng = path.join(process.cwd(), 'public', 'placeholder.png');
-    const placeholderSvg = path.join(process.cwd(), 'public', 'placeholder.svg');
-    if (fs.existsSync(placeholderPng)) {
-      console.warn(`‚ö†Ô∏è Usando placeholder para arquivo n√£o encontrado: ${req.path}`);
-      res.setHeader('Content-Type', 'image/png');
-      return res.sendFile(path.resolve(placeholderPng));
-    }
-    if (fs.existsSync(placeholderSvg)) {
-      res.setHeader('Content-Type', 'image/svg+xml');
-      return res.sendFile(path.resolve(placeholderSvg));
-    }
-    console.error(`‚ùå Arquivo n√£o encontrado e placeholder indispon√≠vel: ${req.path}`);
-    return res.status(404).send('Not Found');
-  });
-} catch (e) {
-  console.warn('‚ö†Ô∏è  N√£o foi poss√≠vel configurar /lovable-uploads:', e?.message || e);
-}
-
-// Rate limiting geral - REMOVIDO para evitar conflito com limiters espec√≠ficos
-// O generalLimiter agora √© aplicado apenas em rotas espec√≠ficas que n√£o t√™m seus pr√≥prios limiters
-// app.use('/api/', generalLimiter);
+// Rate limiting geral
+app.use('/api/', generalLimiter);
 
 // Prote√ß√£o CSRF (Double Submit Cookie pattern)
 app.use(setDoubleSubmitCookie);
@@ -334,6 +145,12 @@ app.get(/^\/https?:\/\/[^/]+(\/.*)$/i, (req, res) => {
   }
 });
 
+// Serve static files from public directory (com headers para evitar ORB)
+app.use('/lovable-uploads', (req, res, next) => {
+  res.setHeader('Cross-Origin-Resource-Policy', 'cross-origin');
+  res.setHeader('Access-Control-Allow-Origin', '*');
+  next();
+}, express.static(path.join(__dirname, '../public/lovable-uploads')));
 // Tamb√©m servir uploads padr√£o
 // servir /uploads do mesmo diret√≥rio base do multer
 app.use('/uploads', (req, res, next) => {
@@ -341,103 +158,6 @@ app.use('/uploads', (req, res, next) => {
   res.setHeader('Access-Control-Allow-Origin', '*');
   next();
 }, express.static(path.join(__dirname, '../public')));
-
-// Rota espec√≠fica para √≠cones PWA via API
-app.get('/api/icons/:filename', (req, res) => {
-  const filename = req.params.filename;
-  const filePath = path.join(__dirname, '../public/static-icons', filename);
-
-  // Verificar se o arquivo existe
-  if (fs.existsSync(filePath)) {
-    res.sendFile(filePath);
-  } else {
-    res.status(404).json({ error: '√çcone n√£o encontrado' });
-  }
-});
-
-// Rota alternativa para √≠cones PWA
-app.get('/pwa-icon/:filename', (req, res) => {
-  const filename = req.params.filename;
-  const filePath = path.join(__dirname, '../public/static-icons', filename);
-
-  // Verificar se o arquivo existe
-  if (fs.existsSync(filePath)) {
-    res.sendFile(filePath);
-  } else {
-    res.status(404).json({ error: '√çcone n√£o encontrado' });
-  }
-});
-
-// Rota espec√≠fica para √≠cones PWA que o Nginx n√£o intercepta
-app.get('/icon/:filename', (req, res) => {
-  const filename = req.params.filename;
-  const filePath = path.join(__dirname, '../public/static-icons', filename);
-
-  // Verificar se o arquivo existe
-  if (fs.existsSync(filePath)) {
-    res.sendFile(filePath);
-  } else {
-    res.status(404).json({ error: '√çcone n√£o encontrado' });
-  }
-});
-
-// Rota espec√≠fica para imagens de uploads
-
-app.get('/lovable-uploads/:filename', (req, res) => {
-  const filename = req.params.filename;
-  const filePath = path.join(__dirname, '../public/lovable-uploads', filename);
-
-  // Verificar se o arquivo existe
-  if (fs.existsSync(filePath)) {
-    const ext = path.extname(filename).toLowerCase();
-    const mimeTypes = {
-      '.png': 'image/png',
-      '.jpg': 'image/jpeg',
-      '.jpeg': 'image/jpeg',
-      '.gif': 'image/gif',
-      '.webp': 'image/webp',
-      '.svg': 'image/svg+xml',
-      '.mp4': 'video/mp4',
-      '.webm': 'video/webm',
-      '.ogg': 'video/ogg'
-    };
-    const contentType = mimeTypes[ext] || 'application/octet-stream';
-    res.setHeader('Content-Type', contentType);
-    res.setHeader('Cache-Control', 'public, max-age=31536000');
-    res.sendFile(path.resolve(filePath));
-  } else {
-    res.status(404).json({ error: 'Imagem n√£o encontrada' });
-  }
-});
-
-// Rota alternativa para imagens de uploads
-app.get('/uploads/:filename', (req, res) => {
-  const filename = req.params.filename;
-  const filePath = path.join(__dirname, '../public/lovable-uploads', filename);
-
-  // Verificar se o arquivo existe
-  if (fs.existsSync(filePath)) {
-    res.sendFile(filePath);
-  } else {
-    res.status(404).json({ error: 'Imagem n√£o encontrada' });
-  }
-});
-
-// Rota espec√≠fica para imagens de uploads que o Nginx n√£o intercepta
-app.get('/img/:filename', (req, res) => {
-  const filename = req.params.filename;
-  const filePath = path.join(__dirname, '../public/lovable-uploads', filename);
-
-  // Verificar se o arquivo existe
-  if (fs.existsSync(filePath)) {
-    res.sendFile(filePath);
-  } else {
-    res.status(404).json({ error: 'Imagem n√£o encontrada' });
-  }
-});
-
-// Rota /api/img/:filename j√° est√° definida acima usando serveUploadFile
-
 // Logar chaves do body para rotas de cole√ß√µes
 app.use((req, _res, next) => {
   if (req.path.startsWith('/api/collections')) {
@@ -490,73 +210,29 @@ const upload = multer({
   storage: storage,
   limits: { fileSize: 5 * 1024 * 1024 }, // 5MB limit
   fileFilter: (req, file, cb) => {
-    // Aceitar qualquer tipo de imagem
     if (file.mimetype.startsWith('image/')) {
-      // Log espec√≠fico para PNG para debug
-      if (file.mimetype === 'image/png' || file.originalname.toLowerCase().endsWith('.png')) {
-        console.log(`üì∏ Upload de PNG detectado: ${file.originalname} (mimetype: ${file.mimetype})`);
-      }
-      cb(null, true);
-    } else {
-      // Tamb√©m verificar por extens√£o caso o mimetype n√£o seja detectado
-      const ext = path.extname(file.originalname).toLowerCase();
-      const imageExts = ['.png', '.jpg', '.jpeg', '.gif', '.webp', '.svg', '.avif', '.bmp'];
-      if (imageExts.includes(ext)) {
-        console.log(`üì∏ Upload de imagem por extens√£o: ${file.originalname} (mimetype: ${file.mimetype}, extens√£o: ${ext})`);
-        cb(null, true);
-      } else {
-        console.warn(`‚ö†Ô∏è Arquivo rejeitado: ${file.originalname} (mimetype: ${file.mimetype}, extens√£o: ${ext})`);
-        cb(new Error('Only image files are allowed!'), false);
-      }
-    }
-  }
-});
-
-// Configure multer for video uploads (larger file size limit)
-const videoUpload = multer({
-  storage: storage,
-  limits: { fileSize: 500 * 1024 * 1024 }, // 500MB limit for videos
-  fileFilter: (req, file, cb) => {
-    // Aceitar v√≠deos
-    if (file.mimetype.startsWith('video/')) {
-      console.log(`üé• Upload de v√≠deo detectado: ${file.originalname} (mimetype: ${file.mimetype})`);
       cb(null, true);
     } else {
-      // Tamb√©m verificar por extens√£o
-      const ext = path.extname(file.originalname).toLowerCase();
-      const videoExts = ['.mp4', '.webm', '.ogg', '.mov', '.avi', '.mkv', '.flv', '.wmv', '.m4v'];
-      if (videoExts.includes(ext)) {
-        console.log(`üé• Upload de v√≠deo por extens√£o: ${file.originalname} (mimetype: ${file.mimetype}, extens√£o: ${ext})`);
-        cb(null, true);
-      } else {
-        console.warn(`‚ö†Ô∏è Arquivo de v√≠deo rejeitado: ${file.originalname} (mimetype: ${file.mimetype}, extens√£o: ${ext})`);
-        cb(new Error('Only video files are allowed!'), false);
-      }
+      cb(new Error('Only image files are allowed!'), false);
     }
   }
 });
 
-// MySQL connection pool
-// IMPORTANTE:
-//  - Nunca deixar senhas reais como valor padr√£o no c√≥digo
-//  - Priorizar vari√°veis de ambiente (MYSQL_* ou DB_*)
+// MySQL connection pool - Configurado para servidor remoto
 const pool = mysql.createPool({
-  host: process.env.MYSQL_HOST || process.env.DB_HOST || '127.0.0.1',
-  user: process.env.MYSQL_USER || process.env.DB_USER || 'root',
-  // N√£o definir senha real como fallback; em desenvolvimento o .env deve preencher
-  password: process.env.MYSQL_PASSWORD || process.env.DB_PASSWORD || '',
-  database: process.env.MYSQL_DATABASE || process.env.DB_NAME || 'rare_toy_companion',
-  port: parseInt(process.env.MYSQL_PORT || process.env.DB_PORT || '3306'),
+  host: process.env.MYSQL_HOST,
+  user: process.env.MYSQL_USER,
+  password: process.env.MYSQL_PASSWORD,
+  database: process.env.MYSQL_DATABASE,
+  port: parseInt(process.env.MYSQL_PORT || '3306'),
   waitForConnections: true,
   connectionLimit: 10,
   queueLimit: 0,
   ssl: false,
-  charset: 'utf8mb4'
+  charset: 'utf8mb4',
+  connectTimeout: 10000
 });
 
-// Tornar o pool acess√≠vel a middlewares via app.locals
-app.locals.pool = pool;
-
 // Verifica√ß√£o de conex√£o com banco de dados
 pool.getConnection()
   .then(async (conn) => {
@@ -576,10 +252,10 @@ function transformCarouselItem(dbItem, req) {
     imagem: normalizeToThisOrigin(req, dbItem.image_url || ''),
     badge: dbItem.badge || 'Novo',
     descricao: dbItem.subtitle || '',
-    ativo: dbItem.is_active === 1 || dbItem.is_active === true || dbItem.active === 1 || dbItem.active === true,
+    ativo: dbItem.active === 1 || dbItem.active === true,
     order_index: dbItem.order_index || 0,
     button_text: dbItem.button_text || 'Ver Mais',
-    button_link: dbItem.button_link || dbItem.link_url || '#'
+    button_link: dbItem.button_link || '#'
   };
 }
 
@@ -626,9 +302,8 @@ app.get('/api/carousel', async (req, res) => {
 // GET /api/carousel/active - Get active carousel items only
 app.get('/api/carousel/active', async (req, res) => {
   try {
-    // CORRIGIDO: coluna √© 'active', n√£o 'is_active'
     const [rows] = await pool.execute(
-      'SELECT * FROM carousel_items WHERE is_active = 1 ORDER BY order_index ASC, created_at ASC'
+      'SELECT * FROM carousel_items WHERE active = true ORDER BY order_index ASC, created_at ASC'
     );
     const items = rows.map(row => transformCarouselItem(row, req));
     res.json(items);
@@ -835,651 +510,165 @@ app.post('/api/carousel/bulk', async (req, res) => {
   }
 });
 
-// ==================== VIDEO GALLERY API ====================
-
-// Transform database video to frontend format
-function transformVideoItem(dbItem, req) {
-  // Normalizar video_url (remover /api/ se presente e garantir caminho correto)
-  let videoUrl = dbItem.video_url || '';
-  if (videoUrl.startsWith('/api/lovable-uploads/')) {
-    videoUrl = videoUrl.replace('/api/lovable-uploads/', '/lovable-uploads/');
-  } else if (videoUrl.startsWith('lovable-uploads/')) {
-    videoUrl = '/' + videoUrl;
-  } else if (!videoUrl.startsWith('/') && !videoUrl.startsWith('http')) {
-    videoUrl = '/lovable-uploads/' + videoUrl;
-  }
-
-  return {
-    id: dbItem.id || '',
-    titulo: dbItem.titulo || '',
-    descricao: dbItem.descricao || '',
-    video_url: normalizeToThisOrigin(req, videoUrl),
-    thumbnail_url: normalizeToThisOrigin(req, dbItem.thumbnail_url || ''),
-    categoria: dbItem.categoria || '',
-    duracao: dbItem.duracao || 0,
-    ordem: dbItem.ordem || 0,
-    is_active: dbItem.is_active === 1 || dbItem.is_active === true,
-    visualizacoes: dbItem.visualizacoes || 0,
-    created_at: dbItem.created_at,
-    updated_at: dbItem.updated_at
-  };
-}
-
-// Transform frontend video to database format
-const transformVideoToDatabase = (item) => ({
-  id: item.id || null,
-  titulo: item.titulo || null,
-  descricao: item.descricao || null,
-  video_url: item.video_url || null,
-  thumbnail_url: item.thumbnail_url || null,
-  categoria: item.categoria || null,
-  duracao: item.duracao || 0,
-  ordem: item.ordem || 0,
-  is_active: item.is_active !== undefined ? item.is_active : true,
-  visualizacoes: item.visualizacoes || 0
-});
-
-// GET /api/videos - Get all videos
-app.get('/api/videos', async (req, res) => {
-  try {
-    console.log('üìπ [VIDEOS] GET /api/videos - Buscando v√≠deos...');
-    const [rows] = await pool.execute(
-      'SELECT * FROM video_gallery ORDER BY ordem ASC, created_at ASC'
-    );
-    console.log(`üìπ [VIDEOS] Encontrados ${rows.length} v√≠deos`);
-    const videos = rows.map(row => transformVideoItem(row, req));
-    res.json(videos);
-  } catch (error) {
-    console.error('‚ùå [VIDEOS] Error fetching videos:', error);
-    console.error('‚ùå [VIDEOS] Stack:', error.stack);
-    res.status(500).json({ error: 'Failed to fetch videos', message: error.message });
-  }
-});
-
-// GET /api/videos/active - Get active videos only
-app.get('/api/videos/active', async (req, res) => {
-  try {
-    const [rows] = await pool.execute(
-      'SELECT * FROM video_gallery WHERE is_active = 1 ORDER BY ordem ASC, created_at ASC'
-    );
-    const videos = rows.map(row => transformVideoItem(row, req));
-    res.json(videos);
-  } catch (error) {
-    console.error('Error fetching active videos:', error);
-    res.status(500).json({ error: 'Failed to fetch active videos' });
-  }
-});
-
-// GET /api/videos/:id - Get single video
-app.get('/api/videos/:id', async (req, res) => {
+// POST /api/upload - Upload image
+app.post('/api/upload', upload.single('image'), (req, res) => {
   try {
-    const { id } = req.params;
-    const [rows] = await pool.execute('SELECT * FROM video_gallery WHERE id = ?', [id]);
-    if (rows.length === 0) {
-      return res.status(404).json({ error: 'Video not found' });
+    if (!req.file) {
+      return res.status(400).json({ error: 'No file uploaded' });
     }
-    const video = transformVideoItem(rows[0], req);
-    res.json(video);
+
+    const imageUrl = `/lovable-uploads/${req.file.filename}`;
+    res.json({
+      success: true,
+      imageUrl: imageUrl,
+      filename: req.file.filename
+    });
   } catch (error) {
-    console.error('Error fetching video:', error);
-    res.status(500).json({ error: 'Failed to fetch video' });
+    console.error('Upload error:', error);
+    res.status(500).json({ error: 'Upload failed', message: error.message });
   }
 });
 
-// POST /api/videos - Create new video
-app.post('/api/videos', async (req, res) => {
-  try {
-    console.log('üìπ [VIDEOS] POST /api/videos - Criando v√≠deo...');
-    console.log('üìπ [VIDEOS] Body recebido:', JSON.stringify(req.body, null, 2));
-
-    const video = req.body;
-    const dbVideo = filterUndefined(transformVideoToDatabase(video));
-    const newId = require('crypto').randomUUID();
-
-    console.log('üìπ [VIDEOS] Dados transformados:', JSON.stringify(dbVideo, null, 2));
-    console.log('üìπ [VIDEOS] Novo ID:', newId);
+// ==================== PRODUTOS API ====================
 
-    const [result] = await pool.execute(
-      `INSERT INTO video_gallery 
-       (id, titulo, descricao, video_url, thumbnail_url, categoria, duracao, ordem, is_active, visualizacoes, created_at, updated_at)
-       VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, NOW(), NOW())`,
-      [
-        newId,
-        dbVideo.titulo ?? null,
-        dbVideo.descricao ?? null,
-        dbVideo.video_url ?? null,
-        dbVideo.thumbnail_url ?? null,
-        dbVideo.categoria ?? null,
-        dbVideo.duracao ?? 0,
-        dbVideo.ordem ?? 0,
-        dbVideo.is_active ?? true,
-        dbVideo.visualizacoes ?? 0
-      ]
-    );
+// Buscar todos os produtos
+// Cache de produtos (1 minuto)
+const productsCacheMiddleware = redisCache.cacheMiddleware(60);
 
-    console.log('üìπ [VIDEOS] Insert result:', result);
+app.get('/api/produtos', productsLimiter, productsCacheMiddleware, async (req, res) => {
+  try {
+    console.log('üîÑ Buscando produtos...');
+    const [rows] = await pool.execute(`
+      SELECT 
+        id, nome, descricao, preco, imagem_url as imagemUrl, categoria, estoque, 
+        status, destaque, promocao, lancamento, avaliacao, total_avaliacoes as totalAvaliacoes,
+        faixa_etaria as faixaEtaria, peso, dimensoes, material, marca, origem, fornecedor,
+        codigo_barras as codigoBarras, data_lancamento as dataLancamento, created_at as createdAt, updated_at as updatedAt
+      FROM produtos 
+      ORDER BY created_at DESC
+    `);
 
-    // Fetch the created video
-    const [rows] = await pool.execute('SELECT * FROM video_gallery WHERE id = ?', [newId]);
-    if (rows.length === 0) {
-      throw new Error('Video was not created');
-    }
+    console.log(`‚úÖ ${rows.length} produtos encontrados`);
 
-    const createdVideo = transformVideoItem(rows[0], req);
-    console.log('‚úÖ [VIDEOS] V√≠deo criado com sucesso:', createdVideo.id);
+    // Converter pre√ßos de string para number e corrigir URLs de imagem
+    const produtos = rows.map(produto => ({
+      ...produto,
+      preco: parseFloat(produto.preco),
+      avaliacao: produto.avaliacao ? parseFloat(produto.avaliacao) : null,
+      imagemUrl: produto.imagemUrl ? getPublicUrl(req, produto.imagemUrl) : null
+    }));
 
-    res.status(201).json(createdVideo);
+    res.json(produtos);
   } catch (error) {
-    console.error('‚ùå [VIDEOS] Error creating video:', error);
-    console.error('‚ùå [VIDEOS] Stack:', error.stack);
-    res.status(500).json({ error: 'Failed to create video', message: error.message });
+    console.error('‚ùå Erro ao buscar produtos:', error);
+    res.status(500).json({ error: 'Erro interno do servidor' });
   }
 });
 
-// PUT /api/videos/:id - Update video
-app.put('/api/videos/:id', async (req, res) => {
+// Buscar produtos em destaque
+app.get('/api/produtos/destaque', async (req, res) => {
   try {
-    const { id } = req.params;
-    const video = req.body;
-    const dbVideo = filterUndefined(transformVideoToDatabase(video));
+    console.log('üîÑ Buscando produtos em destaque...');
 
-    await pool.execute(
-      `UPDATE video_gallery 
-       SET titulo = ?, descricao = ?, video_url = ?, thumbnail_url = ?, categoria = ?, 
-           duracao = ?, ordem = ?, is_active = ?, updated_at = NOW()
-       WHERE id = ?`,
-      [
-        dbVideo.titulo ?? null,
-        dbVideo.descricao ?? null,
-        dbVideo.video_url ?? null,
-        dbVideo.thumbnail_url ?? null,
-        dbVideo.categoria ?? null,
-        dbVideo.duracao ?? 0,
-        dbVideo.ordem ?? 0,
-        dbVideo.is_active ?? true,
-        id
-      ]
+    const [rows] = await pool.execute(
+      'SELECT *, imagem_url as imagemUrl, total_avaliacoes as totalAvaliacoes, faixa_etaria as faixaEtaria, codigo_barras as codigoBarras, data_lancamento as dataLancamento, created_at as createdAt, updated_at as updatedAt FROM produtos WHERE destaque = true ORDER BY created_at DESC'
     );
 
-    // Fetch the updated video
-    const [rows] = await pool.execute('SELECT * FROM video_gallery WHERE id = ?', [id]);
-    if (rows.length === 0) {
-      return res.status(404).json({ error: 'Video not found' });
-    }
+    console.log(`‚úÖ ${rows.length} produtos em destaque encontrados`);
+
+    // Converter pre√ßos de string para number e corrigir URLs de imagem
+    const produtos = rows.map(produto => ({
+      ...produto,
+      preco: parseFloat(produto.preco),
+      avaliacao: produto.avaliacao ? parseFloat(produto.avaliacao) : null,
+      imagemUrl: produto.imagemUrl ? getPublicUrl(req, produto.imagemUrl) : null
+    }));
 
-    const updatedVideo = transformVideoItem(rows[0], req);
-    res.json(updatedVideo);
+    res.json(produtos);
   } catch (error) {
-    console.error('Error updating video:', error);
-    res.status(500).json({ error: 'Failed to update video', message: error.message });
+    console.error('‚ùå Erro ao buscar produtos em destaque:', error);
+    res.status(500).json({ error: 'Erro interno do servidor' });
   }
 });
 
-// DELETE /api/videos/:id - Delete video
-app.delete('/api/videos/:id', async (req, res) => {
+// Buscar todas as categorias com contagem de produtos (P√öBLICO)
+app.get('/api/categorias', async (req, res) => {
   try {
-    const { id } = req.params;
+    console.log('üîÑ Buscando categorias p√∫blicas...');
+
+    // Buscar categorias da tabela com estat√≠sticas de produtos
+    const [categorias] = await pool.query(`
+      SELECT 
+        c.id,
+        c.nome,
+        c.slug,
+        c.descricao,
+        c.icon,
+        c.cor,
+        c.imagem_url,
+        c.ordem,
+        COALESCE(COUNT(DISTINCT p.id), 0) as quantidade,
+        COALESCE(MIN(p.preco), 0) as precoMinimo,
+        COALESCE(MAX(p.preco), 0) as precoMaximo,
+        COALESCE(AVG(p.avaliacao), 0) as avaliacaoMedia,
+        MAX(p.created_at) as ultimoProduto
+      FROM \`categorias\` c
+      LEFT JOIN \`produtos\` p ON p.categoria = c.nome AND p.status = 'ativo'
+      WHERE c.ativo = TRUE
+      GROUP BY c.id
+      ORDER BY c.ordem ASC, c.nome ASC
+    `);
 
-    const [result] = await pool.execute('DELETE FROM video_gallery WHERE id = ?', [id]);
+    console.log(`‚úÖ ${categorias.length} categorias encontradas`);
 
-    if (result.affectedRows === 0) {
-      return res.status(404).json({ error: 'Video not found' });
-    }
+    // Formatar resposta
+    const categoriasFormatadas = categorias.map(categoria => ({
+      id: categoria.slug || categoria.id,
+      nome: categoria.nome,
+      slug: categoria.slug,
+      descricao: categoria.descricao || `Encontre ${categoria.quantidade} produtos incr√≠veis`,
+      icon: categoria.icon,
+      cor: categoria.cor,
+      imagem_url: categoria.imagem_url ? getPublicUrl(req, categoria.imagem_url) : null,
+      quantidade: parseInt(categoria.quantidade),
+      precoMinimo: parseFloat(categoria.precoMinimo),
+      precoMaximo: parseFloat(categoria.precoMaximo),
+      avaliacaoMedia: categoria.avaliacaoMedia && categoria.quantidade > 0
+        ? parseFloat(categoria.avaliacaoMedia).toFixed(1)
+        : null,
+      ultimoProduto: categoria.ultimoProduto
+    }));
 
-    res.json({ success: true });
+    res.json(categoriasFormatadas);
   } catch (error) {
-    console.error('Error deleting video:', error);
-    res.status(500).json({ error: 'Failed to delete video' });
+    console.error('‚ùå Erro ao buscar categorias:', error);
+    res.status(500).json({ error: 'Erro interno do servidor' });
   }
 });
 
-// PUT /api/videos/:id/toggle - Toggle video active status
-app.put('/api/videos/:id/toggle', async (req, res) => {
-  try {
-    const { id } = req.params;
-    const { is_active } = req.body;
-
-    await pool.execute(
-      'UPDATE video_gallery SET is_active = ?, updated_at = NOW() WHERE id = ?',
-      [is_active ?? true, id]
-    );
+// ============================================================
+// NOVA API DE CATEGORIAS COM GERENCIAMENTO COMPLETO
+// ============================================================
 
-    // Fetch the updated video
-    const [rows] = await pool.execute('SELECT * FROM video_gallery WHERE id = ?', [id]);
-    if (rows.length === 0) {
-      return res.status(404).json({ error: 'Video not found' });
-    }
+// GET /api/categorias/nomes - Listar apenas nomes das categorias ativas (para dropdowns)
+app.get('/api/categorias/nomes', async (req, res) => {
+  try {
+    const [categorias] = await pool.execute(`
+      SELECT nome, slug, icon, cor 
+      FROM categorias 
+      WHERE ativo = TRUE 
+      ORDER BY ordem ASC, nome ASC
+    `);
 
-    const updatedVideo = transformVideoItem(rows[0], req);
-    res.json(updatedVideo);
+    res.json(categorias.map(c => c.nome));
   } catch (error) {
-    console.error('Error toggling video:', error);
-    res.status(500).json({ error: 'Failed to toggle video', message: error.message });
+    console.error('‚ùå Erro ao buscar nomes de categorias:', error);
+    res.status(500).json({ error: 'Erro interno do servidor' });
   }
 });
 
-// POST /api/videos/bulk - Save all videos (bulk update)
-app.post('/api/videos/bulk', async (req, res) => {
-  try {
-    const videos = req.body;
-
-    // Start transaction
-    const connection = await pool.getConnection();
-    await connection.beginTransaction();
-
-    try {
-      // Get all existing videos
-      const [existingRows] = await connection.execute('SELECT id FROM video_gallery');
-      const existingIds = new Set(existingRows.map(row => row.id));
-      const newVideoIds = new Set(videos.map(v => v.id));
-
-      // Delete videos that were removed
-      for (const existingId of existingIds) {
-        if (!newVideoIds.has(existingId)) {
-          await connection.execute('DELETE FROM video_gallery WHERE id = ?', [existingId]);
-        }
-      }
-
-      // Update or create videos
-      for (let i = 0; i < videos.length; i++) {
-        const video = { ...videos[i], ordem: i };
-        const dbVideo = filterUndefined(transformVideoToDatabase(video));
-
-        if (existingIds.has(video.id)) {
-          // Update existing video
-          await connection.execute(
-            `UPDATE video_gallery 
-             SET titulo = ?, descricao = ?, video_url = ?, thumbnail_url = ?, categoria = ?, 
-                 duracao = ?, ordem = ?, is_active = ?, updated_at = NOW()
-             WHERE id = ?`,
-            [
-              dbVideo.titulo ?? null,
-              dbVideo.descricao ?? null,
-              dbVideo.video_url ?? null,
-              dbVideo.thumbnail_url ?? null,
-              dbVideo.categoria ?? null,
-              dbVideo.duracao ?? 0,
-              dbVideo.ordem ?? 0,
-              dbVideo.is_active ?? true,
-              video.id
-            ]
-          );
-        } else {
-          // Create new video
-          await connection.execute(
-            `INSERT INTO video_gallery 
-             (id, titulo, descricao, video_url, thumbnail_url, categoria, duracao, ordem, is_active, visualizacoes, created_at, updated_at)
-             VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, NOW(), NOW())`,
-            [
-              video.id,
-              dbVideo.titulo ?? null,
-              dbVideo.descricao ?? null,
-              dbVideo.video_url ?? null,
-              dbVideo.thumbnail_url ?? null,
-              dbVideo.categoria ?? null,
-              dbVideo.duracao ?? 0,
-              dbVideo.ordem ?? 0,
-              dbVideo.is_active ?? true,
-              dbVideo.visualizacoes ?? 0
-            ]
-          );
-        }
-      }
-
-      await connection.commit();
-      res.json({ success: true });
-    } catch (error) {
-      await connection.rollback();
-      throw error;
-    } finally {
-      connection.release();
-    }
-  } catch (error) {
-    console.error('Error saving videos:', error);
-    res.status(500).json({ error: 'Failed to save videos' });
-  }
-});
-
-// PUT /api/videos/:id/increment-views - Increment video views
-app.put('/api/videos/:id/increment-views', async (req, res) => {
-  try {
-    const { id } = req.params;
-
-    await pool.execute(
-      'UPDATE video_gallery SET visualizacoes = visualizacoes + 1 WHERE id = ?',
-      [id]
-    );
-
-    const [rows] = await pool.execute('SELECT * FROM video_gallery WHERE id = ?', [id]);
-    if (rows.length === 0) {
-      return res.status(404).json({ error: 'Video not found' });
-    }
-
-    const video = transformVideoItem(rows[0], req);
-    res.json(video);
-  } catch (error) {
-    console.error('Error incrementing video views:', error);
-    res.status(500).json({ error: 'Failed to increment views' });
-  }
-});
-
-// POST /api/upload - Upload image
-app.post('/api/upload', upload.single('image'), (req, res) => {
-  try {
-    console.log('üì§ [UPLOAD] Recebendo requisi√ß√£o de upload...');
-    console.log('üì§ [UPLOAD] File recebido:', req.file ? {
-      filename: req.file.filename,
-      originalname: req.file.originalname,
-      mimetype: req.file.mimetype,
-      size: req.file.size,
-      path: req.file.path
-    } : 'Nenhum arquivo');
-
-    if (!req.file) {
-      console.error('‚ùå [UPLOAD] Nenhum arquivo recebido');
-      return res.status(400).json({ error: 'No file uploaded' });
-    }
-
-    const imageUrl = `/lovable-uploads/${req.file.filename}`;
-    const response = {
-      success: true,
-      imageUrl: imageUrl,
-      filename: req.file.filename
-    };
-
-    console.log('‚úÖ [UPLOAD] Upload bem-sucedido:', {
-      filename: req.file.filename,
-      imageUrl: imageUrl,
-      fullPath: req.file.path,
-      fileExists: fs.existsSync(req.file.path)
-    });
-
-    res.json(response);
-  } catch (error) {
-    console.error('‚ùå [UPLOAD] Erro no upload:', error);
-    console.error('‚ùå [UPLOAD] Stack:', error.stack);
-    res.status(500).json({ error: 'Upload failed', message: error.message });
-  }
-});
-
-// POST /api/upload/video - Upload video
-app.post('/api/upload/video', videoUpload.single('video'), (req, res) => {
-  try {
-    console.log('üé• [VIDEO UPLOAD] Recebendo requisi√ß√£o de upload de v√≠deo...');
-    console.log('üé• [VIDEO UPLOAD] File recebido:', req.file ? {
-      filename: req.file.filename,
-      originalname: req.file.originalname,
-      mimetype: req.file.mimetype,
-      size: req.file.size,
-      path: req.file.path
-    } : 'Nenhum arquivo');
-
-    if (!req.file) {
-      console.error('‚ùå [VIDEO UPLOAD] Nenhum arquivo recebido');
-      return res.status(400).json({ error: 'No video file uploaded' });
-    }
-
-    const videoUrl = `/lovable-uploads/${req.file.filename}`;
-    const response = {
-      success: true,
-      videoUrl: videoUrl,
-      filename: req.file.filename,
-      size: req.file.size,
-      mimetype: req.file.mimetype
-    };
-
-    console.log('‚úÖ [VIDEO UPLOAD] Upload bem-sucedido:', {
-      filename: req.file.filename,
-      videoUrl: videoUrl,
-      fullPath: req.file.path,
-      fileExists: fs.existsSync(req.file.path),
-      size: `${(req.file.size / 1024 / 1024).toFixed(2)} MB`
-    });
-
-    res.json(response);
-  } catch (error) {
-    console.error('‚ùå [VIDEO UPLOAD] Erro no upload:', error);
-    console.error('‚ùå [VIDEO UPLOAD] Stack:', error.stack);
-    res.status(500).json({ error: 'Video upload failed', message: error.message });
-  }
-});
-
-// ==================== PRODUTOS API ====================
-
-// Buscar todos os produtos
-// Cache de produtos (1 minuto)
-const productsCacheMiddleware = redisCache.cacheMiddleware(60);
-
-app.get('/api/produtos', productsLimiter, productsCacheMiddleware, async (req, res) => {
-  try {
-    const {
-      page: pageRaw,
-      pageSize: pageSizeRaw,
-      search = '',
-      categoria = '',
-      sort = 'created_at_desc',
-      inStock,
-      onSale,
-      featured,
-      novo
-    } = req.query || {};
-
-    const page = Math.max(parseInt(pageRaw, 10) || 0, 0);
-    const pageSize = Math.min(Math.max(parseInt(pageSizeRaw, 10) || 0, 1), 100);
-
-    const whereParts = [];
-    const params = [];
-
-    if (search) {
-      whereParts.push('(LOWER(nome) LIKE ? OR LOWER(categoria) LIKE ? OR LOWER(descricao) LIKE ?)');
-      const s = `%${String(search).toLowerCase()}%`;
-      params.push(s, s, s);
-    }
-    if (categoria) {
-      whereParts.push('categoria = ?');
-      params.push(String(categoria));
-    }
-    if (inStock === 'true') {
-      whereParts.push('estoque > 0');
-    }
-    if (onSale === 'true') {
-      whereParts.push('promocao = 1');
-    }
-    if (featured === 'true') {
-      whereParts.push('destaque = 1');
-    }
-    if (novo === 'true') {
-      whereParts.push('lancamento = 1');
-    }
-
-    const whereSql = whereParts.length > 0 ? `WHERE ${whereParts.join(' AND ')}` : '';
-
-    // Ordena√ß√£o segura (whitelist)
-    const sortMap = {
-      created_at_desc: 'created_at DESC',
-      created_at_asc: 'created_at ASC',
-      nome_asc: 'nome ASC',
-      nome_desc: 'nome DESC',
-      preco_asc: 'preco ASC',
-      preco_desc: 'preco DESC',
-    };
-    const orderBy = sortMap[String(sort)] || sortMap.created_at_desc;
-
-    // Caso sem pagina√ß√£o: mant√©m retorno antigo (array)
-    if (!page || !pageSize) {
-      console.log('üîÑ Buscando produtos (sem pagina√ß√£o)...');
-      const [rows] = await pool.execute(
-        `SELECT id, nome, descricao, preco, imagem_url as imagemUrl, categoria, estoque,
-                status, destaque, promocao, lancamento, avaliacao, total_avaliacoes as totalAvaliacoes,
-                faixa_etaria as faixaEtaria, peso, dimensoes, material, marca, origem, fornecedor,
-                codigo_barras as codigoBarras, data_lancamento as dataLancamento,
-                created_at as createdAt, updated_at as updatedAt
-           FROM produtos ${whereSql}
-           ORDER BY ${orderBy}`,
-        params
-      );
-      const produtos = rows.map((p) => ({
-        ...p,
-        preco: parseFloat(p.preco),
-        avaliacao: p.avaliacao ? parseFloat(p.avaliacao) : null,
-        imagemUrl: p.imagemUrl ? getPublicUrl(req, p.imagemUrl) : null,
-      }));
-      return res.json(produtos);
-    }
-
-    console.log('üîÑ Buscando produtos (com pagina√ß√£o)...');
-    // Total
-    const [countRows] = await pool.execute(`SELECT COUNT(*) as total FROM produtos ${whereSql}`, params);
-    const total = Number(countRows?.[0]?.total || 0);
-
-    // P√°gina
-    const offset = Math.max(0, (page - 1) * pageSize);
-    // Garantir que pageSize e offset sejam n√∫meros inteiros (parseInt para garantir tipo correto)
-    const limitInt = parseInt(String(pageSize), 10);
-    const offsetInt = parseInt(String(offset), 10);
-    // Usar valores diretos para LIMIT e OFFSET (s√£o seguros pois s√£o n√∫meros validados)
-    const [rows] = await pool.execute(
-      `SELECT id, nome, descricao, preco, imagem_url as imagemUrl, categoria, estoque,
-              status, destaque, promocao, lancamento, avaliacao, total_avaliacoes as totalAvaliacoes,
-              faixa_etaria as faixaEtaria, peso, dimensoes, material, marca, origem, fornecedor,
-              codigo_barras as codigoBarras, data_lancamento as dataLancamento,
-              created_at as createdAt, updated_at as updatedAt
-         FROM produtos ${whereSql}
-         ORDER BY ${orderBy}
-         LIMIT ${limitInt} OFFSET ${offsetInt}`,
-      params
-    );
-
-    const itens = rows.map((p) => ({
-      ...p,
-      preco: parseFloat(p.preco),
-      avaliacao: p.avaliacao ? parseFloat(p.avaliacao) : null,
-      imagemUrl: p.imagemUrl ? getPublicUrl(req, p.imagemUrl) : null,
-    }));
-
-    res.json({ items: itens, total, page, pageSize });
-  } catch (error) {
-    console.error('‚ùå Erro ao buscar produtos:', error);
-    res.status(500).json({ error: 'Erro interno do servidor' });
-  }
-});
-
-// Buscar produtos em destaque
-app.get('/api/produtos/destaque', async (req, res) => {
-  try {
-    console.log('üîÑ Buscando produtos em destaque...');
-
-    const [rows] = await pool.execute(
-      'SELECT *, imagem_url as imagemUrl, total_avaliacoes as totalAvaliacoes, faixa_etaria as faixaEtaria, codigo_barras as codigoBarras, data_lancamento as dataLancamento, created_at as createdAt, updated_at as updatedAt FROM produtos WHERE destaque = true ORDER BY created_at DESC'
-    );
-
-    console.log(`‚úÖ ${rows.length} produtos em destaque encontrados`);
-
-    // Converter pre√ßos de string para number e corrigir URLs de imagem
-    const produtos = rows.map(produto => ({
-      ...produto,
-      preco: parseFloat(produto.preco),
-      avaliacao: produto.avaliacao ? parseFloat(produto.avaliacao) : null,
-      imagemUrl: produto.imagemUrl ? getPublicUrl(req, produto.imagemUrl) : null
-    }));
-
-    res.json(produtos);
-  } catch (error) {
-    console.error('‚ùå Erro ao buscar produtos em destaque:', error);
-    res.status(500).json({ error: 'Erro interno do servidor' });
-  }
-});
-
-// Buscar todas as categorias com contagem de produtos (P√öBLICO)
-app.get('/api/categorias', async (req, res) => {
-  try {
-    // Tentar cache primeiro
-    const cacheHelpers = require('./utils/cacheHelpers.cjs');
-    const cached = await cacheHelpers.getCachedCategories();
-
-    if (cached) {
-      console.log('‚úÖ Categorias do cache');
-      return res.json(cached);
-    }
-
-    console.log('üîÑ Buscando categorias p√∫blicas...');
-
-    // Buscar categorias da tabela com estat√≠sticas de produtos
-    const [categorias] = await pool.query(`
-      SELECT 
-        c.id,
-        c.nome,
-        c.slug,
-        c.descricao,
-        c.icon,
-        c.cor,
-        c.imagem_url,
-        c.ordem,
-        COALESCE(COUNT(DISTINCT p.id), 0) as quantidade,
-        COALESCE(MIN(p.preco), 0) as precoMinimo,
-        COALESCE(MAX(p.preco), 0) as precoMaximo,
-        COALESCE(AVG(p.avaliacao), 0) as avaliacaoMedia,
-        MAX(p.created_at) as ultimoProduto
-      FROM \`categorias\` c
-      LEFT JOIN \`produtos\` p ON p.categoria = c.nome AND p.status = 'ativo'
-      WHERE c.ativo = TRUE
-      GROUP BY c.id
-      ORDER BY c.ordem ASC, c.nome ASC
-    `);
-
-    console.log(`‚úÖ ${categorias.length} categorias encontradas`);
-
-    // Formatar resposta
-    const categoriasFormatadas = categorias.map(categoria => ({
-      id: categoria.slug || categoria.id,
-      nome: categoria.nome,
-      slug: categoria.slug,
-      descricao: categoria.descricao || `Encontre ${categoria.quantidade} produtos incr√≠veis`,
-      icon: categoria.icon,
-      cor: categoria.cor,
-      imagem_url: categoria.imagem_url ? getPublicUrl(req, categoria.imagem_url) : null,
-      quantidade: parseInt(categoria.quantidade),
-      precoMinimo: parseFloat(categoria.precoMinimo),
-      precoMaximo: parseFloat(categoria.precoMaximo),
-      avaliacaoMedia: categoria.avaliacaoMedia && categoria.quantidade > 0
-        ? parseFloat(categoria.avaliacaoMedia).toFixed(1)
-        : null,
-      ultimoProduto: categoria.ultimoProduto
-    }));
-
-    // Cachear resultado
-    await cacheHelpers.setCachedCategories(categoriasFormatadas);
-
-    res.json(categoriasFormatadas);
-  } catch (error) {
-    console.error('‚ùå Erro ao buscar categorias:', error);
-    res.status(500).json({ error: 'Erro interno do servidor' });
-  }
-});
-
-// ============================================================
-// NOVA API DE CATEGORIAS COM GERENCIAMENTO COMPLETO
-// ============================================================
-
-// GET /api/categorias/nomes - Listar apenas nomes das categorias ativas (para dropdowns)
-app.get('/api/categorias/nomes', async (req, res) => {
-  try {
-    const [categorias] = await pool.execute(`
-      SELECT nome, slug, icon, cor 
-      FROM categorias 
-      WHERE ativo = TRUE 
-      ORDER BY ordem ASC, nome ASC
-    `);
-
-    res.json(categorias.map(c => c.nome));
-  } catch (error) {
-    console.error('‚ùå Erro ao buscar nomes de categorias:', error);
-    res.status(500).json({ error: 'Erro interno do servidor' });
-  }
-});
-
-// GET /api/categorias/lista - Listar categorias para dropdown (nome + detalhes)
-app.get('/api/categorias/lista', async (req, res) => {
+// GET /api/categorias/lista - Listar categorias para dropdown (nome + detalhes)
+app.get('/api/categorias/lista', async (req, res) => {
   try {
     const [categorias] = await pool.execute(`
       SELECT id, nome, slug, icon, cor 
@@ -1970,16 +1159,6 @@ app.get('/api/compras-recentes', async (req, res) => {
 app.get('/api/produtos/:id', async (req, res) => {
   try {
     const { id } = req.params;
-
-    // Tentar cache primeiro
-    const cacheHelpers = require('./utils/cacheHelpers.cjs');
-    const cached = await cacheHelpers.getCachedProduct(id);
-
-    if (cached) {
-      console.log(`‚úÖ Produto ${id} do cache`);
-      return res.json(cached);
-    }
-
     console.log(`üîÑ Buscando produto ID: ${id}`);
 
     const [rows] = await pool.execute(
@@ -2001,9 +1180,6 @@ app.get('/api/produtos/:id', async (req, res) => {
       imagemUrl: rows[0].imagemUrl ? getPublicUrl(req, rows[0].imagemUrl) : null
     };
 
-    // Cachear resultado
-    await cacheHelpers.setCachedProduct(id, produto);
-
     res.json(produto);
   } catch (error) {
     console.error('‚ùå Erro ao buscar produto:', error);
@@ -2014,33 +1190,26 @@ app.get('/api/produtos/:id', async (req, res) => {
 // Criar novo produto
 // ==================== QUICK ADD PRODUCT (MOBILE-FIRST) ====================
 
-// MIDDLEWARE GLOBAL PARA DEBUG - Capturar TODAS as requisi√ß√µes POST para /api/produtos
-app.use('/api/produtos/quick-add', (req, res, next) => {
-  console.log('üö®üö®üö® MIDDLEWARE GLOBAL CAPTURADO: POST /api/produtos/quick-add');
-  console.log('üö® Method:', req.method);
-  console.log('üö® Path:', req.path);
-  console.log('üö® Original URL:', req.originalUrl);
-  next();
-});
-
 // Cadastro r√°pido de produto (mobile-optimized)
-// TESTE: Vers√£o sem middleware de upload para isolar problema
-app.post('/api/produtos/quick-add-test', async (req, res) => {
-  console.log('üîµüîµüîµ POST /api/produtos/quick-add-test - HANDLER TESTE (SEM UPLOAD)');
-  console.log('üìä Body:', req.body);
-  console.log('üìä Headers:', req.headers);
-
+app.post('/api/produtos/quick-add', upload.single('imagem'), async (req, res) => {
   try {
     const { nome, preco, estoque, categoria, status } = req.body;
     const id = crypto.randomUUID();
 
-    console.log('‚ö° Cadastro r√°pido (teste):', nome);
+    console.log('‚ö° Cadastro r√°pido:', nome);
+
+    // URL da imagem (se enviou)
+    let imagemUrl = null;
+    if (req.file) {
+      imagemUrl = `/lovable-uploads/${req.file.filename}`;
+      console.log('üì∏ Foto capturada:', imagemUrl);
+    }
 
-    // Buscar categoria_id
+    // Buscar categoria_id pelo nome ou usar a primeira dispon√≠vel
     let categoria_id = null;
     if (categoria) {
       const [catRows] = await pool.execute(
-        'SELECT id FROM `rare_toy_companion`.`categorias` WHERE nome = ? OR slug = ? LIMIT 1',
+        'SELECT id FROM categorias WHERE nome = ? OR slug = ? LIMIT 1',
         [categoria, categoria]
       );
       if (catRows.length > 0) {
@@ -2048,203 +1217,40 @@ app.post('/api/produtos/quick-add-test', async (req, res) => {
       }
     }
 
+    // Se n√£o encontrou, usa a primeira categoria dispon√≠vel
     if (!categoria_id) {
       const [firstCat] = await pool.execute(
-        'SELECT id, nome FROM `rare_toy_companion`.`categorias` WHERE ativo = 1 ORDER BY ordem LIMIT 1'
+        'SELECT id, nome FROM categorias WHERE ativo = 1 ORDER BY ordem LIMIT 1'
       );
       if (firstCat.length > 0) {
         categoria_id = firstCat[0].id;
+        console.log(`üì¶ Usando categoria padr√£o: ${firstCat[0].nome} (ID: ${categoria_id})`);
+      } else {
+        return res.status(400).json({ error: 'Nenhuma categoria dispon√≠vel' });
       }
     }
 
-    console.log(`‚úÖ categoria_id: ${categoria_id}`);
-
-    // Inserir produto
-    let connection;
-    try {
-      connection = await pool.getConnection();
-      await connection.query('USE `rare_toy_companion`');
-
-      await connection.execute(`
-        INSERT INTO \`rare_toy_companion\`.\`produtos\` (
-          id, nome, preco, categoria, categoria_id, estoque, status,
-          destaque, promocao, lancamento
-        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
-      `, [
-        id, nome, Number(preco || 0), categoria || 'Outros', categoria_id,
-        Number(estoque || 1), status || 'ativo', false, false, false
-      ]);
-
-      connection.release();
-      console.log(`‚úÖ Produto inserido (teste)! ID: ${id}`);
-
-      res.json({ success: true, id, message: 'Produto cadastrado (teste)' });
-    } catch (insertError) {
-      if (connection) connection.release();
-      console.error('‚ùå Erro ao inserir (teste):', insertError);
-      throw insertError;
-    }
-  } catch (error) {
-    console.error('‚ùå Erro no quick-add-test:', error);
-    res.status(500).json({ error: 'Erro ao cadastrar produto (teste)', details: error.message });
-  }
-});
-
-// Vers√£o original com upload - multer opcional (n√£o obrigat√≥rio ter arquivo)
-app.post('/api/produtos/quick-add', (req, res, next) => {
-  console.log('üö®üö®üö® MIDDLEWARE ANTES DO MULTER');
-  console.log('üö® Method:', req.method);
-  console.log('üö® Path:', req.path);
-  console.log('üö® Content-Type:', req.headers['content-type']);
-  next();
-}, upload.single('imagem'), (err, req, res, next) => {
-  if (err) {
-    console.error('‚ùå‚ùå‚ùå ERRO NO MULTER:', err);
-    return res.status(400).json({ error: 'Erro no upload', details: err.message });
-  }
-  next();
-}, async (req, res) => {
-  console.log('üîµüîµüîµ POST /api/produtos/quick-add - HANDLER EXECUTADO');
-  console.log('üìä Body:', req.body);
-  console.log('üìä Headers:', req.headers);
-  console.log('üìä Content-Type:', req.headers['content-type']);
-  console.log('üìä File:', req.file ? req.file.filename : 'nenhum arquivo');
-
-  try {
-    const { nome, preco, estoque, categoria, status } = req.body;
-    const id = crypto.randomUUID();
-
-    console.log('‚ö° Cadastro r√°pido:', nome);
-    console.log('üìä Dados recebidos:', { nome, preco, estoque, categoria, status });
-
-    // URL da imagem (se enviou)
-    let imagemUrl = null;
-    if (req.file) {
-      imagemUrl = `/lovable-uploads/${req.file.filename}`;
-      console.log('üì∏ Foto capturada:', imagemUrl);
-    }
-
-    // Buscar categoria_id pelo nome ou usar a primeira dispon√≠vel
-    // Usar nome completo do banco para garantir
-    let categoria_id = null;
-    if (categoria) {
-      const [catRows] = await pool.execute(
-        'SELECT id FROM `rare_toy_companion`.`categorias` WHERE nome = ? OR slug = ? LIMIT 1',
-        [categoria, categoria]
-      );
-      if (catRows.length > 0) {
-        categoria_id = catRows[0].id;
-      }
-    }
-
-    // Se n√£o encontrou, usa a primeira categoria dispon√≠vel
-    if (!categoria_id) {
-      try {
-        const [firstCat] = await pool.execute(
-          'SELECT id, nome FROM `rare_toy_companion`.`categorias` WHERE ativo = 1 ORDER BY ordem LIMIT 1'
-        );
-        if (firstCat.length > 0) {
-          categoria_id = firstCat[0].id;
-          console.log(`üì¶ Usando categoria padr√£o: ${firstCat[0].nome} (ID: ${categoria_id})`);
-        } else {
-          console.log('‚ö†Ô∏è Nenhuma categoria ativa encontrada, tentando qualquer categoria...');
-          const [anyCat] = await pool.execute(
-            'SELECT id, nome FROM `rare_toy_companion`.`categorias` ORDER BY id LIMIT 1'
-          );
-          if (anyCat.length > 0) {
-            categoria_id = anyCat[0].id;
-            console.log(`üì¶ Usando primeira categoria dispon√≠vel: ${anyCat[0].nome} (ID: ${categoria_id})`);
-          } else {
-            return res.status(400).json({ error: 'Nenhuma categoria dispon√≠vel no banco de dados' });
-          }
-        }
-      } catch (catError) {
-        console.error('‚ùå Erro ao buscar categoria:', catError);
-        return res.status(500).json({ error: 'Erro ao buscar categoria', details: catError.message });
-      }
-    }
-
-    console.log(`‚úÖ categoria_id final: ${categoria_id}`);
-
-    // Inserir produto com campos m√≠nimos
-    // Usar conex√£o expl√≠cita e garantir banco correto
-    console.log(`üìù Inserindo produto no banco rare_toy_companion...`);
-    let connection;
-    try {
-      connection = await pool.getConnection();
-
-      // SEMPRE for√ßar uso do banco correto (n√£o confiar no banco padr√£o)
-      // Verificar banco atual primeiro
-      const [dbCheck] = await connection.query('SELECT DATABASE() as current_db');
-      const currentDb = dbCheck[0]?.current_db;
-      console.log(`üìä Banco atual da conex√£o ANTES do USE: ${currentDb}`);
-
-      // SEMPRE executar USE para garantir o banco correto
-      await connection.query('USE `rare_toy_companion`');
-      console.log(`‚úÖ USE rare_toy_companion executado`);
-
-      // Verificar novamente para confirmar
-      const [dbCheck2] = await connection.query('SELECT DATABASE() as current_db');
-      const finalDb = dbCheck2[0]?.current_db;
-      console.log(`üìä Banco atual da conex√£o AP√ìS o USE: ${finalDb}`);
-
-      if (finalDb !== 'rare_toy_companion') {
-        throw new Error(`Falha ao mudar para banco rare_toy_companion. Banco atual: ${finalDb}`);
-      }
-
-      // Inserir produto - usar apenas nome da tabela (banco j√° foi definido com USE)
-      console.log(`üìù Executando INSERT na tabela produtos do banco ${finalDb}...`);
-      console.log(`üìù Valores: id=${id}, nome=${nome}, categoria_id=${categoria_id}`);
-
-      // Tentar inserir SEM categoria_id primeiro para ver se funciona
-      // Se n√£o funcionar, tentar COM categoria_id
-      let result;
-      try {
-        // Primeiro, tentar inserir SEM categoria_id para ver se a tabela aceita
-        console.log(`üìù Tentativa 1: INSERT sem categoria_id...`);
-        result = await connection.query(`
-          INSERT INTO produtos (
-            id, nome, preco, categoria, imagem_url, estoque, status,
-            destaque, promocao, lancamento
-          ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
-        `, [
-          id, nome, Number(preco || 0), categoria || 'Outros', imagemUrl,
-          Number(estoque || 1), status || 'ativo', false, false, false
-        ]);
-        console.log(`‚úÖ Produto inserido SEM categoria_id! ID: ${id}`);
-      } catch (errorWithoutCat) {
-        console.log(`‚ö†Ô∏è Erro ao inserir sem categoria_id: ${errorWithoutCat.message}`);
-        // Se falhar, tentar COM categoria_id
-        console.log(`üìù Tentativa 2: INSERT COM categoria_id...`);
-        result = await connection.query(`
-      INSERT INTO produtos (
-        id, nome, preco, categoria, categoria_id, imagem_url, estoque, status,
-        destaque, promocao, lancamento
-      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
-    `, [
-          id, nome, Number(preco || 0), categoria || 'Outros', categoria_id,
-          imagemUrl, Number(estoque || 1), status || 'ativo', false, false, false
-        ]);
-        console.log(`‚úÖ Produto inserido COM categoria_id! ID: ${id}`);
-      }
-
-      console.log(`‚úÖ Produto inserido com sucesso! ID: ${id}, Result:`, result);
-      connection.release();
-    } catch (insertError) {
-      if (connection) connection.release();
-      console.error('‚ùå Erro ao inserir produto:', insertError);
-      console.error('‚ùå C√≥digo do erro:', insertError.code);
-      console.error('‚ùå Mensagem:', insertError.message);
-      throw insertError;
-    }
+    // Inserir produto com campos m√≠nimos
+    await pool.execute(`
+      INSERT INTO produtos (
+        id, nome, preco, categoria, imagem_url, estoque, status,
+        destaque, promocao, lancamento
+      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
+    `, [
+      id,
+      nome,
+      Number(preco || 0),
+      categoria || 'Outros',
+      imagemUrl,
+      Number(estoque || 1),
+      status || 'ativo',
+      false,
+      false,
+      false
+    ]);
 
     logger.info('Produto cadastrado rapidamente', { id, nome, mobile: true });
 
-    // Invalidar cache de produtos
-    const cacheHelpers = require('./utils/cacheHelpers.cjs');
-    await cacheHelpers.invalidateProductsCache();
-    await cacheHelpers.invalidateCategoriesCache();
-
     res.json({
       success: true,
       id,
@@ -2253,10 +1259,6 @@ app.post('/api/produtos/quick-add', (req, res, next) => {
     });
   } catch (error) {
     console.error('‚ùå Erro no quick-add:', error);
-    console.error('‚ùå Stack:', error.stack);
-    console.error('‚ùå C√≥digo do erro:', error.code);
-    console.error('‚ùå SQL State:', error.sqlState);
-    console.error('‚ùå SQL Message:', error.sqlMessage);
     logger.error('Erro no quick-add de produto', { error: error.message, stack: error.stack });
     res.status(500).json({ error: 'Erro ao cadastrar produto rapidamente', details: error.message });
   }
@@ -2268,11 +1270,10 @@ app.post('/api/produtos', async (req, res) => {
     console.log('üîÑ Criando produto:', produtoData.nome);
 
     // Buscar categoria_id pelo nome
-    // Usar nome completo do banco para garantir
     let categoria_id = null;
     if (produtoData.categoria) {
       const [catRows] = await pool.execute(
-        'SELECT id FROM `rare_toy_companion`.`categorias` WHERE nome = ? OR slug = ? LIMIT 1',
+        'SELECT id FROM categorias WHERE nome = ? OR slug = ? LIMIT 1',
         [produtoData.categoria, produtoData.categoria]
       );
       if (catRows.length > 0) {
@@ -2283,7 +1284,7 @@ app.post('/api/produtos', async (req, res) => {
     // Se n√£o encontrou, usa a primeira categoria dispon√≠vel
     if (!categoria_id) {
       const [firstCat] = await pool.execute(
-        'SELECT id FROM `rare_toy_companion`.`categorias` WHERE ativo = 1 ORDER BY ordem LIMIT 1'
+        'SELECT id FROM categorias WHERE ativo = 1 ORDER BY ordem LIMIT 1'
       );
       if (firstCat.length > 0) {
         categoria_id = firstCat[0].id;
@@ -2293,67 +1294,40 @@ app.post('/api/produtos', async (req, res) => {
     }
 
     // Criar produto com campos obrigat√≥rios
-    // Usar nome completo do banco para garantir
-    let connection;
-    try {
-      connection = await pool.getConnection();
-
-      // Verificar banco atual
-      const [dbCheck] = await connection.query('SELECT DATABASE() as current_db');
-      const currentDb = dbCheck[0]?.current_db;
-
-      // For√ßar uso do banco correto
-      if (currentDb !== 'rare_toy_companion') {
-        await connection.query('USE `rare_toy_companion`');
-      }
-
-      const [result] = await connection.execute(`
+    const [result] = await pool.execute(`
       INSERT INTO produtos (
-          id, nome, preco, categoria, categoria_id, imagem_url, descricao, estoque, status,
+        id, nome, preco, categoria, imagem_url, descricao, estoque, status,
         destaque, promocao, lancamento, avaliacao, total_avaliacoes,
         faixa_etaria, peso, dimensoes, material, marca, origem, fornecedor,
         codigo_barras, data_lancamento
-        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
+      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
     `, [
-        require('crypto').randomUUID(),
-        produtoData.nome,
-        produtoData.preco,
-        produtoData.categoria,
-        categoria_id,
-        produtoData.imagemUrl || null,
-        produtoData.descricao || null,
-        produtoData.estoque || 0,
-        produtoData.status || 'ativo',
-        produtoData.destaque || false,
-        produtoData.promocao || false,
-        produtoData.lancamento || false,
-        produtoData.avaliacao || 0,
-        produtoData.totalAvaliacoes || 0,
-        produtoData.faixaEtaria || null,
-        produtoData.peso || null,
-        produtoData.dimensoes || null,
-        produtoData.material || null,
-        produtoData.marca || null,
-        produtoData.origem || null,
-        produtoData.fornecedor || null,
-        produtoData.codigoBarras || null,
-        produtoData.dataLancamento || null
-      ]);
-
-      connection.release();
-
-      // Invalidar cache de produtos
-      const cacheHelpers = require('./utils/cacheHelpers.cjs');
-      await cacheHelpers.invalidateProductsCache();
-      await cacheHelpers.invalidateCategoriesCache();
+      require('crypto').randomUUID(),
+      produtoData.nome,
+      produtoData.preco,
+      produtoData.categoria,
+      produtoData.imagemUrl || null,
+      produtoData.descricao || null,
+      produtoData.estoque || 0,
+      produtoData.status || 'ativo',
+      produtoData.destaque || false,
+      produtoData.promocao || false,
+      produtoData.lancamento || false,
+      produtoData.avaliacao || 0,
+      produtoData.totalAvaliacoes || 0,
+      produtoData.faixaEtaria || null,
+      produtoData.peso || null,
+      produtoData.dimensoes || null,
+      produtoData.material || null,
+      produtoData.marca || null,
+      produtoData.origem || null,
+      produtoData.fornecedor || null,
+      produtoData.codigoBarras || null,
+      produtoData.dataLancamento || null
+    ]);
 
-      console.log('‚úÖ Produto criado com ID:', result.insertId);
-      res.status(201).json({ id: result.insertId, ...produtoData });
-    } catch (insertError) {
-      if (connection) connection.release();
-      console.error('‚ùå Erro ao inserir produto:', insertError);
-      throw insertError;
-    }
+    console.log('‚úÖ Produto criado com ID:', result.insertId);
+    res.status(201).json({ id: result.insertId, ...produtoData });
   } catch (error) {
     console.error('‚ùå Erro ao criar produto:', error);
     res.status(500).json({ error: 'Erro interno do servidor' });
@@ -2411,14 +1385,6 @@ app.put('/api/produtos/:id', async (req, res) => {
       fields.push('lancamento = ?');
       values.push(produtoData.lancamento);
     }
-    if (produtoData.novo !== undefined) {
-      fields.push('novo = ?');
-      values.push(produtoData.novo);
-    }
-    if (produtoData.seminovo !== undefined) {
-      fields.push('seminovo = ?');
-      values.push(produtoData.seminovo);
-    }
     if (produtoData.avaliacao !== undefined) {
       fields.push('avaliacao = ?');
       values.push(produtoData.avaliacao);
@@ -2514,11 +1480,6 @@ app.put('/api/produtos/:id', async (req, res) => {
       updatedAt: produto.updated_at
     };
 
-    // Invalidar cache de produtos
-    const cacheHelpers = require('./utils/cacheHelpers.cjs');
-    await cacheHelpers.invalidateProductCache(id);
-    await cacheHelpers.invalidateProductsCache();
-
     console.log('‚úÖ Produto atualizado com sucesso');
     res.json(produtoFormatado);
   } catch (error) {
@@ -2542,11 +1503,6 @@ app.delete('/api/produtos/:id', async (req, res) => {
       return res.status(404).json({ error: 'Produto n√£o encontrado' });
     }
 
-    // Invalidar cache de produtos
-    const cacheHelpers = require('./utils/cacheHelpers.cjs');
-    await cacheHelpers.invalidateProductCache(id);
-    await cacheHelpers.invalidateProductsCache();
-
     console.log('‚úÖ Produto deletado');
     res.json({ message: 'Produto deletado com sucesso' });
   } catch (error) {
@@ -2561,55 +1517,21 @@ app.delete('/api/produtos/:id', async (req, res) => {
 app.get('/api/events', async (req, res) => {
   try {
     console.log('üîÑ Buscando eventos...');
-
-    // Buscar apenas colunas essenciais que sempre existem
-    let rows;
-    try {
-      // Tentativa 1: Buscar com todas as colunas poss√≠veis
-      const [result] = await pool.execute(`
+    const [rows] = await pool.execute(`
       SELECT 
-          id, titulo, descricao, data_evento, local, imagem_url,
-          status, ativo,
-        created_at, updated_at
-        FROM \`rare_toy_companion\`.\`events\`
+        id, titulo, descricao, data_evento, local, numero_vagas,
+        vagas_limitadas, imagem_url, ativo, feira_fechada, renda_total,
+        participantes_confirmados, created_at, updated_at
+      FROM events 
       ORDER BY data_evento ASC
     `);
-      rows = result;
-    } catch (error) {
-      console.error('‚ùå Erro na primeira tentativa:', error.message);
-      // Tentativa 2: Apenas colunas b√°sicas
-      try {
-        const [result] = await pool.execute(`
-          SELECT 
-            id, titulo, descricao, data_evento, local, imagem_url,
-            created_at, updated_at
-          FROM \`rare_toy_companion\`.\`events\`
-          ORDER BY data_evento ASC
-        `);
-        rows = result.map(e => ({ ...e, status: 'ativo', ativo: 1 }));
-      } catch (error2) {
-        console.error('‚ùå Erro na segunda tentativa:', error2.message);
-        throw error2;
-      }
-    }
 
     console.log(`‚úÖ ${rows.length} eventos encontrados`);
 
-    // Converter e adicionar campos adicionais com valores padr√£o
+    // Converter renda_total de string para number e corrigir URLs de imagem
     const eventos = rows.map(evento => ({
       ...evento,
-      ativo: evento.ativo === 1 || evento.ativo === true || evento.status === 'ativo',
-      status: evento.status || (evento.ativo ? 'ativo' : 'inativo'),
-      destaque: evento.destaque !== undefined ? evento.destaque : false,
-      ordem: evento.ordem !== undefined ? evento.ordem : 0,
-      data_inicio: evento.data_inicio || evento.data_evento,
-      data_fim: evento.data_fim || null,
-      numero_vagas: evento.numero_vagas || null,
-      vagas_limitadas: evento.vagas_limitadas || false,
-      feira_fechada: evento.feira_fechada || false,
-      link_inscricao: evento.link_inscricao || null,
       renda_total: evento.renda_total ? parseFloat(evento.renda_total) : null,
-      participantes_confirmados: evento.participantes_confirmados || 0,
       imagem_url: evento.imagem_url ? getPublicUrl(req, evento.imagem_url) : null
     }));
 
@@ -2663,144 +1585,33 @@ app.post('/api/events', async (req, res) => {
   try {
     const eventoData = req.body;
     console.log('üîÑ Criando evento:', eventoData.titulo);
-    console.log('üì¶ Dados recebidos:', JSON.stringify(eventoData, null, 2));
-
-    // Validar campos obrigat√≥rios
-    if (!eventoData.titulo) {
-      return res.status(400).json({ error: 'T√≠tulo √© obrigat√≥rio' });
-    }
-
-    // Usar data_inicio se dispon√≠vel, sen√£o data_evento (compatibilidade)
-    const dataEvento = eventoData.data_inicio || eventoData.data_evento;
-
-    if (!dataEvento) {
-      return res.status(400).json({ error: 'Data do evento √© obrigat√≥ria' });
-    }
 
-    const formattedDate = formatDateForMySQL(dataEvento);
-    console.log('üìÖ Data original:', dataEvento);
-    console.log('üìÖ Data formatada:', formattedDate);
-
-    const newId = require('crypto').randomUUID();
-
-    const insertValues = [
-      newId,
+    const [result] = await pool.execute(`
+      INSERT INTO events (
+        id, titulo, descricao, data_evento, local, numero_vagas,
+        vagas_limitadas, imagem_url, ativo, feira_fechada, renda_total,
+        participantes_confirmados
+      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
+    `, [
+      require('crypto').randomUUID(),
       eventoData.titulo,
       eventoData.descricao || null,
-      formattedDate,
+      formatDateForMySQL(eventoData.data_evento),
       eventoData.local || null,
+      eventoData.numero_vagas || null,
+      eventoData.vagas_limitadas || false,
       eventoData.imagem_url || null,
-      eventoData.ativo !== false
-    ];
-
-    console.log('üìã Valores do INSERT:', insertValues);
-
-    // A tabela events usa 'status' em vez de 'ativo'
-    const status = eventoData.ativo !== false ? 'ativo' : 'inativo';
-
-    // Usar nome completo do banco e tentar inserir com status primeiro
-    let result;
-    try {
-      result = await pool.execute(`
-        INSERT INTO \`rare_toy_companion\`.\`events\` (
-        id, titulo, descricao, data_evento, local, imagem_url, status
-      ) VALUES (?, ?, ?, ?, ?, ?, ?)
-    `, [
-        newId,
-        eventoData.titulo,
-        eventoData.descricao || null,
-        formattedDate,
-        eventoData.local || null,
-        eventoData.imagem_url || null,
-        status
-      ]);
-    } catch (statusError) {
-      // Se falhar com status, tentar com ativo
-      if (statusError.message.includes('status')) {
-        console.log('‚ö†Ô∏è Tentando inserir com campo ativo ao inv√©s de status...');
-        result = await pool.execute(`
-          INSERT INTO \`rare_toy_companion\`.\`events\` (
-            id, titulo, descricao, data_evento, local, imagem_url, ativo
-          ) VALUES (?, ?, ?, ?, ?, ?, ?)
-        `, [
-          newId,
-          eventoData.titulo,
-          eventoData.descricao || null,
-          formattedDate,
-          eventoData.local || null,
-          eventoData.imagem_url || null,
-          eventoData.ativo !== false ? 1 : 0
-        ]);
-      } else {
-        throw statusError;
-      }
-    }
-
-    // Inserir campos adicionais se fornecidos (data_fim, numero_vagas, etc.)
-    if (eventoData.data_fim || eventoData.numero_vagas !== undefined || eventoData.vagas_limitadas !== undefined) {
-      try {
-        const updateFields = [];
-        const updateValues = [];
-
-        if (eventoData.data_fim) {
-          updateFields.push('data_fim = ?');
-          updateValues.push(formatDateForMySQL(eventoData.data_fim));
-        }
-        if (eventoData.numero_vagas !== undefined) {
-          updateFields.push('numero_vagas = ?');
-          updateValues.push(eventoData.numero_vagas);
-        }
-        if (eventoData.vagas_limitadas !== undefined) {
-          updateFields.push('vagas_limitadas = ?');
-          updateValues.push(eventoData.vagas_limitadas ? 1 : 0);
-        }
-
-        if (updateFields.length > 0) {
-          updateValues.push(newId);
-          await pool.execute(`
-            UPDATE \`rare_toy_companion\`.\`events\`
-            SET ${updateFields.join(', ')}
-            WHERE id = ?
-          `, updateValues);
-          console.log('‚úÖ Campos adicionais atualizados');
-        }
-      } catch (updateError) {
-        console.warn('‚ö†Ô∏è Erro ao atualizar campos adicionais (n√£o cr√≠tico):', updateError.message);
-      }
-    }
+      eventoData.ativo !== false,
+      eventoData.feira_fechada || false,
+      eventoData.renda_total || null,
+      eventoData.participantes_confirmados || null
+    ]);
 
-    console.log('‚úÖ Evento criado com sucesso! ID:', newId);
-    res.status(201).json({
-      id: newId,
-      titulo: eventoData.titulo,
-      message: 'Evento criado com sucesso'
-    });
+    console.log('‚úÖ Evento criado com sucesso!');
+    res.status(201).json({ id: result.insertId, ...eventoData });
   } catch (error) {
     console.error('‚ùå Erro ao criar evento:', error);
-    console.error('üìã Stack:', error.stack);
-    console.error('üìã SQL Error Code:', error.code);
-    console.error('üìã SQL Message:', error.sqlMessage);
-
-    // Tratamento espec√≠fico para erros SQL
-    if (error.code === 'ER_BAD_FIELD_ERROR') {
-      return res.status(500).json({
-        error: 'Erro na estrutura da tabela',
-        details: `Coluna n√£o encontrada: ${error.sqlMessage}`
-      });
-    }
-
-    if (error.code === 'ER_NO_SUCH_TABLE') {
-      return res.status(500).json({
-        error: 'Tabela n√£o encontrada',
-        details: 'A tabela events n√£o existe no banco de dados'
-      });
-    }
-
-    res.status(500).json({
-      error: 'Erro interno do servidor',
-      details: error.message,
-      code: error.code
-    });
+    res.status(500).json({ error: 'Erro interno do servidor', details: error.message });
   }
 });
 
@@ -2811,34 +1622,26 @@ app.put('/api/events/:id', async (req, res) => {
     const eventoData = req.body;
     console.log(`üîÑ Atualizando evento ID: ${id}`);
 
-    // Usar data_inicio se dispon√≠vel, sen√£o data_evento (compatibilidade)
-    const dataEvento = eventoData.data_inicio || eventoData.data_evento;
-
-    // Construir query UPDATE dinamicamente apenas com campos que existem
-    const updateFields = [];
-    const updateValues = [];
-
-    if (eventoData.titulo !== undefined) { updateFields.push('titulo = ?'); updateValues.push(eventoData.titulo); }
-    if (eventoData.descricao !== undefined) { updateFields.push('descricao = ?'); updateValues.push(eventoData.descricao || null); }
-    if (dataEvento !== undefined) { updateFields.push('data_evento = ?'); updateValues.push(formatDateForMySQL(dataEvento)); }
-    if (eventoData.local !== undefined) { updateFields.push('local = ?'); updateValues.push(eventoData.local || null); }
-    if (eventoData.imagem_url !== undefined) { updateFields.push('imagem_url = ?'); updateValues.push(eventoData.imagem_url || null); }
-    if (eventoData.ativo !== undefined) {
-      const status = eventoData.ativo !== false ? 'ativo' : 'inativo';
-      updateFields.push('status = ?');
-      updateValues.push(status);
-    }
-
-    updateFields.push('updated_at = NOW()');
-    updateValues.push(id);
-
-    if (updateFields.length === 1) {
-      return res.status(400).json({ error: 'Nenhum campo para atualizar' });
-    }
-
     const [result] = await pool.execute(`
-      UPDATE events SET ${updateFields.join(', ')} WHERE id = ?
-    `, updateValues);
+      UPDATE events SET 
+        titulo = ?, descricao = ?, data_evento = ?, local = ?,
+        numero_vagas = ?, vagas_limitadas = ?, imagem_url = ?, ativo = ?,
+        feira_fechada = ?, renda_total = ?, participantes_confirmados = ?, updated_at = NOW()
+      WHERE id = ?
+    `, [
+      eventoData.titulo,
+      eventoData.descricao || null,
+      formatDateForMySQL(eventoData.data_evento),
+      eventoData.local || null,
+      eventoData.numero_vagas || null,
+      eventoData.vagas_limitadas || false,
+      eventoData.imagem_url || null,
+      eventoData.ativo !== false,
+      eventoData.feira_fechada || false,
+      eventoData.renda_total || null,
+      eventoData.participantes_confirmados || null,
+      id
+    ]);
 
     if (result.affectedRows === 0) {
       return res.status(404).json({ error: 'Evento n√£o encontrado' });
@@ -2859,30 +1662,32 @@ app.post('/api/events/:id/fechar-feira', async (req, res) => {
     const { renda_total, participantes_confirmados } = req.body;
     console.log(`üîÑ Fechando feira do evento ID: ${id}`);
 
-    // Nota: As colunas feira_fechada, renda_total e participantes_confirmados n√£o existem na tabela events
-    // Este endpoint est√° desabilitado at√© que essas colunas sejam adicionadas ao banco de dados
-
-    // Apenas atualizar o timestamp para indicar que a a√ß√£o foi executada
     const [result] = await pool.execute(`
       UPDATE events SET 
+        feira_fechada = true, 
+        renda_total = ?, 
+        participantes_confirmados = ?,
         updated_at = NOW()
       WHERE id = ?
-    `, [id]);
+    `, [
+      renda_total || 0,
+      participantes_confirmados || 0,
+      id
+    ]);
 
     if (result.affectedRows === 0) {
       return res.status(404).json({ error: 'Evento n√£o encontrado' });
     }
 
-    console.log('‚úÖ Feira fechada com sucesso (funcionalidade limitada)');
+    console.log('‚úÖ Feira fechada com sucesso');
     res.json({
       message: 'Feira fechada com sucesso',
       renda_total: renda_total || 0,
-      participantes_confirmados: participantes_confirmados || 0,
-      note: 'As colunas feira_fechada, renda_total e participantes_confirmados n√£o est√£o dispon√≠veis na tabela events'
+      participantes_confirmados: participantes_confirmados || 0
     });
   } catch (error) {
     console.error('‚ùå Erro ao fechar feira:', error);
-    res.status(500).json({ error: 'Erro interno do servidor', details: error.message });
+    res.status(500).json({ error: 'Erro interno do servidor' });
   }
 });
 
@@ -2920,7 +1725,8 @@ app.get('/api/users', async (req, res) => {
     console.log('üîÑ Buscando usu√°rios...');
     const [rows] = await pool.execute(`
       SELECT 
-        id, email, avatar_url, nome, created_at
+        id, email, avatar_url, nome, telefone, endereco, cidade, estado, cep,
+        created_at, updated_at
       FROM users 
       ORDER BY created_at DESC
     `);
@@ -2964,13 +1770,18 @@ app.post('/api/users', async (req, res) => {
 
     const [result] = await pool.execute(`
       INSERT INTO users (
-        id, email, avatar_url, nome
-      ) VALUES (?, ?, ?, ?)
+        id, email, avatar_url, nome, telefone, endereco, cidade, estado, cep
+      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
     `, [
       require('crypto').randomUUID(),
       userData.email,
       userData.avatar_url || null,
-      userData.nome
+      userData.nome,
+      userData.telefone || null,
+      userData.endereco || null,
+      userData.cidade || null,
+      userData.estado || null,
+      userData.cep || null
     ]);
 
     console.log('‚úÖ Usu√°rio criado com ID:', result.insertId);
@@ -2985,8 +1796,84 @@ app.post('/api/users', async (req, res) => {
   }
 });
 
-// Endpoint de registro p√∫blico - REMOVIDO (duplicado)
-// Usando apenas a rota com rate limiting e hash de senha (linha 3263)
+// Endpoint de registro p√∫blico
+app.post('/api/auth/register', async (req, res) => {
+  try {
+    const { email, senha, nome, telefone } = req.body || {};
+
+    // Validar dados obrigat√≥rios
+    if (!email || !senha || !nome) {
+      return res.status(400).json({
+        ok: false,
+        error: 'missing_data',
+        message: 'Email, senha e nome s√£o obrigat√≥rios'
+      });
+    }
+
+    // Validar formato do email
+    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
+    if (!emailRegex.test(email)) {
+      return res.status(400).json({
+        ok: false,
+        error: 'invalid_email',
+        message: 'Formato de email inv√°lido'
+      });
+    }
+
+    console.log('üìù Tentativa de registro:', email);
+
+    // Verificar se usu√°rio j√° existe
+    const [existing] = await pool.execute('SELECT id FROM users WHERE email = ?', [email]);
+    if (existing && existing.length > 0) {
+      console.log('‚ùå Usu√°rio j√° existe:', email);
+      return res.status(400).json({
+        ok: false,
+        error: 'user_exists',
+        message: 'Este email j√° est√° cadastrado'
+      });
+    }
+
+    // Criar usu√°rio
+    const [result] = await pool.execute(
+      'INSERT INTO users (email, nome, telefone, created_at) VALUES (?, ?, ?, NOW())',
+      [email.toLowerCase(), nome, telefone || null]
+    );
+
+    const userId = result.insertId;
+    console.log('‚úÖ Usu√°rio criado com sucesso:', email, 'ID:', userId);
+
+    // Fazer login autom√°tico ap√≥s registro
+    const sid = require('crypto').randomUUID();
+    await pool.execute('INSERT INTO sessions (id, user_email, user_id, created_at, last_seen) VALUES (?, ?, ?, NOW(), NOW())', [sid, email, userId]);
+
+    // Configurar cookie de sess√£o
+    res.cookie('session_id', sid, {
+      httpOnly: false,
+      sameSite: 'lax',
+      secure: (req.headers['x-forwarded-proto'] || req.protocol) === 'https',
+      maxAge: 1000 * 60 * 60 * 24 * 30 // 30 dias
+    });
+
+    res.json({
+      ok: true,
+      user_id: userId,
+      user: {
+        id: userId,
+        email: email,
+        nome: nome,
+        telefone: telefone
+      },
+      message: 'Usu√°rio criado com sucesso'
+    });
+  } catch (e) {
+    console.error('‚ùå Erro no registro:', e);
+    res.status(500).json({
+      ok: false,
+      error: 'register_failed',
+      message: 'Erro interno do servidor'
+    });
+  }
+});
 
 // Atualizar usu√°rio
 app.put('/api/users/:id', async (req, res) => {
@@ -2997,12 +1884,18 @@ app.put('/api/users/:id', async (req, res) => {
 
     const [result] = await pool.execute(`
       UPDATE users SET 
-        email = ?, avatar_url = ?, nome = ?
+        email = ?, avatar_url = ?, nome = ?, telefone = ?, endereco = ?, cidade = ?, 
+        estado = ?, cep = ?, updated_at = NOW()
       WHERE id = ?
     `, [
       userData.email,
       userData.avatar_url || null,
       userData.nome,
+      userData.telefone || null,
+      userData.endereco || null,
+      userData.cidade || null,
+      userData.estado || null,
+      userData.cep || null,
       id
     ]);
 
@@ -3093,9 +1986,8 @@ app.get('/api/collections', async (req, res) => {
       hasOrdem ? 'ordem' : null,
     ].filter(Boolean).join(', ');
 
-    const selectCols = `c.id, c.nome, c.descricao, c.imagem_url${optionalCols ? ', c.' + optionalCols.split(', ').join(', c.') : ''}, NOW() as created_at, NOW() as updated_at, 
-      (SELECT COUNT(*) FROM collection_products cp WHERE cp.collection_id = c.id) as total_produtos`;
-    const sql = `SELECT ${selectCols} FROM collections c ${whereSql.replaceAll('nome', 'c.nome').replaceAll('descricao', 'c.descricao')} ORDER BY ${sortCol.startsWith('c.') ? sortCol : `c.${sortCol}`} ${order} LIMIT ${limitNum} OFFSET ${offsetNum}`;
+    const selectCols = `id, nome, descricao, imagem_url${optionalCols ? ', ' + optionalCols : ''}, NOW() as created_at, NOW() as updated_at`;
+    const sql = `SELECT ${selectCols} FROM collections ${whereSql} ORDER BY ${sortCol} ${order} LIMIT ${limitNum} OFFSET ${offsetNum}`;
     const [rows] = await pool.execute(sql, vals);
 
     console.log(`‚úÖ ${rows.length} cole√ß√µes encontradas`);
@@ -3505,22 +2397,6 @@ app.delete('/api/collections/:id', async (req, res) => {
   }
 });
 
-// GET /api/debug/collections-schema - Inspeciona colunas da tabela collections
-app.get('/api/debug/collections-schema', async (req, res) => {
-  try {
-    const [cols] = await pool.execute("SELECT COLUMN_NAME, DATA_TYPE FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_SCHEMA = DATABASE() AND TABLE_NAME = 'collections' ORDER BY ORDINAL_POSITION");
-    res.json({
-      database: process.env.MYSQL_DATABASE,
-      table: 'collections',
-      columns: cols
-    });
-  } catch (error) {
-    console.error('‚ùå Erro ao ler schema de collections:', { message: error?.message, code: error?.code });
-    res.status(500).json({ error: 'Erro interno do servidor', message: error?.message, code: error?.code });
-  }
-});
-
-// Ensure link table collection_products exists
 (async () => {
   try {
     await pool.execute(`
@@ -3656,7 +2532,7 @@ app.get('/api/debug/collections-schema', async (req, res) => {
 })();
 
 // Endpoints de Settings
-app.get('/api/settings', authRoutesLimiter, async (req, res) => {
+app.get('/api/settings', async (req, res) => {
   try {
     const [rows] = await pool.execute('SELECT key_name, value_text FROM settings');
     const settings = {};
@@ -4022,22 +2898,11 @@ app.get('/api/settings/audit', async (req, res) => {
     await pool.execute(`
       CREATE TABLE IF NOT EXISTS sessions (
         id VARCHAR(191) PRIMARY KEY,
-        user_id VARCHAR(191) NULL,
         user_email VARCHAR(255) NOT NULL,
         created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
-        last_seen DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
-        INDEX idx_user_email (user_email),
-        INDEX idx_user_id (user_id)
+        last_seen DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP
       ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
     `);
-
-    // Adicionar coluna user_id se n√£o existir
-    try {
-      await pool.execute('ALTER TABLE sessions ADD COLUMN user_id VARCHAR(191) NULL AFTER id');
-      console.log('‚úÖ Coluna user_id adicionada √† tabela sessions');
-    } catch (e) {
-      // Coluna j√° existe, ignorar erro
-    }
   } catch (e) {
     console.error('‚ùå Erro criando tabela de sess√µes:', e?.message || e);
   }
@@ -4055,162 +2920,39 @@ async function attachUserFromSession(req) {
   } catch { return null; }
 }
 
-app.post('/api/auth/login', authLimiter, async (req, res) => {
+app.post('/api/auth/login', async (req, res) => {
   try {
-    const { email, senha, password } = req.body || {};
-    const mail = String(email || '').trim().toLowerCase();
-    const pass = String(password || senha || '');
+    const { email, senha } = req.body || {};
+    if (!email || !senha) return res.status(400).json({ error: 'credenciais_invalidas' });
 
-    if (!mail || !pass) {
-      return res.status(400).json({ error: 'credenciais_invalidas', message: 'Email e senha s√£o obrigat√≥rios' });
+    console.log('üîê Tentativa de login:', email);
+
+    // Buscar usu√°rio no banco
+    const [userRows] = await pool.execute('SELECT id, email, nome FROM users WHERE email = ?', [email]);
+    if (!userRows || userRows.length === 0) {
+      console.log('‚ùå Usu√°rio n√£o encontrado:', email);
+      return res.status(401).json({ error: 'usuario_nao_encontrado' });
     }
 
-    console.log('üîê Tentativa de login cliente:', mail);
-    console.log('üîç Verificando banco de dados atual...');
+    const user = userRows[0];
+    const userId = user.id;
 
-    // Verificar banco atual
-    try {
-      const [dbCheck] = await pool.execute('SELECT DATABASE() as current_db');
-      console.log('üìç Banco atual:', dbCheck[0]?.current_db || 'n√£o definido');
-    } catch (e) {
-      console.log('‚ö†Ô∏è Erro ao verificar banco:', e.message);
-    }
+    // Gerar ID de sess√£o √∫nico
+    const sid = require('crypto').randomUUID();
 
-    // Buscar usu√°rio no banco (tentar primeiro em users, depois em customers)
-    let userRows = [];
-    let user = null;
-    let userId = null;
+    // Remover sess√µes antigas do usu√°rio para garantir sess√£o √∫nica
+    await pool.execute('DELETE FROM sessions WHERE user_id = ? OR user_email = ?', [userId, email]);
 
-    // Tentar em users primeiro
-    // CORRIGIDO: usar apenas password_hash (n√£o existe senha_hash na tabela users)
-    try {
-      console.log('üîç Buscando em users...');
-      [userRows] = await pool.execute(`
-        SELECT 
-          id, email, nome, password_hash as senha_hash
-        FROM users 
-        WHERE email = ? 
-        LIMIT 1
-      `, [mail]);
-      console.log('üìä Resultado da busca em users:', userRows.length, 'registro(s)');
-      if (userRows && userRows.length > 0) {
-        user = userRows[0];
-        userId = user.id;
-        console.log('‚úÖ Usu√°rio encontrado na tabela users:', mail, 'ID:', userId, 'Tem senha:', !!user.senha_hash);
-      } else {
-        console.log('‚ö†Ô∏è Usu√°rio n√£o encontrado em users para:', mail);
-      }
-    } catch (e) {
-      console.error('‚ùå Erro ao buscar em users:', e.message);
-      console.error('‚ùå Stack:', e.stack);
-    }
+    // Criar nova sess√£o
+    await pool.execute('INSERT INTO sessions (id, user_email, user_id, created_at, last_seen) VALUES (?, ?, ?, NOW(), NOW())', [sid, email, userId]);
 
-    // Se n√£o encontrou em users, tentar em customers
-    // CORRIGIDO: customers n√£o tem password_hash, apenas users tem
-    if (!user) {
-      try {
-        console.log('üîç Buscando em customers...');
-        const [customerRows] = await pool.execute(`
-          SELECT 
-            id, email, nome
-          FROM customers 
-          WHERE email = ? 
-          LIMIT 1
-        `, [mail]);
-        console.log('üìä Resultado da busca em customers:', customerRows.length, 'registro(s)');
-        if (customerRows && customerRows.length > 0) {
-          // Se encontrou em customers, tentar buscar senha em users pelo mesmo ID
-          const customer = customerRows[0];
-          const [userWithPassword] = await pool.execute(
-            'SELECT password_hash FROM users WHERE id = ? LIMIT 1',
-            [customer.id]
-          );
-          user = {
-            ...customer,
-            senha_hash: userWithPassword[0]?.password_hash || null
-          };
-          userId = user.id;
-          console.log('‚úÖ Usu√°rio encontrado na tabela customers:', mail, 'ID:', userId, 'Tem senha:', !!user.senha_hash);
-        } else {
-          console.log('‚ö†Ô∏è Usu√°rio n√£o encontrado em customers para:', mail);
-        }
-      } catch (e) {
-        console.error('‚ùå Erro ao buscar em customers:', e.message);
-        console.error('‚ùå Stack:', e.stack);
-      }
-    }
-
-    if (!user || !userId) {
-      console.log('‚ùå Usu√°rio n√£o encontrado em users nem customers:', mail);
-      // Listar alguns emails dispon√≠veis para debug
-      try {
-        const [allUsers] = await pool.execute('SELECT email FROM users LIMIT 5');
-        const [allCustomers] = await pool.execute('SELECT email FROM customers LIMIT 5');
-        console.log('üìã Emails dispon√≠veis em users:', allUsers.map(u => u.email).join(', '));
-        console.log('üìã Emails dispon√≠veis em customers:', allCustomers.map(c => c.email).join(', '));
-      } catch (e) {
-        console.log('‚ö†Ô∏è N√£o foi poss√≠vel listar emails:', e.message);
-      }
-      return res.status(401).json({
-        error: 'usuario_nao_encontrado',
-        message: 'Email ou senha incorretos. Verifique suas credenciais ou crie uma conta.'
-      });
-    }
-
-    // Verificar senha se houver hash
-    if (user.senha_hash) {
-      try {
-        console.log('üîê Verificando senha para:', mail);
-        const { verifyPassword } = require('./utils/security.cjs');
-        const senhaCorreta = await verifyPassword(pass, user.senha_hash);
-        console.log('üîê Resultado da verifica√ß√£o de senha:', senhaCorreta ? '‚úÖ Correta' : '‚ùå Incorreta');
-        if (!senhaCorreta) {
-          console.log('‚ùå Senha incorreta para:', mail);
-          return res.status(401).json({
-            error: 'credenciais_invalidas',
-            message: 'Email ou senha incorretos'
-          });
-        }
-        console.log('‚úÖ Senha verificada com sucesso para:', mail);
-      } catch (verifyError) {
-        console.error('‚ùå Erro ao verificar senha:', verifyError);
-        console.error('‚ùå Stack:', verifyError.stack);
-        // Se houver erro na verifica√ß√£o, n√£o permitir login por seguran√ßa
-        return res.status(401).json({
-          error: 'credenciais_invalidas',
-          message: 'Erro ao verificar credenciais. Tente novamente.'
-        });
-      }
-    } else {
-      // Se n√£o tem senha_hash, verificar se senha foi fornecida
-      console.log('‚ö†Ô∏è Usu√°rio sem senha_hash encontrado:', mail);
-      if (pass && pass.length > 0) {
-        console.log('‚ö†Ô∏è Senha fornecida mas usu√°rio n√£o tem hash - negando login por seguran√ßa');
-        console.log('üí° Solu√ß√£o: O usu√°rio precisa redefinir a senha ou criar uma nova conta');
-        return res.status(401).json({
-          error: 'credenciais_invalidas',
-          message: 'Este email n√£o possui senha cadastrada. Por favor, use a op√ß√£o "Esqueci minha senha" ou crie uma nova conta.'
-        });
-      } else {
-        // Se n√£o tem senha_hash e nenhuma senha foi fornecida, permitir login (usu√°rio antigo)
-        console.log('‚ö†Ô∏è Login sem senha permitido para usu√°rio antigo:', mail);
-      }
-    }
-
-    // Gerar ID de sess√£o √∫nico
-    const sid = require('crypto').randomUUID();
-
-    // Remover sess√µes antigas do usu√°rio para garantir sess√£o √∫nica
-    await pool.execute('DELETE FROM sessions WHERE user_id = ? OR user_email = ?', [userId, mail]);
-
-    // Criar nova sess√£o
-    await pool.execute('INSERT INTO sessions (id, user_email, user_id, created_at, last_seen) VALUES (?, ?, ?, NOW(), NOW())', [sid, mail, userId]);
-
-    // Configurar cookie de sess√£o (seguro)
-    const { getSecureCookieOptions } = require('./utils/security.cjs');
-    res.cookie('session_id', sid, getSecureCookieOptions({
+    // Configurar cookie de sess√£o
+    res.cookie('session_id', sid, {
+      httpOnly: false,
+      sameSite: 'lax',
+      secure: (req.headers['x-forwarded-proto'] || req.protocol) === 'https',
       maxAge: 1000 * 60 * 60 * 24 * 30 // 30 dias
-    }));
+    });
 
     // Vincular carrinho atual ao usu√°rio
     const cartId = req.cookies?.cart_id;
@@ -4218,7 +2960,7 @@ app.post('/api/auth/login', authLimiter, async (req, res) => {
       await pool.execute('UPDATE carts SET user_id = ? WHERE id = ?', [userId, cartId]);
     }
 
-    console.log('‚úÖ Login realizado com sucesso:', mail, 'Sess√£o:', sid);
+    console.log('‚úÖ Login realizado com sucesso:', email, 'Sess√£o:', sid);
     res.json({
       success: true,
       user: {
@@ -4283,304 +3025,6 @@ app.post('/api/auth/logout', async (req, res) => {
   }
 });
 
-// ==================== ESQUECI MINHA SENHA (CLIENTES) ====================
-
-// Esqueci minha senha - Gerar token de reset
-app.post('/api/auth/forgot-password', authLimiter, async (req, res) => {
-  try {
-    const { email } = req.body || {};
-    const mail = String(email || '').trim().toLowerCase();
-
-    if (!mail || !/^[^@\s]+@[^@\s]+\.[^@\s]+$/.test(mail)) {
-      return res.status(400).json({
-        ok: false,
-        error: 'invalid_email',
-        message: 'Email inv√°lido'
-      });
-    }
-
-    console.log('üîê Solicita√ß√£o de reset de senha para:', mail);
-
-    // Buscar usu√°rio em users ou customers
-    let userId = null;
-    let userEmail = null;
-
-    try {
-      const [users] = await pool.execute('SELECT id, email FROM `rare_toy_companion`.`users` WHERE email = ? LIMIT 1', [mail]);
-      if (users && users.length > 0) {
-        userId = users[0].id;
-        userEmail = users[0].email;
-        console.log('‚úÖ Usu√°rio encontrado em users:', userId);
-      } else {
-        const [customers] = await pool.execute('SELECT id, email FROM `rare_toy_companion`.`customers` WHERE email = ? LIMIT 1', [mail]);
-        if (customers && customers.length > 0) {
-          userId = customers[0].id;
-          userEmail = customers[0].email;
-          console.log('‚úÖ Usu√°rio encontrado em customers:', userId);
-        }
-      }
-    } catch (e) {
-      console.error('‚ùå Erro ao buscar usu√°rio:', e);
-    }
-
-    // Sempre retornar sucesso (n√£o revelar se email existe)
-    if (!userId) {
-      console.log('‚ö†Ô∏è Email n√£o encontrado (n√£o revelando para seguran√ßa):', mail);
-      return res.json({
-        ok: true,
-        message: 'Se o email existir, voc√™ receber√° um link para redefinir sua senha.'
-      });
-    }
-
-    // Gerar token de reset
-    const token = require('crypto').randomUUID();
-    const expires = new Date(Date.now() + 1000 * 60 * 60); // 1 hora
-
-    // Salvar token no banco (usar tabela users ou customers conforme encontrado)
-    try {
-      // Verificar em qual tabela o usu√°rio foi encontrado e atualizar
-      const [checkUsers] = await pool.execute('SELECT id FROM `rare_toy_companion`.`users` WHERE id = ? LIMIT 1', [userId]);
-      if (checkUsers && checkUsers.length > 0) {
-        try {
-          await pool.execute(
-            'UPDATE `rare_toy_companion`.`users` SET reset_token = ?, reset_expires = ? WHERE id = ?',
-            [token, expires, userId]
-          );
-          console.log('‚úÖ Token salvo em users');
-        } catch (updateError) {
-          // Se colunas n√£o existem, criar dinamicamente
-          if (updateError.message && updateError.message.includes('Unknown column')) {
-            console.warn('‚ö†Ô∏è Colunas reset_token/reset_expires n√£o existem em users. Execute: node scripts/check-reset-password-tables.cjs');
-            // Tentar adicionar colunas dinamicamente
-            try {
-              await pool.execute('ALTER TABLE `rare_toy_companion`.`users` ADD COLUMN IF NOT EXISTS `reset_token` VARCHAR(255) NULL DEFAULT NULL');
-              await pool.execute('ALTER TABLE `rare_toy_companion`.`users` ADD COLUMN IF NOT EXISTS `reset_expires` DATETIME NULL DEFAULT NULL');
-              // Tentar novamente
-              await pool.execute(
-                'UPDATE `rare_toy_companion`.`users` SET reset_token = ?, reset_expires = ? WHERE id = ?',
-                [token, expires, userId]
-              );
-              console.log('‚úÖ Colunas criadas e token salvo em users');
-            } catch (alterError) {
-              console.error('‚ùå Erro ao criar colunas:', alterError.message);
-              throw alterError;
-            }
-          } else {
-            throw updateError;
-          }
-        }
-      } else {
-        try {
-          await pool.execute(
-            'UPDATE `rare_toy_companion`.`customers` SET reset_token = ?, reset_expires = ? WHERE id = ?',
-            [token, expires, userId]
-          );
-          console.log('‚úÖ Token salvo em customers');
-        } catch (updateError) {
-          // Se colunas n√£o existem, criar dinamicamente
-          if (updateError.message && updateError.message.includes('Unknown column')) {
-            console.warn('‚ö†Ô∏è Colunas reset_token/reset_expires n√£o existem em customers. Execute: node scripts/check-reset-password-tables.cjs');
-            // Tentar adicionar colunas dinamicamente
-            try {
-              await pool.execute('ALTER TABLE `rare_toy_companion`.`customers` ADD COLUMN IF NOT EXISTS `reset_token` VARCHAR(255) NULL DEFAULT NULL');
-              await pool.execute('ALTER TABLE `rare_toy_companion`.`customers` ADD COLUMN IF NOT EXISTS `reset_expires` DATETIME NULL DEFAULT NULL');
-              // Tentar novamente
-              await pool.execute(
-                'UPDATE `rare_toy_companion`.`customers` SET reset_token = ?, reset_expires = ? WHERE id = ?',
-                [token, expires, userId]
-              );
-              console.log('‚úÖ Colunas criadas e token salvo em customers');
-            } catch (alterError) {
-              console.error('‚ùå Erro ao criar colunas:', alterError.message);
-              throw alterError;
-            }
-          } else {
-            throw updateError;
-          }
-        }
-      }
-
-      console.log('‚úÖ Token de reset gerado para:', mail);
-
-      // Construir URL de reset
-      const baseUrl = process.env.APP_BASE_URL || `${req.protocol}://${req.get('host')}`;
-      const resetUrl = `${baseUrl}/auth/reset-password?token=${token}`;
-
-      // Enviar email com link de reset
-      try {
-        const { sendPasswordResetEmail } = require('../config/emailService.cjs');
-        const emailResult = await sendPasswordResetEmail({
-          email: userEmail,
-          customerName: null, // Pode buscar o nome do usu√°rio se necess√°rio
-          resetUrl: resetUrl,
-        });
-
-        if (emailResult.success) {
-          console.log('‚úÖ Email de recupera√ß√£o de senha enviado para:', mail);
-        } else {
-          console.warn('‚ö†Ô∏è Falha ao enviar email de recupera√ß√£o:', emailResult.error);
-          // Em desenvolvimento, ainda retornar URL no log
-          if (process.env.NODE_ENV === 'development') {
-            console.log('üîê Link de reset (DESENVOLVIMENTO):', resetUrl);
-          }
-        }
-      } catch (emailError) {
-        console.error('‚ùå Erro ao enviar email de recupera√ß√£o:', emailError);
-        // Em desenvolvimento, ainda logar o link
-        if (process.env.NODE_ENV === 'development') {
-          console.log('üîê Link de reset (DESENVOLVIMENTO):', resetUrl);
-        }
-      }
-
-      return res.json({
-        ok: true,
-        message: 'Se o email existir, voc√™ receber√° um link para redefinir sua senha.',
-        // Apenas em desenvolvimento retornar URL e token
-        ...(process.env.NODE_ENV === 'development' && { resetUrl, token })
-      });
-    } catch (e) {
-      console.error('‚ùå Erro ao salvar token:', e);
-      return res.json({
-        ok: true,
-        message: 'Se o email existir, voc√™ receber√° um link para redefinir sua senha.'
-      });
-    }
-  } catch (e) {
-    console.error('‚ùå Erro em forgot-password:', e);
-    res.json({
-      ok: true,
-      message: 'Se o email existir, voc√™ receber√° um link para redefinir sua senha.'
-    });
-  }
-});
-
-// Resetar senha via token
-app.post('/api/auth/reset-password', authLimiter, async (req, res) => {
-  try {
-    const { hashPassword } = require('./utils/security.cjs');
-
-    const { token, new_password } = req.body || {};
-
-    if (!token || !new_password) {
-      return res.status(400).json({
-        ok: false,
-        error: 'missing_params',
-        message: 'Token e nova senha s√£o obrigat√≥rios'
-      });
-    }
-
-    if (String(new_password).length < 6) {
-      return res.status(400).json({
-        ok: false,
-        error: 'weak_password',
-        message: 'Senha deve ter no m√≠nimo 6 caracteres'
-      });
-    }
-
-    console.log('üîê Tentativa de reset de senha com token');
-
-    // Buscar usu√°rio com token v√°lido em users
-    let userId = null;
-    let expires = null;
-
-    try {
-      const [users] = await pool.execute(
-        'SELECT id, reset_expires FROM `rare_toy_companion`.`users` WHERE reset_token = ? LIMIT 1',
-        [token]
-      );
-
-      if (users && users.length > 0) {
-        userId = users[0].id;
-        expires = users[0].reset_expires ? new Date(users[0].reset_expires) : null;
-        console.log('‚úÖ Token encontrado em users:', userId);
-      } else {
-        // Tentar em customers
-        const [customers] = await pool.execute(
-          'SELECT id, reset_expires FROM `rare_toy_companion`.`customers` WHERE reset_token = ? LIMIT 1',
-          [token]
-        );
-
-        if (customers && customers.length > 0) {
-          userId = customers[0].id;
-          expires = customers[0].reset_expires ? new Date(customers[0].reset_expires) : null;
-          console.log('‚úÖ Token encontrado em customers:', userId);
-        }
-      }
-    } catch (e) {
-      console.error('‚ùå Erro ao buscar token:', e);
-    }
-
-    if (!userId) {
-      return res.status(400).json({
-        ok: false,
-        error: 'invalid_token',
-        message: 'Token inv√°lido ou expirado'
-      });
-    }
-
-    if (!expires || expires.getTime() < Date.now()) {
-      return res.status(400).json({
-        ok: false,
-        error: 'expired_token',
-        message: 'Token expirado. Solicite um novo link de redefini√ß√£o.'
-      });
-    }
-
-    // Gerar hash da nova senha
-    const hash = await hashPassword(String(new_password));
-
-    // Atualizar senha em users ou customers
-    try {
-      // Verificar em qual tabela o usu√°rio est√° e atualizar
-      const [checkUsers] = await pool.execute('SELECT id FROM `rare_toy_companion`.`users` WHERE id = ? LIMIT 1', [userId]);
-      if (checkUsers && checkUsers.length > 0) {
-        await pool.execute(
-          'UPDATE `rare_toy_companion`.`users` SET password_hash = ?, reset_token = NULL, reset_expires = NULL, updated_at = NOW() WHERE id = ?',
-          [hash, userId]
-        );
-        console.log('‚úÖ Senha atualizada em users');
-      } else {
-        // Tentar atualizar em customers (pode ter password_hash ou senha_hash)
-        try {
-          await pool.execute(
-            'UPDATE `rare_toy_companion`.`customers` SET password_hash = ?, reset_token = NULL, reset_expires = NULL WHERE id = ?',
-            [hash, userId]
-          );
-          console.log('‚úÖ Senha atualizada em customers (password_hash)');
-        } catch (e) {
-          // Fallback: tentar com senha_hash se password_hash n√£o existir
-          await pool.execute(
-            'UPDATE `rare_toy_companion`.`customers` SET senha_hash = ?, reset_token = NULL, reset_expires = NULL WHERE id = ?',
-            [hash, userId]
-          );
-          console.log('‚úÖ Senha atualizada em customers (senha_hash)');
-        }
-      }
-
-      console.log(`‚úÖ Senha resetada com sucesso para usu√°rio ID: ${userId}`);
-
-      return res.json({
-        ok: true,
-        message: 'Senha redefinida com sucesso! Voc√™ j√° pode fazer login.'
-      });
-    } catch (e) {
-      console.error('‚ùå Erro ao atualizar senha:', e);
-      return res.status(500).json({
-        ok: false,
-        error: 'reset_failed',
-        message: 'Erro ao redefinir senha. Tente novamente.'
-      });
-    }
-  } catch (e) {
-    console.error('‚ùå Erro em reset-password:', e);
-    res.status(500).json({
-      ok: false,
-      error: 'reset_failed',
-      message: 'Erro ao redefinir senha. Tente novamente.'
-    });
-  }
-});
-
 // ==========================
 // Favoritos (por usu√°rio mock_email ou cart_id)
 // ==========================
@@ -4610,7 +3054,7 @@ function getCurrentUserEmail(req) {
   return (req.cookies && req.cookies.mock_email) || null;
 }
 
-app.get('/api/favorites', highFrequencyLimiter, async (req, res) => {
+app.get('/api/favorites', async (req, res) => {
   try {
     const email = getCurrentUserEmail(req);
     const cartId = getOrCreateCartId(req, res);
@@ -4668,26 +3112,6 @@ app.get('/api/favorites', highFrequencyLimiter, async (req, res) => {
         await pool.execute('ALTER TABLE users ADD COLUMN nome VARCHAR(255) NULL AFTER password_hash');
         console.log('üîß Adicionada coluna users.nome');
       }
-      if (!fields.has('telefone')) {
-        await pool.execute('ALTER TABLE users ADD COLUMN telefone VARCHAR(50) NULL AFTER nome');
-        console.log('üîß Adicionada coluna users.telefone');
-      }
-      if (!fields.has('cidade')) {
-        await pool.execute('ALTER TABLE users ADD COLUMN cidade VARCHAR(100) NULL AFTER telefone');
-        console.log('üîß Adicionada coluna users.cidade');
-      }
-      if (!fields.has('estado')) {
-        await pool.execute('ALTER TABLE users ADD COLUMN estado VARCHAR(2) NULL AFTER cidade');
-        console.log('üîß Adicionada coluna users.estado');
-      }
-      if (!fields.has('endereco')) {
-        await pool.execute('ALTER TABLE users ADD COLUMN endereco TEXT NULL AFTER estado');
-        console.log('üîß Adicionada coluna users.endereco');
-      }
-      if (!fields.has('cep')) {
-        await pool.execute('ALTER TABLE users ADD COLUMN cep VARCHAR(10) NULL AFTER endereco');
-        console.log('üîß Adicionada coluna users.cep');
-      }
     } catch (e) {
       console.log('‚ÑπÔ∏è N√£o foi poss√≠vel ajustar colunas de users:', e?.message);
     }
@@ -4696,6 +3120,7 @@ app.get('/api/favorites', highFrequencyLimiter, async (req, res) => {
   }
 })();
 
+const crypto = require('crypto');
 const AUTH_SECRET = process.env.AUTH_SECRET || 'dev-secret-change-me';
 
 function signToken(payload) {
@@ -4719,11 +3144,7 @@ function verifyToken(token) {
 
 function setAuthCookie(res, payload) {
   const token = signToken(payload);
-  // Cookie seguro para auth_token
-  const { getSecureCookieOptions } = require('./utils/security.cjs');
-  res.cookie('auth_token', token, getSecureCookieOptions({
-    maxAge: 1000 * 60 * 60 * 24 * 7 // 7 dias
-  }));
+  res.cookie('auth_token', token, { httpOnly: true, sameSite: 'lax', maxAge: 1000 * 60 * 60 * 24 * 7 });
 }
 
 async function hashPassword(password) {
@@ -4752,444 +3173,56 @@ app.post('/api/auth/register', createAccountLimiter, async (req, res) => {
     const { email, senha, password, nome } = req.body || {};
     const mail = String(email || '').trim().toLowerCase();
     const pass = String(password || senha || '');
+    if (!mail || !/^[^@\s]+@[^@\s]+\.[^@\s]+$/.test(mail)) return res.status(400).json({ ok: false, error: 'invalid_email' });
+    if (pass.length < 6) return res.status(400).json({ ok: false, error: 'weak_password' });
+    const id = crypto.randomUUID();
+    const pw = await hashPassword(pass);
+    await pool.execute('INSERT INTO users (id, email, password_hash, nome) VALUES (?,?,?,?)', [id, mail, pw, nome || null]);
+    setAuthCookie(res, { id, email: mail });
+    logger.info('New user registered', { email: mail });
+    res.json({ ok: true });
+  } catch (e) {
+    if (e && e.code === 'ER_DUP_ENTRY') return res.status(409).json({ ok: false, error: 'email_in_use' });
+    logger.logError(e, req);
+    res.status(500).json({ ok: false, error: 'register_failed' });
+  }
+});
 
-    console.log('üìù Tentativa de registro:', mail);
-
-    // Valida√ß√µes
-    if (!mail || !/^[^@\s]+@[^@\s]+\.[^@\s]+$/.test(mail)) {
-      return res.status(400).json({
-        ok: false,
-        error: 'invalid_email',
-        message: 'Email inv√°lido. Por favor, verifique o formato do email.'
-      });
-    }
-
-    if (pass.length < 6) {
-      return res.status(400).json({
-        ok: false,
-        error: 'weak_password',
-        message: 'A senha deve ter no m√≠nimo 6 caracteres.'
-      });
-    }
-
-    // Verificar se email j√° existe em users ou customers
-    try {
-      const [existingUsers] = await pool.execute(
-        'SELECT id, email, password_hash FROM `rare_toy_companion`.`users` WHERE email = ? LIMIT 1',
-        [mail]
-      );
-
-      if (existingUsers && existingUsers.length > 0) {
-        const existingUser = existingUsers[0];
-
-        // Se o usu√°rio existe mas n√£o tem senha, permitir completar o cadastro
-        if (!existingUser.password_hash || existingUser.password_hash.trim() === '') {
-          console.log('‚ö†Ô∏è Usu√°rio existe sem senha, completando cadastro:', mail);
-
-          // Atualizar senha e nome do usu√°rio existente
-          const pw = await hashPassword(pass);
-          await pool.execute(
-            'UPDATE `rare_toy_companion`.`users` SET password_hash = ?, nome = COALESCE(?, nome), updated_at = NOW() WHERE email = ?',
-            [pw, nome || null, mail]
-          );
+// NOTA: Endpoint de login duplicado removido - usando apenas o sistema de sess√£o principal
 
-          // Criar entrada em customers se n√£o existir
-          const [existingCustomers] = await pool.execute(
-            'SELECT id FROM `rare_toy_companion`.`customers` WHERE email = ? LIMIT 1',
-            [mail]
-          );
+app.get('/api/auth/me', async (req, res) => {
+  try {
+    console.log('üîç GET /api/auth/me - Verificando autentica√ß√£o');
 
-          if (existingCustomers.length === 0) {
-            await pool.execute(
-              'INSERT INTO `rare_toy_companion`.`customers` (id, email, nome, created_at, updated_at) VALUES (?, ?, ?, NOW(), NOW())',
-              [existingUser.id, mail, nome || mail]
-            );
-          }
+    // Verificar sess√£o ativa
+    const sessionId = req.cookies?.session_id;
+    console.log('üîç Session ID:', sessionId ? 'presente' : 'ausente');
 
-          // Criar sess√£o
-          const sid = require('crypto').randomUUID();
-          await pool.execute(
-            'INSERT INTO sessions (id, user_email, user_id, created_at, last_seen) VALUES (?, ?, ?, NOW(), NOW()) ON DUPLICATE KEY UPDATE last_seen = NOW()',
-            [sid, mail, existingUser.id]
-          );
+    if (sessionId) {
+      const [sessions] = await pool.execute('SELECT * FROM sessions WHERE id = ?', [sessionId]);
+      console.log('üîç Sess√£o encontrada:', sessions && sessions[0] ? 'sim' : 'n√£o');
 
-          // Configurar cookie
-          const { getSecureCookieOptions } = require('./utils/security.cjs');
-          res.cookie('session_id', sid, getSecureCookieOptions({
-            maxAge: 1000 * 60 * 60 * 24 * 30
-          }));
+      if (sessions && sessions[0] && sessions[0].user_id) {
+        // Buscar dados completos do usu√°rio
+        const [users] = await pool.execute('SELECT id, email, nome, avatar_url, telefone, created_at FROM users WHERE id = ? LIMIT 1', [sessions[0].user_id]);
+        if (users && users[0]) {
+          console.log('‚úÖ Usu√°rio autenticado via sess√£o:', users[0].email);
 
-          setAuthCookie(res, { id: existingUser.id, email: mail });
-          logger.info('User registration completed (existing user)', { email: mail });
+          // Atualizar last_seen da sess√£o
+          await pool.execute('UPDATE sessions SET last_seen = NOW() WHERE id = ?', [sessionId]);
 
           return res.json({
-            ok: true,
-            message: 'Conta criada com sucesso!',
-            user: {
-              id: existingUser.id,
-              email: mail,
-              nome: nome || existingUser.nome || null
-            }
-          });
-        } else {
-          // Usu√°rio j√° existe E tem senha - retornar erro
-          console.log('‚ö†Ô∏è Email j√° existe com senha cadastrada:', mail);
-          return res.status(409).json({
-            ok: false,
-            error: 'email_in_use',
-            message: 'Este email j√° est√° cadastrado. Tente fazer login ou use "Esqueci minha senha".'
+            authenticated: true,
+            user: users[0],
+            sessionId: sessionId
           });
         }
       }
 
-      // Verificar em customers (se n√£o encontrou em users)
-      const [existingCustomers] = await pool.execute(
-        'SELECT id, email FROM `rare_toy_companion`.`customers` WHERE email = ? LIMIT 1',
-        [mail]
-      );
-
-      if (existingCustomers && existingCustomers.length > 0 && existingUsers.length === 0) {
-        // Existe em customers mas n√£o em users - criar em users com senha
-        console.log('‚ö†Ô∏è Email existe apenas em customers, criando em users:', mail);
-
-        const customerId = existingCustomers[0].id;
-        const pw = await hashPassword(pass);
-
-        await pool.execute(
-          'INSERT INTO `rare_toy_companion`.`users` (id, email, password_hash, nome, created_at, updated_at) VALUES (?, ?, ?, ?, NOW(), NOW())',
-          [customerId, mail, pw, nome || existingCustomers[0].nome || mail]
-        );
-
-        // Criar sess√£o
-        const sid = require('crypto').randomUUID();
-        await pool.execute(
-          'INSERT INTO sessions (id, user_email, user_id, created_at, last_seen) VALUES (?, ?, ?, NOW(), NOW())',
-          [sid, mail, customerId]
-        );
-
-        // Configurar cookie
-        const { getSecureCookieOptions } = require('./utils/security.cjs');
-        res.cookie('session_id', sid, getSecureCookieOptions({
-          maxAge: 1000 * 60 * 60 * 24 * 30
-        }));
-
-        setAuthCookie(res, { id: customerId, email: mail });
-        logger.info('User registration completed (existing customer)', { email: mail });
-
-        return res.json({
-          ok: true,
-          message: 'Conta criada com sucesso!',
-          user: {
-            id: customerId,
-            email: mail,
-            nome: nome || existingCustomers[0].nome || null
-          }
-        });
-      }
-    } catch (checkError) {
-      console.error('‚ùå Erro ao verificar email existente:', checkError);
-      // Continuar mesmo se houver erro na verifica√ß√£o (tentar inserir e capturar ER_DUP_ENTRY)
-    }
-
-    // Criar novo usu√°rio
-    const id = crypto.randomUUID();
-    const pw = await hashPassword(pass);
-
-    try {
-      // 1) Inserir em users
-      await pool.execute(
-        'INSERT INTO users (id, email, password_hash, nome) VALUES (?,?,?,?)',
-        [id, mail, pw, nome || null]
-      );
-      console.log('‚úÖ Usu√°rio registrado com sucesso:', mail);
-
-      // 2) Garantir registro correspondente em customers (para aparecer no Admin > Clientes)
-      try {
-        await pool.execute(
-          'INSERT INTO `rare_toy_companion`.`customers` (id, email, nome, created_at, updated_at) VALUES (?, ?, ?, NOW(), NOW()) ON DUPLICATE KEY UPDATE email = VALUES(email), nome = COALESCE(VALUES(nome), nome)',
-          [id, mail, nome || mail]
-        );
-        console.log('‚úÖ Registro criado/atualizado em customers para o usu√°rio:', mail);
-      } catch (customerError) {
-        console.error('‚ö†Ô∏è Erro ao criar registro em customers para novo usu√°rio:', customerError.message);
-        // N√£o falhar o registro se apenas a cria√ß√£o em customers falhar
-      }
-
-      // 3) Criar sess√£o automaticamente ap√≥s registro
-      const sid = require('crypto').randomUUID();
-      await pool.execute(
-        'INSERT INTO sessions (id, user_email, user_id, created_at, last_seen) VALUES (?, ?, ?, NOW(), NOW())',
-        [sid, mail, id]
-      );
-
-      // 4) Configurar cookie de sess√£o
-      const { getSecureCookieOptions } = require('./utils/security.cjs');
-      res.cookie('session_id', sid, getSecureCookieOptions({
-        maxAge: 1000 * 60 * 60 * 24 * 30 // 30 dias
-      }));
-
-      setAuthCookie(res, { id, email: mail });
-      logger.info('New user registered', { email: mail });
-
-      res.json({
-        ok: true,
-        message: 'Conta criada com sucesso!',
-        user: {
-          id,
-          email: mail,
-          nome: nome || null
-        }
-      });
-    } catch (insertError) {
-      // Se ainda assim houver ER_DUP_ENTRY (race condition)
-      if (insertError && insertError.code === 'ER_DUP_ENTRY') {
-        console.log('‚ö†Ô∏è ER_DUP_ENTRY capturado (race condition):', mail);
-        return res.status(409).json({
-          ok: false,
-          error: 'email_in_use',
-          message: 'Este email j√° est√° cadastrado. Tente fazer login ou use outro email.'
-        });
-      }
-      throw insertError; // Re-throw para ser capturado pelo catch externo
-    }
-  } catch (e) {
-    console.error('‚ùå Erro no registro:', e);
-    logger.logError(e, req);
-    res.status(500).json({
-      ok: false,
-      error: 'register_failed',
-      message: 'Erro ao criar conta. Tente novamente mais tarde.'
-    });
-  }
-});
-
-// ==================== SINCRONIZA√á√ÉO USERS -> CUSTOMERS (ADMIN) ====================
-
-/**
- * üîÑ Sincronizar tabela customers com tabela users
- *
- * - Cria registros em `customers` para todos os `users` que ainda n√£o possuem entrada correspondente
- * - Mant√©m o mesmo ID (para preservar relacionamentos com orders, etc.)
- * - Uso: Admin > Clientes > rodar manualmente quando necess√°rio
- */
-app.post('/api/admin/customers/sync-users', authenticateAdmin, async (req, res) => {
-  try {
-    console.log('üîÑ [SYNC] Iniciando sincroniza√ß√£o de customers com users...');
-
-    // Contar clientes antes
-    const [beforeRows] = await pool.execute('SELECT COUNT(*) as total FROM customers');
-    const beforeTotal = beforeRows && beforeRows[0] ? Number(beforeRows[0].total || 0) : 0;
-
-    // Inserir clientes que ainda n√£o existem
-    const [insertResult] = await pool.execute(`
-      INSERT INTO customers (id, email, nome, created_at, updated_at)
-      SELECT 
-        u.id,
-        u.email,
-        COALESCE(u.nome, u.email) AS nome,
-        NOW() AS created_at,
-        NOW() AS updated_at
-      FROM users u
-      LEFT JOIN customers c ON c.id = u.id
-      WHERE c.id IS NULL
-    `);
-
-    const inserted = insertResult && typeof insertResult.affectedRows === 'number'
-      ? insertResult.affectedRows
-      : 0;
-
-    // Contar clientes depois
-    const [afterRows] = await pool.execute('SELECT COUNT(*) as total FROM customers');
-    const afterTotal = afterRows && afterRows[0] ? Number(afterRows[0].total || 0) : beforeTotal + inserted;
-
-    console.log(`‚úÖ [SYNC] Conclu√≠da. Inseridos: ${inserted}, Total antes: ${beforeTotal}, Total depois: ${afterTotal}`);
-
-    res.json({
-      success: true,
-      message: inserted > 0
-        ? `Sincroniza√ß√£o conclu√≠da. ${inserted} cliente(s) adicionados.`
-        : 'Sincroniza√ß√£o conclu√≠da. Nenhum novo cliente para adicionar.',
-      inserted,
-      beforeTotal,
-      afterTotal,
-    });
-  } catch (error) {
-    console.error('‚ùå [SYNC] Erro ao sincronizar customers com users:', error);
-    logger.logError(error, req);
-    res.status(500).json({
-      success: false,
-      error: 'sync_failed',
-      message: 'Erro ao sincronizar clientes. Verifique os logs para mais detalhes.',
-    });
-  }
-});
-
-// NOTA: Endpoint duplicado de forgot-password removido
-// Usar apenas o endpoint em /api/auth/forgot-password (linha ~4279) que j√° foi evolu√≠do
-// com envio de email e funcionalidades completas
-
-// Resetar senha via token
-app.post('/api/auth/reset-password', authLimiter, async (req, res) => {
-  try {
-    const { hashPassword } = require('./utils/security.cjs');
-
-    const { token, new_password } = req.body || {};
-
-    if (!token || !new_password) {
-      return res.status(400).json({
-        ok: false,
-        error: 'missing_params',
-        message: 'Token e nova senha s√£o obrigat√≥rios'
-      });
-    }
-
-    if (String(new_password).length < 6) {
-      return res.status(400).json({
-        ok: false,
-        error: 'weak_password',
-        message: 'Senha deve ter no m√≠nimo 6 caracteres'
-      });
-    }
-
-    console.log('üîê Tentativa de reset de senha com token');
-
-    // Buscar usu√°rio com token v√°lido em users
-    let userId = null;
-    let expires = null;
-
-    try {
-      const [users] = await pool.execute(
-        'SELECT id, reset_expires FROM `rare_toy_companion`.`users` WHERE reset_token = ? LIMIT 1',
-        [token]
-      );
-
-      if (users && users.length > 0) {
-        userId = users[0].id;
-        expires = users[0].reset_expires ? new Date(users[0].reset_expires) : null;
-        console.log('‚úÖ Token encontrado em users:', userId);
-      } else {
-        // Tentar em customers
-        const [customers] = await pool.execute(
-          'SELECT id, reset_expires FROM `rare_toy_companion`.`customers` WHERE reset_token = ? LIMIT 1',
-          [token]
-        );
-
-        if (customers && customers.length > 0) {
-          userId = customers[0].id;
-          expires = customers[0].reset_expires ? new Date(customers[0].reset_expires) : null;
-          console.log('‚úÖ Token encontrado em customers:', userId);
-        }
-      }
-    } catch (e) {
-      console.error('‚ùå Erro ao buscar token:', e);
-    }
-
-    if (!userId) {
-      return res.status(400).json({
-        ok: false,
-        error: 'invalid_token',
-        message: 'Token inv√°lido ou expirado'
-      });
-    }
-
-    if (!expires || expires.getTime() < Date.now()) {
-      return res.status(400).json({
-        ok: false,
-        error: 'expired_token',
-        message: 'Token expirado. Solicite um novo link de redefini√ß√£o.'
-      });
-    }
-
-    // Gerar hash da nova senha
-    const hash = await hashPassword(String(new_password));
-
-    // Atualizar senha em users ou customers
-    try {
-      // Verificar em qual tabela o usu√°rio est√° e atualizar
-      const [checkUsers] = await pool.execute('SELECT id FROM `rare_toy_companion`.`users` WHERE id = ? LIMIT 1', [userId]);
-      if (checkUsers && checkUsers.length > 0) {
-        await pool.execute(
-          'UPDATE `rare_toy_companion`.`users` SET password_hash = ?, reset_token = NULL, reset_expires = NULL, updated_at = NOW() WHERE id = ?',
-          [hash, userId]
-        );
-        console.log('‚úÖ Senha atualizada em users');
-      } else {
-        // Tentar atualizar em customers (pode ter password_hash ou senha_hash)
-        try {
-          await pool.execute(
-            'UPDATE `rare_toy_companion`.`customers` SET password_hash = ?, reset_token = NULL, reset_expires = NULL WHERE id = ?',
-            [hash, userId]
-          );
-          console.log('‚úÖ Senha atualizada em customers (password_hash)');
-        } catch (e) {
-          // Fallback: tentar com senha_hash se password_hash n√£o existir
-          await pool.execute(
-            'UPDATE `rare_toy_companion`.`customers` SET senha_hash = ?, reset_token = NULL, reset_expires = NULL WHERE id = ?',
-            [hash, userId]
-          );
-          console.log('‚úÖ Senha atualizada em customers (senha_hash)');
-        }
-      }
-
-      console.log(`‚úÖ Senha resetada com sucesso para usu√°rio ID: ${userId}`);
-
-      return res.json({
-        ok: true,
-        message: 'Senha redefinida com sucesso! Voc√™ j√° pode fazer login.'
-      });
-    } catch (e) {
-      console.error('‚ùå Erro ao atualizar senha:', e);
-      return res.status(500).json({
-        ok: false,
-        error: 'reset_failed',
-        message: 'Erro ao redefinir senha. Tente novamente.'
-      });
-    }
-  } catch (e) {
-    console.error('‚ùå Erro em reset-password:', e);
-    res.status(500).json({
-      ok: false,
-      error: 'reset_failed',
-      message: 'Erro ao redefinir senha. Tente novamente.'
-    });
-  }
-});
-
-// NOTA: Endpoint de login duplicado removido - usando apenas o sistema de sess√£o principal
-
-app.get('/api/auth/me', authRoutesLimiter, async (req, res) => {
-  try {
-    console.log('üîç GET /api/auth/me - Verificando autentica√ß√£o');
-
-    // Verificar sess√£o ativa
-    const sessionId = req.cookies?.session_id;
-    console.log('üîç Session ID:', sessionId ? 'presente' : 'ausente');
-
-    if (sessionId) {
-      const [sessions] = await pool.execute('SELECT * FROM sessions WHERE id = ?', [sessionId]);
-      console.log('üîç Sess√£o encontrada:', sessions && sessions[0] ? 'sim' : 'n√£o');
-
-      if (sessions && sessions[0] && sessions[0].user_id) {
-        // Buscar dados completos do usu√°rio
-        const [users] = await pool.execute('SELECT id, email, nome, avatar_url, telefone, created_at FROM users WHERE id = ? LIMIT 1', [sessions[0].user_id]);
-        if (users && users[0]) {
-          console.log('‚úÖ Usu√°rio autenticado via sess√£o:', users[0].email);
-
-          // Atualizar last_seen da sess√£o
-          await pool.execute('UPDATE sessions SET last_seen = NOW() WHERE id = ?', [sessionId]);
-
-          return res.json({
-            authenticated: true,
-            user: users[0],
-            sessionId: sessionId
-          });
-        }
-      }
-
-      // Se sess√£o existe mas usu√°rio n√£o foi encontrado, remover sess√£o inv√°lida
-      if (sessions && sessions[0]) {
-        await pool.execute('DELETE FROM sessions WHERE id = ?', [sessionId]);
-        console.log('üóëÔ∏è Sess√£o inv√°lida removida:', sessionId);
+      // Se sess√£o existe mas usu√°rio n√£o foi encontrado, remover sess√£o inv√°lida
+      if (sessions && sessions[0]) {
+        await pool.execute('DELETE FROM sessions WHERE id = ?', [sessionId]);
+        console.log('üóëÔ∏è Sess√£o inv√°lida removida:', sessionId);
       }
     }
 
@@ -5258,15 +3291,7 @@ function getOrCreateCartId(req, res) {
   let cartId = req.cookies?.cart_id;
   if (!cartId) {
     cartId = require('crypto').randomUUID();
-    // Cookie para cart_id (pode ser false httpOnly pois √© usado no frontend)
-    // Mas mantemos secure e sameSite para seguran√ßa
-    const isHttps = (req.headers['x-forwarded-proto'] || req.protocol) === 'https' || process.env.NODE_ENV === 'production';
-    res.cookie('cart_id', cartId, {
-      httpOnly: false, // Necess√°rio para acesso no frontend
-      sameSite: 'lax',
-      secure: isHttps,
-      maxAge: 1000 * 60 * 60 * 24 * 30 // 30 dias
-    });
+    res.cookie('cart_id', cartId, { httpOnly: false, sameSite: 'lax', secure: (req.headers['x-forwarded-proto'] || req.protocol) === 'https', maxAge: 1000 * 60 * 60 * 24 * 30 });
   }
   return cartId;
 }
@@ -5289,14 +3314,15 @@ function mapCartItemRow(r, req) {
   };
 }
 
-app.get('/api/cart', highFrequencyLimiter, async (req, res) => {
+app.get('/api/cart', async (req, res) => {
   try {
     const cartId = getOrCreateCartId(req, res);
     await ensureCartExists(cartId);
-    // Buscar itens do carrinho sem JOIN com products (tabela n√£o existe)
+    // JOIN com tabela products para obter informa√ß√µes completas do produto
     const [rows] = await pool.execute(`
-      SELECT ci.*, ci.name as produto_nome, ci.price, ci.quantity
+      SELECT ci.*, p.nome as produto_nome, p.estoque, p.categoria, p.status
       FROM cart_items ci
+      LEFT JOIN products p ON ci.product_id = p.id
       WHERE ci.cart_id = ? 
       ORDER BY ci.created_at ASC
     `, [cartId]);
@@ -5373,20 +3399,9 @@ app.delete('/api/cart/items/:id', async (req, res) => {
 // Cria√ß√£o de pedido a partir do carrinho atual
 app.post('/api/orders', async (req, res) => {
   try {
-    console.log('üõí ========== INICIANDO CRIA√á√ÉO DE PEDIDO ==========');
-    console.log('üì¶ Body recebido:', JSON.stringify(req.body, null, 2));
-    console.log('üç™ Cookies:', req.cookies);
-
     const cartId = getOrCreateCartId(req, res);
-    console.log('üõí Cart ID:', cartId);
-
     const [rows] = await pool.execute('SELECT * FROM cart_items WHERE cart_id = ?', [cartId]);
-    console.log(`üìä Itens no carrinho: ${rows.length}`);
-
-    if (!rows.length) {
-      console.log('‚ùå Carrinho vazio!');
-      return res.status(400).json({ error: 'carrinho_vazio', message: 'Adicione itens ao carrinho antes de finalizar' });
-    }
+    if (!rows.length) return res.status(400).json({ error: 'carrinho_vazio' });
 
     // Validar e limpar produtos inexistentes do carrinho
     const validItems = [];
@@ -5422,7 +3437,7 @@ app.post('/api/orders', async (req, res) => {
     const orderId = require('crypto').randomUUID();
 
     // Dados de entrega/pagamento do body
-    const { nome, email, telefone, endereco, metodoPagamento, payment_status = 'pending', user_id, coupon_code, discount_amount } = req.body || {};
+    const { nome, email, telefone, endereco, metodoPagamento, payment_status = 'pending', user_id } = req.body || {};
 
     // Obter user_id da sess√£o se dispon√≠vel
     let userId = user_id;
@@ -5479,8 +3494,6 @@ app.post('/api/orders', async (req, res) => {
       const hasEmail = columns.includes('email');
       const hasTelefone = columns.includes('telefone');
       const hasPaymentStatus = columns.includes('payment_status');
-      const hasCouponCode = columns.includes('coupon_code');
-      const hasDiscountAmount = columns.includes('discount_amount');
 
       // Montar colunas dinamicamente priorizando nomes do schema atual
       // Descobrir tipo de status
@@ -5536,23 +3549,10 @@ app.post('/api/orders', async (req, res) => {
         values.push(payment_status);
       }
 
-      // Cupom de desconto
-      if (hasCouponCode && coupon_code) {
-        insertCols.push('coupon_code');
-        values.push(coupon_code);
-      }
-
-      if (hasDiscountAmount && discount_amount) {
-        insertCols.push('discount_amount');
-        values.push(Number(discount_amount) || 0);
-      }
-
       const placeholders = insertCols.map(() => '?').join(',');
       const sql = `INSERT INTO orders (${insertCols.join(', ')}) VALUES (${placeholders})`;
       await pool.execute(sql, values);
 
-      console.log(`‚úÖ Cupom aplicado: ${coupon_code} - Desconto: R$ ${Number(discount_amount || 0).toFixed(2)}`);
-
       console.log(`‚úÖ Pedido criado: ${orderId} para ${userId ? `user_id=${userId}` : `cart_id=${cartId}`}`);
     } catch (e) {
       console.log('‚ùå Erro ao verificar estrutura da tabela orders:', e.message);
@@ -5600,72 +3600,17 @@ app.post('/api/orders', async (req, res) => {
 
     // Limpa carrinho
     await pool.execute('DELETE FROM cart_items WHERE cart_id = ?', [cartId]);
-    console.log(`üóëÔ∏è Carrinho limpo: ${cartId}`);
-
-    // Buscar dados completos do cliente para automa√ß√µes
-    let customerData = null;
-    if (userId) {
-      try {
-        const [customers] = await pool.execute(
-          'SELECT id, nome, email, type FROM customers WHERE id = ?',
-          [userId]
-        );
-        if (customers.length > 0) {
-          customerData = customers[0];
-        }
-      } catch (e) {
-        console.log('‚ö†Ô∏è Erro ao buscar dados do cliente:', e.message);
-      }
-    }
-
-    // Processar automa√ß√µes para pedido criado
-    if (orderAutomationService) {
-      try {
-        const eventData = {
-          order_id: orderId,
-          status: 'pending',
-          customer_id: userId,
-          customer_email: email || customerData?.email,
-          customer_name: nome || customerData?.nome,
-          customer_type: customerData?.type || 'regular',
-          total: total,
-          items: items.map(it => ({
-            product_id: it.product_id,
-            quantity: it.quantity,
-            price: it.price
-          }))
-        };
 
-        await orderAutomationService.processEvent('order_created', eventData);
-        console.log('‚úÖ Automa√ß√µes processadas para pedido criado');
-      } catch (autoError) {
-        console.error('‚ö†Ô∏è Erro ao processar automa√ß√µes:', autoError);
-        // N√£o falhar o pedido por erro de automa√ß√£o
-      }
-    }
-
-    const response = {
+    res.status(201).json({
       id: orderId,
       status: 'criado',
       total,
       payment_status: payment_status,
-      customer_id: userId || null,
       dadosEntrega: { nome: nome || null, email: email || null, telefone: telefone || null, endereco: endereco || null, metodoPagamento: metodoPagamento || null }
-    };
-
-    console.log('‚úÖ ========== PEDIDO CRIADO COM SUCESSO ==========');
-    console.log('üìù Resposta:', JSON.stringify(response, null, 2));
-
-    res.status(201).json(response);
-  } catch (e) {
-    console.error('‚ùå ========== ERRO AO CRIAR PEDIDO ==========');
-    console.error('üí• Erro completo:', e);
-    console.error('üìç Stack:', e.stack);
-    res.status(500).json({
-      error: 'order_create_failed',
-      message: e.message || 'Erro ao criar pedido',
-      details: process.env.NODE_ENV === 'development' ? e.stack : undefined
     });
+  } catch (e) {
+    console.error('Order create error', e);
+    res.status(500).json({ error: 'order_create_failed' });
   }
 });
 
@@ -5793,28 +3738,11 @@ function calculateCRC16(str) {
   return crc;
 }
 
-// Fun√ß√£o para gerar QR Code usando API externa
+// Fun√ß√£o para gerar QR Code (mock por enquanto)
 async function generateQRCodeImage(pixCode) {
-  try {
-    // Usar API gratuita do QR Server para gerar QR Code
-    // Tamanho: 300x300 pixels, formato PNG
-    const encodedCode = encodeURIComponent(pixCode);
-    const qrCodeUrl = `https://api.qrserver.com/v1/create-qr-code/?size=300x300&data=${encodedCode}&format=png&margin=1`;
-
-    // Verificar se a URL foi gerada corretamente
-    if (!qrCodeUrl || !pixCode) {
-      console.warn('‚ö†Ô∏è Erro ao gerar URL do QR Code');
-      // Fallback: retornar URL que gera QR Code vazio
-      return `https://api.qrserver.com/v1/create-qr-code/?size=300x300&data=error&format=png`;
-    }
-
-    console.log('‚úÖ QR Code URL gerada:', qrCodeUrl.substring(0, 100) + '...');
-    return qrCodeUrl;
-  } catch (error) {
-    console.error('‚ùå Erro ao gerar QR Code:', error);
-    // Fallback: retornar URL de QR Code de erro
-    return `https://api.qrserver.com/v1/create-qr-code/?size=300x300&data=error&format=png`;
-  }
+  // Em produ√ß√£o, usar uma biblioteca como 'qrcode' ou 'qrcode-generator'
+  // Por enquanto, retornar uma imagem base64 mock
+  return `data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNkYPhfDwAChwGA60e6kgAAAABJRU5ErkJggg==`;
 }
 
 // Endpoint para gerar QR Code PIX do carrinho
@@ -5918,117 +3846,6 @@ app.get('/api/orders/:id/status', async (req, res) => {
 });
 
 // Endpoint para simular pagamento confirmado (mock)
-// POST /api/orders/:id/infinitetap-result - Processar resultado do InfiniteTap
-app.post('/api/orders/:id/infinitetap-result', async (req, res) => {
-  try {
-    const { id } = req.params;
-    const { nsu, aut, card_brand, user_id, access_id, handle, merchant_document, warning, success } = req.body;
-
-    console.log(`üí≥ [InfiniteTap] Processando resultado para pedido ${id}`);
-
-    // Validar campos obrigat√≥rios
-    if (!nsu || !aut) {
-      return res.status(400).json({
-        error: 'Campos obrigat√≥rios faltando',
-        message: 'nsu e aut s√£o obrigat√≥rios'
-      });
-    }
-
-    // Buscar pedido
-    const [orders] = await pool.execute('SELECT * FROM orders WHERE id = ?', [id]);
-    if (orders.length === 0) {
-      return res.status(404).json({ error: 'Pedido n√£o encontrado' });
-    }
-
-    const order = orders[0];
-
-    // Determinar status do pagamento
-    let paymentStatus = 'pending';
-    if (success && !warning) {
-      paymentStatus = 'paid';
-    } else if (warning) {
-      paymentStatus = 'failed';
-    }
-
-    // Atualizar pedido com informa√ß√µes do InfiniteTap
-    await pool.execute(
-      `UPDATE orders SET 
-        payment_status = ?,
-        metodo_pagamento = 'infinitetap',
-        updated_at = NOW()
-      WHERE id = ?`,
-      [paymentStatus, id]
-    );
-
-    // Salvar detalhes da transa√ß√£o (opcional: criar tabela order_payments se necess√°rio)
-    try {
-      await pool.execute(
-        `INSERT INTO order_payments (
-          order_id, payment_method, transaction_id, authorization_code, 
-          card_brand, status, metadata, created_at
-        ) VALUES (?, ?, ?, ?, ?, ?, ?, NOW())
-        ON DUPLICATE KEY UPDATE
-          transaction_id = VALUES(transaction_id),
-          authorization_code = VALUES(authorization_code),
-          card_brand = VALUES(card_brand),
-          status = VALUES(status),
-          metadata = VALUES(metadata),
-          updated_at = NOW()`,
-        [
-          id,
-          'infinitetap',
-          nsu,
-          aut,
-          card_brand || 'unknown',
-          paymentStatus,
-          JSON.stringify({
-            user_id,
-            access_id,
-            handle,
-            merchant_document,
-            warning
-          })
-        ]
-      );
-    } catch (e) {
-      // Se a tabela order_payments n√£o existir, apenas logar
-      console.warn('‚ö†Ô∏è Tabela order_payments n√£o encontrada, pulando salvamento de detalhes:', e.message);
-    }
-
-    // Se pagamento aprovado, atualizar estoque
-    if (paymentStatus === 'paid') {
-      const [items] = await pool.execute('SELECT * FROM order_items WHERE order_id = ?', [id]);
-      for (const item of items) {
-        await pool.execute(
-          'UPDATE produtos SET estoque = estoque - ? WHERE id = ?',
-          [item.quantity, item.product_id]
-        );
-      }
-    }
-
-    console.log(`‚úÖ [InfiniteTap] Resultado processado para pedido ${id}: ${paymentStatus}`);
-
-    res.json({
-      success: true,
-      order_id: id,
-      payment_status: paymentStatus,
-      transaction: {
-        nsu,
-        aut,
-        card_brand,
-        warning
-      }
-    });
-
-  } catch (error) {
-    console.error('‚ùå [InfiniteTap] Erro ao processar resultado:', error);
-    res.status(500).json({
-      error: 'Erro ao processar resultado do InfiniteTap',
-      message: error?.message
-    });
-  }
-});
-
 app.post('/api/orders/:id/confirm-payment', async (req, res) => {
   try {
     const { id } = req.params;
@@ -6054,7 +3871,7 @@ app.post('/api/orders/:id/confirm-payment', async (req, res) => {
 });
 
 // Lista pedidos simples (por user_id ou cart_id)
-app.get('/api/orders', highFrequencyLimiter, async (req, res) => {
+app.get('/api/orders', async (req, res) => {
   try {
     console.log('üì¶ GET /api/orders - Listando pedidos');
 
@@ -6096,13 +3913,13 @@ app.get('/api/orders', highFrequencyLimiter, async (req, res) => {
     }
 
     // Buscar APENAS pedidos do usu√°rio logado
-    console.log('üîç Buscando pedidos para user_id:', userId);
+    console.log('üîç Buscando pedidos para customer_id:', userId);
     const [orders] = await pool.execute(
       `SELECT o.*, (SELECT COALESCE(SUM(oi.quantity), 0) FROM order_items oi WHERE oi.order_id = o.id) AS items_count
          FROM orders o
-        WHERE o.user_id = ?
+        WHERE o.customer_id = ? OR o.user_id = ?
      ORDER BY o.created_at DESC`,
-      [userId]
+      [userId, userId]
     );
 
     // Normalizar status e tipos para frontend
@@ -6138,14277 +3955,5001 @@ app.get('/api/orders', highFrequencyLimiter, async (req, res) => {
 // const adminOrdersRouter = require('./routes/admin-orders.cjs');
 // app.use('/api/admin', adminOrdersRouter);
 
-// ==================== AUDITORIA: ENDPOINTS ====================
-
-// GET /api/admin/audit-logs - Listar logs de auditoria
-app.get('/api/admin/audit-logs', authenticateAdmin, async (req, res) => {
+// Manter rota antiga para compatibilidade (deprecated)
+app.get('/api/admin/orders', async (req, res) => {
   try {
-    const { getAuditLogs } = require('./utils/audit.cjs');
+    // Query simplificada sem JOIN (tabela users n√£o existe no banco atual)
+    const [orders] = await pool.execute(`
+      SELECT 
+        o.*,
+        (SELECT COUNT(*) FROM order_items oi WHERE oi.order_id = o.id) AS items_count
+      FROM orders o
+      ORDER BY o.created_at DESC
+    `);
 
-    const {
-      userId,
-      action,
-      resourceType,
-      resourceId,
-      startDate,
-      endDate,
-      page = 1,
-      limit = 50
-    } = req.query;
-
-    const offset = (parseInt(page) - 1) * parseInt(limit);
-
-    const logs = await getAuditLogs({
-      userId: userId ? parseInt(userId) : null,
-      action: action || null,
-      resourceType: resourceType || null,
-      resourceId: resourceId || null,
-      startDate: startDate || null,
-      endDate: endDate || null,
-      limit: parseInt(limit),
-      offset
-    });
+    const normalized = (orders || []).map((order) => ({
+      id: order.id,
+      user_id: order.client_id,
+      status: order.status || 'pending',
+      total: Number(order.total_amount || 0),
+      created_at: order.created_at,
+      updated_at: order.updated_at,
+      items_count: Number(order.items_count || 0),
+      items: [],
+
+      // Dados do cliente (n√£o dispon√≠veis no banco atual)
+      customer_name: 'Cliente n√£o identificado',
+      customer_email: 'Email n√£o informado',
+      customer_phone: null,
+
+      // Campos padr√£o para compatibilidade
+      shipping_address: order.shipping_address || null,
+      payment_method: order.payment_method || null,
+      payment_status: 'pending',
+      tracking_code: null,
+      estimated_delivery: null,
+    }));
 
-    // Contar total
-    const { getPool } = require('./utils/audit.cjs');
-    const dbPool = getPool();
-    let countQuery = 'SELECT COUNT(*) as total FROM audit_logs WHERE 1=1';
-    const countParams = [];
+    res.json(normalized);
+  } catch (error) {
+    console.error('Erro na rota /api/admin/orders:', error);
+    logger.logError(error, req);
+    res.status(500).json({ error: 'Erro ao buscar pedidos' });
+  }
+});
 
-    if (userId) {
-      countQuery += ' AND user_id = ?';
-      countParams.push(userId);
-    }
-    if (action) {
-      countQuery += ' AND action = ?';
-      countParams.push(action);
-    }
-    if (resourceType) {
-      countQuery += ' AND resource_type = ?';
-      countParams.push(resourceType);
+// Lista todos os pedidos evolu√≠do (com dados dos clientes sincronizados)
+app.get('/api/admin/orders-evolved', async (req, res) => {
+  try {
+    // Primeiro, tentar com JOIN para customers (se a tabela existir)
+    let orders;
+    try {
+      [orders] = await pool.execute(`
+        SELECT 
+          o.*,
+          c.id as customer_id,
+          c.nome as customer_nome,
+          c.email as customer_email,
+          c.telefone as customer_telefone,
+          c.total_pedidos as customer_total_pedidos,
+          c.total_gasto as customer_total_gasto,
+          c.ultimo_pedido as customer_ultimo_pedido,
+          CASE 
+            WHEN c.id IS NOT NULL THEN 'Cliente Sincronizado'
+            WHEN o.user_id IS NOT NULL THEN 'Cliente Registrado'
+            ELSE 'Cliente An√¥nimo'
+          END as customer_type
+        FROM orders o
+        LEFT JOIN customers c ON o.customer_id = c.id
+        ORDER BY o.created_at DESC
+      `);
+    } catch (joinError) {
+      // Se der erro no JOIN, usar query simples
+      console.log('Tabela customers n√£o existe, usando query simples');
+      [orders] = await pool.execute(`
+        SELECT 
+          o.*,
+          CASE 
+            WHEN o.customer_id IS NOT NULL THEN 'Cliente Associado'
+            WHEN o.user_id IS NOT NULL THEN 'Cliente Registrado'
+            ELSE 'Cliente An√¥nimo'
+          END as customer_type
+        FROM orders o
+        ORDER BY o.created_at DESC
+      `);
     }
 
-    const [countResult] = await dbPool.execute(countQuery, countParams);
-    const total = countResult[0].total;
-
-    res.json({
-      logs,
-      pagination: {
-        page: parseInt(page),
-        limit: parseInt(limit),
-        total,
-        pages: Math.ceil(total / limit)
-      }
-    });
+    // Transformar dados para facilitar o uso no frontend
+    const ordersWithCustomer = orders.map(order => ({
+      ...order,
+      customer: order.customer_id ? {
+        id: order.customer_id,
+        nome: order.customer_nome || 'Cliente Associado',
+        email: order.customer_email || order.email || 'Email n√£o informado',
+        telefone: order.customer_telefone || order.telefone || 'Telefone n√£o informado',
+        total_pedidos: order.customer_total_pedidos || 0,
+        total_gasto: order.customer_total_gasto || 0,
+        ultimo_pedido: order.customer_ultimo_pedido || order.created_at,
+      } : null
+    }));
 
+    res.json(ordersWithCustomer);
   } catch (error) {
-    console.error('‚ùå Erro ao buscar logs de auditoria:', error);
-    res.status(500).json({ error: 'Erro ao buscar logs de auditoria' });
+    console.error('Erro ao buscar pedidos evolu√≠do:', error);
+    res.status(500).json({ error: 'Erro interno do servidor' });
   }
 });
 
-// GET /api/admin/audit-logs/stats - Estat√≠sticas de auditoria
-app.get('/api/admin/audit-logs/stats', authenticateAdmin, async (req, res) => {
+// Estat√≠sticas de pedidos evolu√≠do (Admin)
+app.get('/api/admin/orders-stats-evolved', async (req, res) => {
   try {
-    const { getPool } = require('./utils/audit.cjs');
-    const dbPool = getPool();
-
-    // Estat√≠sticas gerais
-    const [totalLogs] = await dbPool.execute('SELECT COUNT(*) as total FROM audit_logs');
-    const [todayLogs] = await dbPool.execute(
-      'SELECT COUNT(*) as total FROM audit_logs WHERE DATE(created_at) = CURDATE()'
-    );
-    const [thisWeekLogs] = await dbPool.execute(
-      'SELECT COUNT(*) as total FROM audit_logs WHERE created_at >= DATE_SUB(NOW(), INTERVAL 7 DAY)'
-    );
-
-    // A√ß√µes mais frequentes
-    const [topActions] = await dbPool.execute(
-      `SELECT action, COUNT(*) as count 
-       FROM audit_logs 
-       WHERE created_at >= DATE_SUB(NOW(), INTERVAL 30 DAY)
-       GROUP BY action 
-       ORDER BY count DESC 
-       LIMIT 10`
-    );
-
-    // Recursos mais acessados
-    const [topResources] = await dbPool.execute(
-      `SELECT resource_type, COUNT(*) as count 
-       FROM audit_logs 
-       WHERE created_at >= DATE_SUB(NOW(), INTERVAL 30 DAY)
-       GROUP BY resource_type 
-       ORDER BY count DESC 
-       LIMIT 10`
-    );
-
-    // Usu√°rios mais ativos
-    const [topUsers] = await dbPool.execute(
-      `SELECT user_id, user_email, COUNT(*) as count 
-       FROM audit_logs 
-       WHERE created_at >= DATE_SUB(NOW(), INTERVAL 30 DAY)
-       AND user_id IS NOT NULL
-       GROUP BY user_id, user_email 
-       ORDER BY count DESC 
-       LIMIT 10`
-    );
-
-    res.json({
-      total: totalLogs[0].total,
-      today: todayLogs[0].total,
-      thisWeek: thisWeekLogs[0].total,
-      topActions,
-      topResources,
-      topUsers
-    });
+    const [stats] = await pool.execute(`
+      SELECT 
+        COUNT(*) as total,
+        SUM(CASE WHEN o.status = 'pending' THEN 1 ELSE 0 END) as pending,
+        SUM(CASE WHEN o.status = 'processing' THEN 1 ELSE 0 END) as processing,
+        SUM(CASE WHEN o.status = 'shipped' THEN 1 ELSE 0 END) as shipped,
+        SUM(CASE WHEN o.status = 'delivered' THEN 1 ELSE 0 END) as delivered,
+        SUM(CASE WHEN o.status = 'cancelled' THEN 1 ELSE 0 END) as cancelled,
+        SUM(o.total) as totalRevenue,
+        AVG(o.total) as averageTicket,
+        SUM(CASE WHEN DATE(o.created_at) = CURDATE() THEN 1 ELSE 0 END) as todayOrders,
+        SUM(CASE WHEN DATE(o.created_at) = CURDATE() THEN o.total ELSE 0 END) as todayRevenue,
+        COUNT(DISTINCT o.customer_id) as totalCustomers,
+        SUM(CASE WHEN DATE(o.created_at) = CURDATE() AND o.customer_id IS NOT NULL THEN 1 ELSE 0 END) as newCustomers
+      FROM orders o
+    `);
 
+    res.json(stats[0] || {});
   } catch (error) {
-    console.error('‚ùå Erro ao buscar estat√≠sticas de auditoria:', error);
-    res.status(500).json({ error: 'Erro ao buscar estat√≠sticas' });
+    console.error('Erro ao buscar estat√≠sticas evolu√≠do:', error);
+    res.status(500).json({ error: 'Erro interno do servidor' });
   }
 });
 
-// POST /api/admin/audit-logs/clean - Limpar logs antigos
-app.post('/api/admin/audit-logs/clean', authenticateAdmin, async (req, res) => {
+// Buscar clientes para associa√ß√£o
+app.get('/api/admin/customers/search', async (req, res) => {
   try {
-    const { cleanOldAuditLogs } = require('./utils/audit.cjs');
-    const { daysToKeep = 90 } = req.body;
-
-    if (daysToKeep < 30) {
-      return res.status(400).json({ error: 'M√≠nimo de 30 dias para manter logs' });
-    }
-
-    const deletedCount = await cleanOldAuditLogs(parseInt(daysToKeep));
-
-    // Registrar a√ß√£o de limpeza
-    const { logAudit } = require('./utils/audit.cjs');
-    await logAudit({
-      userId: req.adminUser.id,
-      userEmail: req.adminUser.email,
-      action: 'clean',
-      resourceType: 'audit_logs',
-      req,
-      metadata: {
-        daysToKeep,
-        deletedCount
-      }
-    });
+    const { q } = req.query;
 
-    res.json({
-      success: true,
-      message: `Limpeza conclu√≠da: ${deletedCount} registros removidos`,
-      deletedCount
-    });
+    if (!q || q.length < 2) {
+      return res.json([]);
+    }
+
+    const [customers] = await pool.execute(`
+      SELECT 
+        id,
+        nome,
+        email,
+        telefone,
+        total_pedidos,
+        total_gasto,
+        status,
+        created_at
+      FROM customers 
+      WHERE 
+        nome LIKE ? OR 
+        email LIKE ? OR 
+        telefone LIKE ?
+      ORDER BY 
+        CASE WHEN nome LIKE ? THEN 1 ELSE 2 END,
+        total_gasto DESC
+      LIMIT 10
+    `, [`%${q}%`, `%${q}%`, `%${q}%`, `${q}%`]);
 
+    res.json(customers);
   } catch (error) {
-    console.error('‚ùå Erro ao limpar logs:', error);
-    res.status(500).json({ error: 'Erro ao limpar logs' });
+    console.error('Erro ao buscar clientes:', error);
+    res.status(500).json({ error: 'Erro interno do servidor' });
   }
 });
 
-// Aplicar autentica√ß√£o e auditoria a todas as rotas /api/admin/*
-try {
-  const { authenticateAdmin } = require('./middleware/auth.cjs');
-  const { adminAudit } = require('./middleware/admin-audit.cjs');
-  app.use('/api/admin', authenticateAdmin, adminAudit);
-} catch (_e) {
-  console.warn('Admin auth/audit middleware indispon√≠vel:', _e?.message);
-}
-
-// Rotas de sincroniza√ß√£o
-const syncApiRouter = require('./routes/sync-api.cjs');
-app.use('/api/admin/sync', syncApiRouter);
-
-// Rotas de E-mail Marketing
-const emailMarketingRouter = require('./routes/emailMarketing.cjs');
-app.use('/api/email-marketing', emailMarketingRouter);
-
-// Rotas de Analytics
-const analyticsRouter = require('./routes/analytics.cjs');
-app.use('/api/analytics', analyticsRouter);
-
-// Rotas de Cupons e Fidelidade
-const couponsRouter = require('./routes/coupons.cjs');
-app.use('/api/coupons', couponsRouter);
-
-// Rotas de Notifica√ß√µes
-const notificationsRouter = require('./routes/notifications.cjs');
-app.use('/api/notifications', notificationsRouter);
-
-// Rotas de Estoque e Fornecedores
-const inventoryRouter = require('./routes/inventory.cjs');
-app.use('/api/inventory', inventoryRouter);
-
-// Rotas de CRM
-const crmRouter = require('./routes/crm.cjs');
-app.use('/api/crm', crmRouter);
-
-// Rotas de Produtos
-const productsRouter = require('./routes/products.routes.cjs');
-app.use('/api/produtos', productsRouter);
-
-// Rotas de Gest√£o de Pedidos
-const ordersRouter = require('./routes/orders.cjs');
-app.use('/api/orders', ordersRouter);
-
-// Rotas de Sincroniza√ß√£o de Pedidos Unificados
-const { router: ordersSyncRouter } = require('./routes/orders-sync.cjs');
-app.use('/api', ordersSyncRouter);
-
-// Rotas de Business Intelligence
-const businessIntelligenceRouter = require('./routes/businessIntelligence.cjs');
-app.use('/api/bi', businessIntelligenceRouter);
-
-// Rotas de Backup e Seguran√ßa
-const backupSecurityRouter = require('./routes/backupSecurity.cjs');
-app.use('/api/backup-security', backupSecurityRouter);
-
-// Rotas de APIs Externas
-const externalApisRouter = require('./routes/externalApis.cjs');
-app.use('/api/external', externalApisRouter);
-
-// Rotas de Machine Learning
-const machineLearningRouter = require('./routes/machineLearning.cjs');
-app.use('/api/ml', machineLearningRouter);
-
-// Inicializar agendador de recupera√ß√£o de carrinho
-// DESABILITADO: scheduler antigo com dados mockados
-// const cartRecoveryScheduler = require('./services/cartRecoveryScheduler.cjs');
-// cartRecoveryScheduler.start();
-
-
-// ==================== ADMIN: CUSTOMERS API ====================
-
-// GET /api/admin/customers - Lista clientes com filtros, pagina√ß√£o e busca
-app.get('/api/admin/customers', authenticateAdmin, async (req, res) => {
+// Associar pedido com cliente
+app.patch('/api/orders/:id/associate-customer', async (req, res) => {
   try {
-    const {
-      page = 1,
-      limit = 50,
-      search,
-      status,
-      customer_type,
-      cidade,
-      estado,
-      sort = 'created_at',
-      order = 'DESC',
-      date_from,
-      date_to,
-      min_orders,
-      min_spent,
-    } = req.query;
-
-    // Garantir que page e limit s√£o n√∫meros v√°lidos
-    const pageNum = isNaN(Number(page)) || Number(page) < 1 ? 1 : Math.floor(Number(page));
-    const limitNum = isNaN(Number(limit)) || Number(limit) < 1 ? 50 : Math.floor(Number(limit));
-    const offsetNum = (pageNum - 1) * limitNum;
-
-    let whereClause = '';
-    let queryParams = [];
-
-    // Filtro por status
-    if (status && status !== 'all') {
-      whereClause += ' WHERE c.status = ?';
-      queryParams.push(status);
-    }
-
-    // Filtro por tipo de cliente
-    if (customer_type && customer_type !== 'all') {
-      const condition = whereClause ? ' AND' : ' WHERE';
-      whereClause += `${condition} (
-        CASE 
-          WHEN COALESCE(customer_stats.total_orders, 0) = 0 THEN 'new'
-          WHEN COALESCE(customer_stats.total_orders, 0) BETWEEN 1 AND 5 THEN 'regular'
-          WHEN COALESCE(customer_stats.total_orders, 0) BETWEEN 6 AND 20 THEN 'vip'
-          ELSE 'premium'
-        END
-      ) = ?`;
-      queryParams.push(customer_type);
-    }
-
-    // Filtro por cidade
-    if (cidade && cidade !== 'all') {
-      const condition = whereClause ? ' AND' : ' WHERE';
-      whereClause += `${condition} c.endereco_cidade = ?`;
-      queryParams.push(cidade);
-    }
+    const { id } = req.params;
+    const { customer_id } = req.body;
 
-    // Filtro por estado
-    if (estado && estado !== 'all') {
-      const condition = whereClause ? ' AND' : ' WHERE';
-      whereClause += `${condition} c.endereco_estado = ?`;
-      queryParams.push(estado);
+    if (!customer_id) {
+      return res.status(400).json({ error: 'ID do cliente √© obrigat√≥rio' });
     }
 
-    // Filtro por data (de)
-    if (date_from) {
-      const condition = whereClause ? ' AND' : ' WHERE';
-      whereClause += `${condition} DATE(c.created_at) >= ?`;
-      queryParams.push(date_from);
+    // Verificar se o pedido existe
+    const [orders] = await pool.execute('SELECT * FROM orders WHERE id = ?', [id]);
+    if (orders.length === 0) {
+      return res.status(404).json({ error: 'Pedido n√£o encontrado' });
     }
 
-    // Filtro por data (at√©)
-    if (date_to) {
-      const condition = whereClause ? ' AND' : ' WHERE';
-      whereClause += `${condition} DATE(c.created_at) <= ?`;
-      queryParams.push(date_to);
+    // Verificar se o cliente existe
+    const [customers] = await pool.execute('SELECT * FROM customers WHERE id = ?', [customer_id]);
+    if (customers.length === 0) {
+      return res.status(404).json({ error: 'Cliente n√£o encontrado' });
     }
 
-    // Filtro por m√≠nimo de pedidos
-    if (min_orders) {
-      const condition = whereClause ? ' AND' : ' WHERE';
-      whereClause += `${condition} COALESCE(customer_stats.total_orders, 0) >= ?`;
-      queryParams.push(parseInt(min_orders));
-    }
+    // Atualizar pedido
+    await pool.execute(
+      'UPDATE orders SET customer_id = ?, updated_at = NOW() WHERE id = ?',
+      [customer_id, id]
+    );
 
-    // Filtro por m√≠nimo de gasto
-    if (min_spent) {
-      const condition = whereClause ? ' AND' : ' WHERE';
-      whereClause += `${condition} COALESCE(customer_stats.total_spent, 0) >= ?`;
-      queryParams.push(parseFloat(min_spent));
-    }
+    // Atualizar estat√≠sticas do cliente
+    const customer = customers[0];
+    const [orderStats] = await pool.execute(`
+      SELECT 
+        COUNT(*) as total_pedidos,
+        SUM(total) as total_gasto,
+        MAX(created_at) as ultimo_pedido
+      FROM orders 
+      WHERE customer_id = ?
+    `, [customer_id]);
 
-    // Filtro por busca (nome, email, telefone)
-    if (search) {
-      const condition = whereClause ? ' AND' : ' WHERE';
-      whereClause += `${condition} (
-        c.nome LIKE ? OR 
-        c.email LIKE ? OR 
-        c.telefone LIKE ?
-      )`;
-      const searchTerm = `%${search}%`;
-      queryParams.push(searchTerm, searchTerm, searchTerm);
-    }
+    const stats = orderStats[0];
+    await pool.execute(`
+      UPDATE customers 
+      SET 
+        total_pedidos = ?,
+        total_gasto = ?,
+        ultimo_pedido = ?,
+        updated_at = NOW()
+      WHERE id = ?
+    `, [stats.total_pedidos, stats.total_gasto, stats.ultimo_pedido, customer_id]);
 
-    const [customers] = await pool.execute(`
-      SELECT 
-        c.*,
-        COALESCE(customer_stats.total_orders, 0) as total_pedidos,
-        COALESCE(customer_stats.total_spent, 0) as total_gasto,
-        COALESCE(customer_stats.last_order, c.created_at) as ultimo_pedido,
-        COALESCE(customer_stats.average_ticket, 0) as average_ticket,
-        CASE 
-          WHEN COALESCE(customer_stats.total_orders, 0) = 0 THEN 'new'
-          WHEN COALESCE(customer_stats.total_orders, 0) BETWEEN 1 AND 5 THEN 'regular'
-          WHEN COALESCE(customer_stats.total_orders, 0) BETWEEN 6 AND 20 THEN 'vip'
-          ELSE 'premium'
-        END as customer_type
-      FROM customers c
-      LEFT JOIN (
-        SELECT 
-          CAST(user_id AS CHAR) as customer_id,
-          COUNT(*) as total_orders,
-          SUM(total) as total_spent,
-          MAX(created_at) as last_order,
-          AVG(total) as average_ticket
-        FROM orders 
-        WHERE user_id IS NOT NULL
-        GROUP BY user_id
-      ) customer_stats ON c.id COLLATE utf8mb4_unicode_ci = customer_stats.customer_id COLLATE utf8mb4_unicode_ci
-      ${whereClause}
-      ORDER BY c.${sort} ${order}
-      LIMIT ${limitNum} OFFSET ${offsetNum}
-    `, queryParams);
-
-    // Contar total
-    const [countResult] = await pool.execute(`
-      SELECT COUNT(*) as total
-      FROM customers c
-      LEFT JOIN (
-        SELECT 
-          CAST(user_id AS CHAR) as customer_id,
-          COUNT(*) as total_orders,
-          SUM(total) as total_spent
-        FROM orders 
-        WHERE user_id IS NOT NULL
-        GROUP BY user_id
-      ) customer_stats ON c.id COLLATE utf8mb4_unicode_ci = customer_stats.customer_id COLLATE utf8mb4_unicode_ci
-      ${whereClause}
-    `, queryParams);
-
-    const total = countResult[0].total;
+    // Inserir no hist√≥rico do cliente
+    await pool.execute(`
+      INSERT INTO customer_order_history (id, customer_id, order_id, total, status, data_pedido)
+      VALUES (?, ?, ?, ?, ?, ?)
+      ON DUPLICATE KEY UPDATE 
+        total = VALUES(total),
+        status = VALUES(status),
+        data_pedido = VALUES(data_pedido)
+    `, [
+      require('crypto').randomUUID(),
+      customer_id,
+      id,
+      orders[0].total,
+      orders[0].status,
+      orders[0].created_at
+    ]);
 
-    res.json({
-      customers,
-      pagination: {
-        page: pageNum,
-        limit: limitNum,
-        total,
-        pages: Math.ceil(total / limitNum),
-      },
-    });
+    res.json({ success: true, message: 'Cliente associado com sucesso' });
   } catch (error) {
-    logger.logError(error, req);
-    res.status(500).json({ error: 'Erro ao buscar clientes', message: error?.message });
+    console.error('Erro ao associar cliente:', error);
+    res.status(500).json({ error: 'Erro interno do servidor' });
   }
 });
 
-// GET /api/admin/customers/stats - Estat√≠sticas de clientes
-app.get('/api/admin/customers/stats', authenticateAdmin, async (req, res) => {
+// API Simplificada para Pedidos Evolved (sem JOIN)
+app.get('/api/admin/orders-evolved-simple', async (req, res) => {
   try {
-    const [stats] = await pool.execute(`
-      SELECT 
-        COUNT(*) as total,
-        0 as ativos,
-        0 as inativos,
-        0 as bloqueados,
-        SUM(CASE WHEN DATE(created_at) = CURDATE() THEN 1 ELSE 0 END) as clientes_hoje,
-        SUM(CASE WHEN created_at >= DATE_SUB(NOW(), INTERVAL 30 DAY) THEN 1 ELSE 0 END) as novos
-      FROM customers
-    `);
-
-    const [revenueStats] = await pool.execute(`
+    const [orders] = await pool.execute(`
       SELECT 
-        COALESCE(SUM(total), 0) as receita_total,
-        COALESCE(AVG(total), 0) as ticket_medio
-      FROM orders
-      WHERE user_id IS NOT NULL
-    `);
-
-    const [lastMonthStats] = await pool.execute(`
-      SELECT COUNT(*) as total_mes_passado
-      FROM customers
-      WHERE created_at >= DATE_SUB(NOW(), INTERVAL 60 DAY)
-      AND created_at < DATE_SUB(NOW(), INTERVAL 30 DAY)
-    `);
-
-    const [vipStats] = await pool.execute(`
-      SELECT COUNT(*) as vip
-      FROM customers c
-      INNER JOIN (
-        SELECT CAST(user_id AS CHAR) as customer_id, COUNT(*) as total_orders
-        FROM orders
-        WHERE user_id IS NOT NULL
-        GROUP BY user_id
-        HAVING total_orders >= 6
-      ) customer_stats ON c.id COLLATE utf8mb4_unicode_ci = customer_stats.customer_id COLLATE utf8mb4_unicode_ci
+        o.*,
+        u.nome as customer_nome,
+        u.email as customer_email,
+        u.telefone as customer_telefone,
+        CASE 
+          WHEN o.user_id IS NOT NULL THEN 'Cliente Registrado'
+          ELSE 'Cliente An√¥nimo'
+        END as customer_type
+      FROM orders o
+      LEFT JOIN customers u ON o.user_id = u.id
+      ORDER BY o.created_at DESC
     `);
 
-    const total = stats[0].total || 0;
-    const novos = stats[0].novos || 0;
-    const totalMesPassado = lastMonthStats[0].total_mes_passado || 0;
-    const crescimentoMensal = totalMesPassado > 0
-      ? ((novos - totalMesPassado) / totalMesPassado) * 100
-      : 0;
-
-    res.json({
-      total,
-      ativos: stats[0].ativos || 0,
-      inativos: stats[0].inativos || 0,
-      bloqueados: stats[0].bloqueados || 0,
-      novos,
-      vip: vipStats[0].vip || 0,
-      receita_total: revenueStats[0].receita_total || 0,
-      ticket_medio: revenueStats[0].ticket_medio || 0,
-      crescimento_mensal: crescimentoMensal,
-      clientes_hoje: stats[0].clientes_hoje || 0,
-    });
-  } catch (error) {
-    logger.logError(error, req);
-    res.status(500).json({ error: 'Erro ao buscar estat√≠sticas', message: error?.message });
+    const ordersWithCustomer = orders.map(order => ({
+      ...order,
+      customer: order.user_id ? {
+        id: order.user_id,
+        nome: order.customer_nome || 'Cliente',
+        email: order.customer_email || 'Email n√£o informado',
+        telefone: order.customer_telefone || 'Telefone n√£o informado',
+        total_pedidos: 1,
+        total_gasto: order.total || 0,
+        ultimo_pedido: order.created_at,
+      } : null
+    }));
+
+    res.json(ordersWithCustomer);
+  } catch (error) {
+    console.error('Erro ao buscar pedidos evolu√≠do:', error);
+    res.status(500).json({ error: 'Erro interno do servidor' });
   }
 });
 
-// PATCH /api/admin/customers/:id - Atualizar cliente
-app.patch('/api/admin/customers/:id', authenticateAdmin, async (req, res) => {
+// Estat√≠sticas simplificadas para Pedidos Evolved
+app.get('/api/admin/orders-stats-evolved-simple', async (req, res) => {
   try {
-    const { id } = req.params;
-    const updateData = req.body;
+    const [stats] = await pool.execute(`
+      SELECT 
+        COUNT(*) as total,
+        SUM(CASE WHEN status = 'pending' THEN 1 ELSE 0 END) as pending,
+        SUM(CASE WHEN status = 'processing' THEN 1 ELSE 0 END) as processing,
+        SUM(CASE WHEN status = 'shipped' THEN 1 ELSE 0 END) as shipped,
+        SUM(CASE WHEN status = 'delivered' THEN 1 ELSE 0 END) as delivered,
+        SUM(CASE WHEN status = 'cancelled' THEN 1 ELSE 0 END) as cancelled,
+        SUM(total) as totalRevenue,
+        AVG(total) as averageTicket,
+        SUM(CASE WHEN DATE(created_at) = CURDATE() THEN 1 ELSE 0 END) as todayOrders,
+        SUM(CASE WHEN DATE(created_at) = CURDATE() THEN total ELSE 0 END) as todayRevenue,
+        COUNT(DISTINCT user_id) as totalCustomers,
+        SUM(CASE WHEN DATE(created_at) = CURDATE() AND user_id IS NOT NULL THEN 1 ELSE 0 END) as newCustomers
+      FROM orders
+    `);
 
-    const allowedFields = [
-      'nome', 'email', 'telefone', 'cpf', 'data_nascimento',
-      'endereco_rua', 'endereco_numero', 'endereco_complemento',
-      'endereco_bairro', 'endereco_cidade', 'endereco_estado', 'endereco_cep',
-      'status', 'tags', 'notas'
-    ];
+    res.json(stats[0] || {});
+  } catch (error) {
+    console.error('Erro ao buscar estat√≠sticas evolu√≠do:', error);
+    res.status(500).json({ error: 'Erro interno do servidor' });
+  }
+});
+
+// Estat√≠sticas de pedidos (Admin)
+app.get('/api/orders/stats', async (req, res) => {
+  try {
+    const [stats] = await pool.execute(`
+      SELECT 
+        COUNT(*) as total,
+        SUM(CASE WHEN status = 'pending' THEN 1 ELSE 0 END) as pending,
+        SUM(CASE WHEN status = 'processing' THEN 1 ELSE 0 END) as processing,
+        SUM(CASE WHEN status = 'shipped' THEN 1 ELSE 0 END) as shipped,
+        SUM(CASE WHEN status = 'delivered' THEN 1 ELSE 0 END) as delivered,
+        SUM(CASE WHEN status = 'cancelled' THEN 1 ELSE 0 END) as cancelled,
+        COALESCE(SUM(CASE WHEN status != 'cancelled' THEN total ELSE 0 END), 0) as total_revenue,
+        COALESCE(AVG(CASE WHEN status != 'cancelled' THEN total ELSE NULL END), 0) as average_ticket,
+        SUM(CASE WHEN DATE(created_at) = CURDATE() THEN 1 ELSE 0 END) as today_orders,
+        COALESCE(SUM(CASE WHEN DATE(created_at) = CURDATE() AND status != 'cancelled' THEN total ELSE 0 END), 0) as today_revenue
+      FROM orders
+    `);
+
+    res.json({
+      total: Number(stats[0].total) || 0,
+      pending: Number(stats[0].pending) || 0,
+      processing: Number(stats[0].processing) || 0,
+      shipped: Number(stats[0].shipped) || 0,
+      delivered: Number(stats[0].delivered) || 0,
+      cancelled: Number(stats[0].cancelled) || 0,
+      totalRevenue: Number(stats[0].total_revenue) || 0,
+      averageTicket: Number(stats[0].average_ticket) || 0,
+      todayOrders: Number(stats[0].today_orders) || 0,
+      todayRevenue: Number(stats[0].today_revenue) || 0,
+    });
+  } catch (error) {
+    logger.logError(error, req);
+    res.status(500).json({ error: 'Erro ao buscar estat√≠sticas' });
+  }
+});
 
-    const fieldsToUpdate = Object.keys(updateData).filter(key => allowedFields.includes(key));
+// Atualizar status do pedido (Admin)
+app.patch('/api/orders/:id/status', async (req, res) => {
+  try {
+    const { id } = req.params;
+    const { status } = req.body;
 
-    if (fieldsToUpdate.length === 0) {
-      return res.status(400).json({ error: 'Nenhum campo v√°lido para atualizar' });
+    if (!status) {
+      return res.status(400).json({ error: 'Status √© obrigat√≥rio' });
     }
 
-    const setClause = fieldsToUpdate.map(field => `${field} = ?`).join(', ');
-    const values = fieldsToUpdate.map(field => {
-      if (field === 'tags' && Array.isArray(updateData[field])) {
-        return JSON.stringify(updateData[field]);
-      }
-      return updateData[field];
-    });
-    values.push(id);
+    const validStatuses = ['pending', 'confirmed', 'processing', 'shipped', 'delivered', 'cancelled'];
+    if (!validStatuses.includes(status)) {
+      return res.status(400).json({ error: 'Status inv√°lido' });
+    }
 
     await pool.execute(
-      `UPDATE customers SET ${setClause}, updated_at = NOW() WHERE id = ?`,
-      values
+      'UPDATE orders SET status = ?, updated_at = NOW() WHERE id = ?',
+      [status, id]
     );
 
-    res.json({ success: true, message: 'Cliente atualizado com sucesso' });
+    res.json({ success: true, message: 'Status atualizado com sucesso' });
   } catch (error) {
     logger.logError(error, req);
-    res.status(500).json({ error: 'Erro ao atualizar cliente', message: error?.message });
+    res.status(500).json({ error: 'Erro ao atualizar status' });
   }
 });
 
-// DELETE /api/admin/customers/:id - Excluir cliente
-app.delete('/api/admin/customers/:id', authenticateAdmin, async (req, res) => {
+// Adicionar c√≥digo de rastreamento (Admin)
+app.post('/api/orders/:id/tracking', async (req, res) => {
   try {
     const { id } = req.params;
+    const { tracking_code } = req.body;
+
+    if (!tracking_code) {
+      return res.status(400).json({ error: 'C√≥digo de rastreamento √© obrigat√≥rio' });
+    }
+
+    // Verificar se a coluna tracking_code existe
+    try {
+      await pool.execute(
+        'UPDATE orders SET tracking_code = ?, status = "shipped", updated_at = NOW() WHERE id = ?',
+        [tracking_code, id]
+      );
+    } catch (colError) {
+      // Se a coluna n√£o existir, apenas atualizar o status
+      console.log('‚ö†Ô∏è Coluna tracking_code n√£o existe, atualizando apenas status');
+      await pool.execute(
+        'UPDATE orders SET status = "shipped", updated_at = NOW() WHERE id = ?',
+        [id]
+      );
+    }
 
-    // Verificar se o cliente tem pedidos (usar user_id que √© o nome correto da coluna)
+    // Buscar dados do pedido
     const [orders] = await pool.execute(
-      'SELECT COUNT(*) as count FROM `rare_toy_companion`.`orders` WHERE user_id = ?',
+      'SELECT customer_email, customer_name FROM orders WHERE id = ?',
       [id]
     );
 
-    if (orders[0].count > 0) {
-      return res.status(400).json({
-        error: 'N√£o √© poss√≠vel excluir cliente com pedidos associados',
-        message: `Este cliente possui ${orders[0].count} pedido(s). Considere desativar o cliente em vez de exclu√≠-lo.`,
-      });
+    if (orders.length > 0 && orders[0].customer_email) {
+      console.log(`üìß Enviar c√≥digo de rastreamento ${tracking_code} para ${orders[0].customer_email}`);
+      // Aqui voc√™ pode adicionar l√≥gica para enviar email
     }
 
-    await pool.execute('DELETE FROM customers WHERE id = ?', [id]);
-
-    res.json({ success: true, message: 'Cliente exclu√≠do com sucesso' });
+    res.json({ success: true, message: 'C√≥digo de rastreamento adicionado' });
   } catch (error) {
     logger.logError(error, req);
-    res.status(500).json({ error: 'Erro ao excluir cliente', message: error?.message });
+    res.status(500).json({ error: 'Erro ao adicionar c√≥digo de rastreamento' });
   }
 });
 
-// POST /api/admin/customers/bulk-action - A√ß√µes em lote para clientes
-app.post('/api/admin/customers/bulk-action', authenticateAdmin, async (req, res) => {
+// Associar pedido com usu√°rio (Admin)
+app.patch('/api/orders/:id/associate-user', async (req, res) => {
   try {
-    console.log(`[Bulk Action Customers] Recebida requisi√ß√£o:`, JSON.stringify(req.body, null, 2));
-
-    let { customerIds, action, value } = req.body;
-
-    // Detectar e corrigir invers√£o de par√¢metros
-    if (typeof customerIds === 'string' && Array.isArray(action)) {
-      console.warn(`[Bulk Action Customers] Par√¢metros invertidos detectados! Corrigindo...`);
-      const temp = customerIds;
-      customerIds = action;
-      action = temp;
-      console.log(`[Bulk Action Customers] Ap√≥s corre√ß√£o:`, { customerIds, action, value });
-    }
+    const { id } = req.params;
+    const { user_id, customer_email } = req.body;
 
-    if (!customerIds || !Array.isArray(customerIds) || customerIds.length === 0) {
-      return res.status(400).json({ error: 'IDs dos clientes s√£o obrigat√≥rios' });
+    if (!user_id && !customer_email) {
+      return res.status(400).json({ error: 'user_id ou customer_email √© obrigat√≥rio' });
     }
 
-    if (!action || typeof action !== 'string') {
-      return res.status(400).json({ error: 'A√ß√£o √© obrigat√≥ria e deve ser uma string' });
-    }
+    let userIdToUse = user_id;
 
-    const validCustomerIds = customerIds.filter(id => id !== null && id !== undefined && id !== '');
+    // Se n√£o tem user_id mas tem email, tentar encontrar o usu√°rio
+    if (!userIdToUse && customer_email) {
+      const [users] = await pool.execute(
+        'SELECT id FROM users WHERE email = ?',
+        [customer_email]
+      );
 
-    if (validCustomerIds.length === 0) {
-      return res.status(400).json({ error: 'Nenhum ID de cliente v√°lido encontrado' });
+      if (users.length > 0) {
+        userIdToUse = users[0].id;
+      }
     }
 
-    let affectedRows = 0;
-    const placeholders = validCustomerIds.map(() => '?').join(',');
-
-    switch (action) {
-      case 'update_status':
-        if (!value) {
-          return res.status(400).json({ error: 'Novo status √© obrigat√≥rio para atualiza√ß√£o de status' });
-        }
-        const [result] = await pool.execute(
-          `UPDATE customers SET status = ?, updated_at = NOW() WHERE id IN (${placeholders})`,
-          [value, ...validCustomerIds]
-        );
-        affectedRows = result.affectedRows;
-        break;
-
-      case 'add_tags':
-        if (!value) {
-          return res.status(400).json({ error: 'Tags s√£o obrigat√≥rias' });
-        }
-        const tagsToAdd = value.split(',').map(t => t.trim());
-        // Buscar clientes e adicionar tags
-        const [customers] = await pool.execute(
-          `SELECT id, tags FROM customers WHERE id IN (${placeholders})`,
-          validCustomerIds
-        );
-        for (const customer of customers) {
-          const existingTags = customer.tags ? JSON.parse(customer.tags) : [];
-          const newTags = [...new Set([...existingTags, ...tagsToAdd])];
-          await pool.execute(
-            'UPDATE customers SET tags = ?, updated_at = NOW() WHERE id = ?',
-            [JSON.stringify(newTags), customer.id]
-          );
-        }
-        affectedRows = customers.length;
-        break;
-
-      case 'delete':
-        // Verificar se algum cliente tem pedidos (usar user_id que √© o nome correto da coluna)
-        const [ordersCheck] = await pool.execute(
-          `SELECT user_id, COUNT(*) as count FROM \`rare_toy_companion\`.\`orders\` WHERE user_id IN (${placeholders}) GROUP BY user_id`,
-          validCustomerIds
-        );
-
-        if (ordersCheck.length > 0) {
-          return res.status(400).json({
-            error: 'Alguns clientes possuem pedidos associados',
-            message: `N√£o √© poss√≠vel excluir clientes com pedidos. Clientes afetados: ${ordersCheck.map(o => o.user_id).join(', ')}`,
-          });
-        }
+    if (!userIdToUse) {
+      return res.status(404).json({ error: 'Usu√°rio n√£o encontrado' });
+    }
 
-        const [deleteResult] = await pool.execute(
-          `DELETE FROM customers WHERE id IN (${placeholders})`,
-          validCustomerIds
-        );
-        affectedRows = deleteResult.affectedRows;
-        break;
+    // Atualizar o pedido com o user_id
+    await pool.execute(
+      'UPDATE orders SET user_id = ?, updated_at = NOW() WHERE id = ?',
+      [userIdToUse, id]
+    );
 
-      default:
-        return res.status(400).json({ error: `A√ß√£o inv√°lida: ${action}. A√ß√µes suportadas: update_status, add_tags, delete` });
-    }
+    // Buscar dados do usu√°rio para retornar
+    const [users] = await pool.execute(
+      'SELECT nome, email, telefone FROM users WHERE id = ?',
+      [userIdToUse]
+    );
 
     res.json({
       success: true,
-      message: `${affectedRows} cliente(s) processado(s) com sucesso`,
-      affectedRows,
+      message: 'Pedido associado ao cliente com sucesso',
+      customer: users[0] || null
     });
   } catch (error) {
     logger.logError(error, req);
-    res.status(500).json({ error: 'Erro interno do servidor' });
+    res.status(500).json({ error: 'Erro ao associar pedido com cliente' });
   }
 });
 
-// GET /api/admin/customers/:id/orders - Buscar pedidos do cliente
-app.get('/api/admin/customers/:id/orders', authenticateAdmin, async (req, res) => {
+// Buscar usu√°rios para associa√ß√£o (Admin)
+app.get('/api/admin/users/search', async (req, res) => {
   try {
-    const { id } = req.params;
+    const { q } = req.query;
 
-    const [orders] = await pool.execute(`
-      SELECT 
-        o.*,
-        (SELECT COUNT(*) FROM order_items oi WHERE oi.order_id = o.id) AS items_count
-      FROM orders o
-      WHERE o.user_id = ?
-      ORDER BY o.created_at DESC
-      LIMIT 50
-    `, [id]);
+    if (!q || q.length < 2) {
+      return res.json([]);
+    }
+
+    const [users] = await pool.execute(`
+      SELECT id, nome, email, telefone 
+      FROM users 
+      WHERE nome LIKE ? OR email LIKE ?
+      LIMIT 10
+    `, [`%${q}%`, `%${q}%`]);
 
-    res.json(orders);
+    res.json(users);
   } catch (error) {
     logger.logError(error, req);
-    res.status(500).json({ error: 'Erro ao buscar pedidos do cliente', message: error?.message });
+    res.status(500).json({ error: 'Erro ao buscar usu√°rios' });
   }
 });
 
-// GET /api/admin/customers/export - Exportar clientes
-app.get('/api/admin/customers/export', authenticateAdmin, async (req, res) => {
+// A√ß√µes em massa (Admin)
+app.post('/api/orders/bulk-action', async (req, res) => {
   try {
-    const { format = 'csv', ...filters } = req.query;
+    const { orderIds, action } = req.body;
 
-    // Aplicar mesmos filtros do endpoint de listagem
-    let whereClause = '';
-    let queryParams = [];
+    if (!Array.isArray(orderIds) || orderIds.length === 0) {
+      return res.status(400).json({ error: 'IDs de pedidos s√£o obrigat√≥rios' });
+    }
 
-    if (filters.status && filters.status !== 'all') {
-      whereClause += ' WHERE c.status = ?';
-      queryParams.push(filters.status);
+    if (!action) {
+      return res.status(400).json({ error: 'A√ß√£o √© obrigat√≥ria' });
     }
 
-    if (filters.search) {
-      const condition = whereClause ? ' AND' : ' WHERE';
-      whereClause += `${condition} (
-        c.nome LIKE ? OR 
-        c.email LIKE ? OR 
-        c.telefone LIKE ?
-      )`;
-      const searchTerm = `%${filters.search}%`;
-      queryParams.push(searchTerm, searchTerm, searchTerm);
+    const validActions = ['processing', 'shipped', 'delivered', 'cancelled'];
+    if (!validActions.includes(action)) {
+      return res.status(400).json({ error: 'A√ß√£o inv√°lida' });
     }
 
-    const [customers] = await pool.execute(`
-      SELECT 
-        c.*,
-        COALESCE(customer_stats.total_orders, 0) as total_pedidos,
-        COALESCE(customer_stats.total_spent, 0) as total_gasto
-      FROM customers c
-      LEFT JOIN (
-        SELECT 
-          customer_id,
-          COUNT(*) as total_orders,
-          SUM(total) as total_spent
-        FROM orders 
-        WHERE customer_id IS NOT NULL
-        GROUP BY customer_id
-      ) customer_stats ON c.id = customer_stats.customer_id
-      ${whereClause}
-      ORDER BY c.created_at DESC
-    `, queryParams);
-
-    if (format === 'csv') {
-      const headers = [
-        'ID', 'Nome', 'Email', 'Telefone', 'CPF', 'Cidade', 'Estado', 'CEP',
-        'Status', 'Total Pedidos', 'Total Gasto', 'Data Cadastro'
-      ];
-      const rows = customers.map(c => [
-        c.id,
-        c.nome || '',
-        c.email || '',
-        c.telefone || '',
-        c.cpf || '',
-        c.endereco_cidade || '',
-        c.endereco_estado || '',
-        c.endereco_cep || '',
-        c.status || '',
-        c.total_pedidos || 0,
-        c.total_gasto || 0,
-        c.created_at || '',
-      ]);
-      const csv = [headers, ...rows]
-        .map(r => r.map(val => `"${String(val).replace(/"/g, '""')}"`).join(','))
-        .join('\n');
+    // Atualizar todos os pedidos
+    const placeholders = orderIds.map(() => '?').join(',');
+    await pool.execute(
+      `UPDATE orders SET status = ?, updated_at = NOW() WHERE id IN (${placeholders})`,
+      [action, ...orderIds]
+    );
 
-      res.setHeader('Content-Type', 'text/csv;charset=utf-8');
-      res.setHeader('Content-Disposition', `attachment; filename=clientes_export_${new Date().toISOString().slice(0, 10)}.csv`);
-      res.send('\ufeff' + csv); // BOM para Excel
-    } else {
-      res.json(customers);
-    }
+    res.json({
+      success: true,
+      message: `${orderIds.length} pedido(s) atualizado(s)`,
+      updated: orderIds.length
+    });
   } catch (error) {
     logger.logError(error, req);
-    res.status(500).json({ error: 'Erro ao exportar clientes', message: error?.message });
+    res.status(500).json({ error: 'Erro ao executar a√ß√£o em massa' });
   }
 });
 
-// GET /api/admin/orders - Lista pedidos com filtros, pagina√ß√£o e busca
-app.get('/api/admin/orders', authenticateAdmin, async (req, res) => {
+// Criar tabelas para p√°gina Sobre
+(async () => {
   try {
-    const {
-      page = 1,
-      limit = 50,
-      status,
-      search,
-      sort = 'created_at',
-      order = 'DESC',
-      payment_method,
-      payment_status,
-      date_from,
-      date_to
-    } = req.query;
-
-    // Garantir que page e limit s√£o n√∫meros v√°lidos
-    const pageNum = isNaN(Number(page)) || Number(page) < 1 ? 1 : Math.floor(Number(page));
-    const limitNum = isNaN(Number(limit)) || Number(limit) < 1 ? 50 : Math.floor(Number(limit));
-    const offsetNum = (pageNum - 1) * limitNum;
-
-    // Construir query base
-    let whereClause = '';
-    let queryParams = [];
-
-    // Filtro por status
-    if (status && status !== 'all') {
-      whereClause += ' WHERE o.status = ?';
-      queryParams.push(status);
-    }
-
-    // Filtro por m√©todo de pagamento
-    if (payment_method && payment_method !== 'all') {
-      const condition = whereClause ? ' AND' : ' WHERE';
-      whereClause += `${condition} o.metodo_pagamento = ?`;
-      queryParams.push(payment_method);
-    }
-
-    // Filtro por status de pagamento
-    if (payment_status && payment_status !== 'all') {
-      const condition = whereClause ? ' AND' : ' WHERE';
-      whereClause += `${condition} o.payment_status = ?`;
-      queryParams.push(payment_status);
-    }
-
-    // Filtro por data (de)
-    if (date_from) {
-      const condition = whereClause ? ' AND' : ' WHERE';
-      whereClause += `${condition} DATE(o.created_at) >= ?`;
-      queryParams.push(date_from);
-    }
-
-    // Filtro por data (at√©)
-    if (date_to) {
-      const condition = whereClause ? ' AND' : ' WHERE';
-      whereClause += `${condition} DATE(o.created_at) <= ?`;
-      queryParams.push(date_to);
-    }
-
-    // Filtro por busca (nome, email, telefone, ID do pedido)
-    if (search) {
-      const condition = whereClause ? ' AND' : ' WHERE';
-      whereClause += `${condition} (
-        o.id LIKE ? OR 
-        o.nome LIKE ? OR 
-        o.email LIKE ? OR 
-        o.telefone LIKE ?
-      )`;
-      const searchTerm = `%${search}%`;
-      queryParams.push(searchTerm, searchTerm, searchTerm, searchTerm);
-    }
-
-    // Validar sort
-    const allowedSorts = ['created_at', 'updated_at', 'total', 'status', 'nome', 'email'];
-    const sortField = allowedSorts.includes(sort) ? sort : 'created_at';
-    const sortOrderValue = order.toUpperCase() === 'ASC' ? 'ASC' : 'DESC';
-
-    // Query principal - garantir que limit e offset s√£o n√∫meros inteiros v√°lidos
-    // Usar parseInt explicitamente como em outras partes do c√≥digo (linha 1331-1332)
-    const limitInt = parseInt(String(limitNum), 10) || 50;
-    const offsetInt = parseInt(String(offsetNum), 10) || 0;
-
-    // Garantir valores m√≠nimos v√°lidos
-    const limitValue = Math.max(1, limitInt);
-    const offsetValue = Math.max(0, offsetInt);
-
-    // Usar interpola√ß√£o direta para LIMIT e OFFSET (seguro pois s√£o n√∫meros validados)
-    // Algumas vers√µes do MySQL n√£o aceitam placeholders para LIMIT/OFFSET
-    const [orders] = await pool.execute(`
-      SELECT 
-        o.*,
-        (SELECT COUNT(*) FROM order_items oi WHERE oi.order_id = o.id) AS items_count
-      FROM orders o
-      ${whereClause}
-      ORDER BY o.${sortField} ${sortOrderValue}
-      LIMIT ${limitValue} OFFSET ${offsetValue}
-    `, queryParams);
-
-    // Buscar itens de cada pedido
-    const ordersWithItems = await Promise.all(
-      orders.map(async (order) => {
-        try {
-          const [items] = await pool.execute(`
-          SELECT 
-            oi.id,
-            oi.product_id,
-              COALESCE(oi.name, p.nome, 'Produto') as name,
-            oi.price,
-            oi.quantity,
-              COALESCE(oi.image_url, p.imagem_url) as image_url,
-            p.nome as product_name,
-            p.imagem_url as product_image
-          FROM order_items oi
-          LEFT JOIN produtos p ON oi.product_id = p.id COLLATE utf8mb4_unicode_ci
-          WHERE oi.order_id = ?
-          ORDER BY oi.created_at ASC
-        `, [order.id]);
-
-          return {
-            id: order.id,
-            user_id: order.user_id,
-            customer_id: order.user_id,
-            status: order.status || 'pending',
-            total: Number(order.total || 0),
-            created_at: order.created_at,
-            updated_at: order.updated_at,
-            items_count: Number(order.items_count || 0),
-            items: items || [],
-
-            // Dados do cliente
-            customer_name: order.nome || 'Cliente n√£o identificado',
-            customer_email: order.email || 'Email n√£o informado',
-            customer_phone: order.telefone || null,
-
-            // Campos de pagamento e entrega
-            shipping_address: order.endereco || null,
-            payment_method: order.metodo_pagamento || null,
-            payment_status: order.payment_status || 'pending',
-            tracking_code: order.tracking_code || null,
-            estimated_delivery: order.estimated_delivery || null,
-            notes: order.notes || null,
-          };
-        } catch (itemError) {
-          console.error(`‚ùå Erro ao buscar itens do pedido ${order.id}:`, itemError);
-          return {
-            id: order.id,
-            user_id: order.user_id,
-            customer_id: order.user_id,
-            status: order.status || 'pending',
-            total: Number(order.total || 0),
-            created_at: order.created_at,
-            updated_at: order.updated_at,
-            items_count: 0,
-            items: [],
-            customer_name: order.nome || 'Cliente n√£o identificado',
-            customer_email: order.email || 'Email n√£o informado',
-            customer_phone: order.telefone || null,
-            shipping_address: order.endereco || null,
-            payment_method: order.metodo_pagamento || null,
-            payment_status: order.payment_status || 'pending',
-            tracking_code: order.tracking_code || null,
-            estimated_delivery: order.estimated_delivery || null,
-            notes: order.notes || null,
-          };
-        }
-      })
-    );
-
-    // Contar total para pagina√ß√£o
-    const [countResult] = await pool.execute(`
-      SELECT COUNT(*) as total
-      FROM orders o
-      ${whereClause}
-    `, queryParams);
-
-    const total = countResult[0]?.total || 0;
-
-    console.log(`‚úÖ [Admin Orders] ${ordersWithItems.length} pedidos retornados (total: ${total})`);
-
-    res.json({
-      orders: ordersWithItems,
-      pagination: {
-        page: parseInt(page),
-        limit: parseInt(limit),
-        total,
-        pages: Math.ceil(total / parseInt(limit))
-      }
-    });
-  } catch (error) {
-    console.error('‚ùå Erro na rota /api/admin/orders:', error);
-    logger.logError(error, req);
-    res.status(500).json({ error: 'Erro ao buscar pedidos', message: error?.message });
-  }
-});
-
-// POST /api/admin/orders/bulk-action - A√ß√µes em lote para pedidos (Admin)
-app.post('/api/admin/orders/bulk-action', authenticateAdmin, async (req, res) => {
-  try {
-    // Log do body completo antes de desestruturar
-    console.log(`[Bulk Action] Body completo recebido:`, JSON.stringify(req.body, null, 2));
-    console.log(`[Bulk Action] Tipo do body:`, typeof req.body);
-    console.log(`[Bulk Action] Keys do body:`, Object.keys(req.body || {}));
-
-    // Tentar extrair os dados corretamente
-    let orderIds = req.body.orderIds;
-    let action = req.body.action;
-    let value = req.body.value;
-
-    // Se os dados est√£o invertidos (orderIds √© string e action √© array), corrigir
-    if (typeof orderIds === 'string' && Array.isArray(action)) {
-      console.warn(`[Bulk Action] Par√¢metros invertidos detectados! Corrigindo...`);
-      const temp = orderIds;
-      orderIds = action;
-      action = temp;
-      console.log(`[Bulk Action] Ap√≥s corre√ß√£o:`, { orderIds, action, value });
-    }
-
-    console.log(`[Bulk Action] Dados finais:`, {
-      orderIds,
-      action,
-      value,
-      orderIdsType: Array.isArray(orderIds) ? typeof orderIds[0] : 'not array',
-      orderIdsLength: Array.isArray(orderIds) ? orderIds.length : 'not array'
-    });
-
-    if (!orderIds) {
-      console.warn(`[Bulk Action] orderIds √© null/undefined`);
-      return res.status(400).json({ error: 'IDs dos pedidos s√£o obrigat√≥rios' });
-    }
-
-    if (!Array.isArray(orderIds)) {
-      console.warn(`[Bulk Action] orderIds n√£o √© um array:`, typeof orderIds, orderIds);
-      return res.status(400).json({ error: 'IDs dos pedidos devem ser um array' });
-    }
-
-    if (orderIds.length === 0) {
-      console.warn(`[Bulk Action] orderIds est√° vazio`);
-      return res.status(400).json({ error: 'Pelo menos um ID de pedido √© necess√°rio' });
-    }
-
-    // Filtrar IDs v√°lidos (n√£o null, n√£o undefined, n√£o string vazia)
-    const validOrderIds = orderIds.filter(id => id !== null && id !== undefined && id !== '');
-
-    if (validOrderIds.length === 0) {
-      console.warn(`[Bulk Action] Nenhum ID v√°lido ap√≥s filtragem:`, orderIds);
-      return res.status(400).json({ error: 'Nenhum ID de pedido v√°lido encontrado' });
-    }
-
-    if (!action || typeof action !== 'string') {
-      console.warn(`[Bulk Action] action inv√°lido:`, action);
-      return res.status(400).json({ error: 'A√ß√£o √© obrigat√≥ria e deve ser uma string' });
-    }
+    // Tabela para conte√∫do da p√°gina Sobre
+    await pool.execute(`
+      CREATE TABLE IF NOT EXISTS sobre_content (
+        id VARCHAR(191) PRIMARY KEY,
+        section VARCHAR(100) NOT NULL,
+        title VARCHAR(255),
+        subtitle VARCHAR(255),
+        description TEXT,
+        image_url VARCHAR(500),
+        order_index INT DEFAULT 0,
+        is_active BOOLEAN DEFAULT TRUE,
+        metadata JSON,
+        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
+        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
+        UNIQUE KEY unique_section (section)
+      )
+    `);
+    console.log('‚úÖ Tabela sobre_content criada/verificada');
 
-    let updateQuery = '';
-    let updateParams = [];
-    let affectedRows = 0;
+    // Tabela para valores da empresa
+    await pool.execute(`
+      CREATE TABLE IF NOT EXISTS company_values (
+        id VARCHAR(191) PRIMARY KEY,
+        title VARCHAR(255) NOT NULL,
+        description TEXT,
+        icon VARCHAR(100),
+        order_index INT DEFAULT 0,
+        is_active BOOLEAN DEFAULT TRUE,
+        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
+        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
+      )
+    `);
+    console.log('‚úÖ Tabela company_values criada/verificada');
 
-    // Usar validOrderIds em vez de orderIds
-    switch (action) {
-      case 'update_status':
-        if (!value) {
-          return res.status(400).json({ error: 'Novo status √© obrigat√≥rio para atualiza√ß√£o de status' });
-        }
-        const placeholders = validOrderIds.map(() => '?').join(',');
-        const [result] = await pool.execute(
-          `UPDATE orders SET status = ?, updated_at = NOW() WHERE id IN (${placeholders})`,
-          [value, ...validOrderIds]
-        );
-        affectedRows = result.affectedRows;
-        break;
+    // Tabela para equipe
+    await pool.execute(`
+      CREATE TABLE IF NOT EXISTS team_members (
+        id VARCHAR(191) PRIMARY KEY,
+        name VARCHAR(255) NOT NULL,
+        position VARCHAR(255),
+        description TEXT,
+        image_url VARCHAR(500),
+        order_index INT DEFAULT 0,
+        is_active BOOLEAN DEFAULT TRUE,
+        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
+        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
+      )
+    `);
+    console.log('‚úÖ Tabela team_members criada/verificada');
 
-      case 'delete':
-        // Primeiro, deletar os itens dos pedidos
-        const deleteItemsPlaceholders = validOrderIds.map(() => '?').join(',');
-        await pool.execute(
-          `DELETE FROM order_items WHERE order_id IN (${deleteItemsPlaceholders})`,
-          validOrderIds
-        );
+    // Tabela para estat√≠sticas
+    await pool.execute(`
+      CREATE TABLE IF NOT EXISTS company_stats (
+        id VARCHAR(191) PRIMARY KEY,
+        title VARCHAR(255) NOT NULL,
+        value VARCHAR(100) NOT NULL,
+        icon VARCHAR(100),
+        order_index INT DEFAULT 0,
+        is_active BOOLEAN DEFAULT TRUE,
+        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
+        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
+      )
+    `);
+    console.log('‚úÖ Tabela company_stats criada/verificada');
 
-        // Depois, deletar os pedidos
-        const deletePlaceholders = validOrderIds.map(() => '?').join(',');
-        const [deleteResult] = await pool.execute(
-          `DELETE FROM orders WHERE id IN (${deletePlaceholders})`,
-          validOrderIds
-        );
-        affectedRows = deleteResult.affectedRows;
-        break;
+    // Tabela para informa√ß√µes de contato
+    await pool.execute(`
+      CREATE TABLE IF NOT EXISTS contact_info (
+        id VARCHAR(191) PRIMARY KEY,
+        type VARCHAR(100) NOT NULL,
+        title VARCHAR(255) NOT NULL,
+        value VARCHAR(255) NOT NULL,
+        icon VARCHAR(100),
+        order_index INT DEFAULT 0,
+        is_active BOOLEAN DEFAULT TRUE,
+        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
+        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
+      )
+    `);
+    console.log('‚úÖ Tabela contact_info criada/verificada');
 
-      default:
-        console.warn(`[Bulk Action] A√ß√£o inv√°lida:`, action);
-        return res.status(400).json({ error: `A√ß√£o inv√°lida: ${action}. A√ß√µes suportadas: update_status, delete` });
+    // Inserir dados iniciais para a se√ß√£o hero se n√£o existir
+    const [existingHero] = await pool.execute('SELECT id FROM sobre_content WHERE section = ?', ['hero']);
+    if (existingHero.length === 0) {
+      const heroId = require('crypto').randomUUID();
+      await pool.execute(`
+        INSERT INTO sobre_content (id, section, title, subtitle, description, metadata, is_active)
+        VALUES (?, 'hero', 'Nossa Hist√≥ria', '', 'A MuhlStore nasceu do sonho de conectar pessoas atrav√©s de brinquedos √∫nicos e especiais. Desde 2020, nossa miss√£o √© descobrir e compartilhar tesouros de brinquedos raros e seminovos de todo o Brasil.', ?, TRUE)
+      `, [heroId, JSON.stringify({
+        badge_text: 'Nossa Hist√≥ria',
+        badge_icon: 'Sparkles',
+        show_badge: true,
+        buttons: [
+          {
+            id: '1',
+            text: 'Conhe√ßa Nossos Produtos',
+            icon: 'Gift',
+            variant: 'primary',
+            action: '/loja',
+            color: 'orange'
+          },
+          {
+            id: '2',
+            text: 'Nossa Miss√£o',
+            icon: 'Heart',
+            variant: 'outline',
+            action: '/about',
+            color: 'orange'
+          }
+        ]
+      })]);
+      console.log('‚úÖ Dados iniciais da se√ß√£o hero criados');
     }
 
-    res.json({
-      success: true,
-      message: `${affectedRows} pedido(s) processado(s) com sucesso`,
-      affectedRows
-    });
-
-  } catch (error) {
-    logger.logError(error, req);
-    res.status(500).json({ error: 'Erro interno do servidor' });
+  } catch (err) {
+    console.error('‚ùå Erro ao criar tabelas da p√°gina Sobre:', { message: err?.message, code: err?.code });
   }
-});
+})();
 
-// API de estat√≠sticas para o m√≥dulo de pedidos
-app.get('/api/admin/orders/stats', async (req, res) => {
+// ==========================
+// Endere√ßos do cliente (por cart_id)
+// ==========================
+(async () => {
   try {
-    console.log('üìä Acessando API de estat√≠sticas...');
-
-    const [stats] = await pool.execute(`
-      SELECT 
-        COUNT(*) as total,
-        SUM(CASE WHEN status = 'pending' THEN 1 ELSE 0 END) as pending,
-        SUM(CASE WHEN status = 'processing' THEN 1 ELSE 0 END) as processing,
-        SUM(CASE WHEN status = 'shipped' THEN 1 ELSE 0 END) as shipped,
-        SUM(CASE WHEN status = 'delivered' THEN 1 ELSE 0 END) as delivered,
-        SUM(CASE WHEN status = 'cancelled' THEN 1 ELSE 0 END) as cancelled,
-        COALESCE(SUM(total), 0) as totalRevenue,
-        COALESCE(AVG(total), 0) as averageTicket,
-        SUM(CASE WHEN DATE(created_at) = CURDATE() THEN 1 ELSE 0 END) as todayOrders,
-        SUM(CASE WHEN DATE(created_at) = CURDATE() THEN total ELSE 0 END) as todayRevenue
-      FROM orders
-    `);
-
-    const [customerStats] = await pool.execute(`
-      SELECT 
-        COUNT(DISTINCT user_id) as totalCustomers,
-        SUM(CASE WHEN DATE(created_at) = CURDATE() AND user_id NOT IN (
-          SELECT DISTINCT user_id FROM orders WHERE DATE(created_at) < CURDATE()
-        ) THEN 1 ELSE 0 END) as newCustomers
-      FROM orders
-      WHERE user_id IS NOT NULL
+    await pool.execute(`
+      CREATE TABLE IF NOT EXISTS addresses (
+        id VARCHAR(191) PRIMARY KEY,
+        cart_id VARCHAR(191) NOT NULL,
+        nome VARCHAR(255),
+        telefone VARCHAR(100),
+        cep VARCHAR(20),
+        endereco VARCHAR(255),
+        numero VARCHAR(50),
+        complemento VARCHAR(255),
+        bairro VARCHAR(255),
+        cidade VARCHAR(255),
+        estado VARCHAR(50),
+        shipping_default TINYINT(1) DEFAULT 0,
+        billing_default TINYINT(1) DEFAULT 0,
+        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
+        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
+        INDEX idx_cart (cart_id)
+      )
     `);
-
-    const result = {
-      ...stats[0],
-      ...customerStats[0],
-      totalRevenue: Number(stats[0].totalRevenue || 0),
-      averageTicket: Number(stats[0].averageTicket || 0),
-      todayRevenue: Number(stats[0].todayRevenue || 0),
-    };
-
-    console.log('‚úÖ Estat√≠sticas calculadas:', result);
-    res.json(result);
-  } catch (error) {
-    console.error('‚ùå Erro na rota /api/admin/orders/stats:', error);
-    res.status(500).json({ error: 'Erro ao buscar estat√≠sticas' });
+    console.log('‚úÖ Tabela addresses criada/verificada');
+  } catch (e) {
+    console.error('‚ùå Erro ao criar tabela addresses', e);
   }
-});
+})();
 
-// GET /api/admin/orders/export - Exportar pedidos
-app.get('/api/admin/orders/export', authenticateAdmin, async (req, res) => {
+const { randomUUID: uuidv4 } = require('crypto');
+
+app.get('/api/addresses', async (req, res) => {
   try {
-    const { format = 'csv', ...filters } = req.query;
+    console.log('üìç GET /api/addresses - Buscando endere√ßos do usu√°rio logado');
 
-    // Buscar pedidos com os mesmos filtros do endpoint principal
-    const queryParams = [];
-    let whereClause = '';
+    // Tentar obter o usu√°rio da sess√£o
+    let userId = null;
 
-    if (filters.status && filters.status !== 'all') {
-      whereClause += ' WHERE o.status = ?';
-      queryParams.push(filters.status);
+    // Verificar se h√° session_id no cookie
+    const sessionId = req.cookies?.session_id;
+    if (sessionId) {
+      console.log('üîç Verificando sess√£o:', sessionId);
+      try {
+        const [sessions] = await pool.execute('SELECT * FROM sessions WHERE id = ?', [sessionId]);
+        if (sessions && sessions[0]) {
+          userId = sessions[0].user_id;
+          console.log('‚úÖ Usu√°rio encontrado na sess√£o:', userId);
+        }
+      } catch (e) {
+        console.log('‚ö†Ô∏è Erro ao verificar sess√£o:', e.message);
+      }
     }
 
-    if (filters.payment_method && filters.payment_method !== 'all') {
-      const condition = whereClause ? ' AND' : ' WHERE';
-      whereClause += `${condition} o.metodo_pagamento = ?`;
-      queryParams.push(filters.payment_method);
-    }
+    // Se n√£o encontrou usu√°rio na sess√£o, tentar obter do cart_id existente
+    if (!userId) {
+      // Primeiro, tentar obter cart_id do cookie sem criar um novo
+      const existingCartId = req.cookies?.cart_id;
+      if (existingCartId) {
+        console.log('üîç Tentando encontrar usu√°rio pelo cart_id existente:', existingCartId);
+        try {
+          const [carts] = await pool.execute('SELECT * FROM carts WHERE id = ?', [existingCartId]);
+          if (carts && carts[0] && carts[0].user_id) {
+            userId = carts[0].user_id;
+            console.log('‚úÖ Usu√°rio encontrado pelo cart_id existente:', userId);
+          }
+        } catch (e) {
+          console.log('‚ö†Ô∏è Erro ao buscar usu√°rio pelo cart_id existente:', e.message);
+        }
+      }
 
-    if (filters.search) {
-      const condition = whereClause ? ' AND' : ' WHERE';
-      whereClause += `${condition} (
-        o.id LIKE ? OR 
-        o.nome LIKE ? OR 
-        o.email LIKE ? OR 
-        o.telefone LIKE ?
-      )`;
-      const searchTerm = `%${filters.search}%`;
-      queryParams.push(searchTerm, searchTerm, searchTerm, searchTerm);
+      // Se ainda n√£o encontrou, criar novo cart_id
+      if (!userId) {
+        const cartId = getOrCreateCartId(req, res);
+        console.log('üîç Tentando encontrar usu√°rio pelo novo cart_id:', cartId);
+        try {
+          const [carts] = await pool.execute('SELECT * FROM carts WHERE id = ?', [cartId]);
+          if (carts && carts[0] && carts[0].user_id) {
+            userId = carts[0].user_id;
+            console.log('‚úÖ Usu√°rio encontrado pelo novo cart_id:', userId);
+          }
+        } catch (e) {
+          console.log('‚ö†Ô∏è Erro ao buscar usu√°rio pelo novo cart_id:', e.message);
+        }
+      }
     }
 
-    const [orders] = await pool.execute(`
-      SELECT 
-        o.*,
-        (SELECT COUNT(*) FROM order_items oi WHERE oi.order_id = o.id) AS items_count
-      FROM orders o
-      ${whereClause}
-      ORDER BY o.created_at DESC
-    `, queryParams);
-
-    if (format === 'csv') {
-      // Gerar CSV
-      const headers = ['ID', 'Cliente', 'Email', 'Telefone', 'Status', 'Total', 'M√©todo Pagamento', 'Data Cria√ß√£o', 'Itens'];
-      const rows = orders.map(order => [
-        order.id,
-        order.nome || 'N/A',
-        order.email || 'N/A',
-        order.telefone || 'N/A',
-        order.status || 'pending',
-        Number(order.total || 0).toFixed(2),
-        order.metodo_pagamento || 'N/A',
-        new Date(order.created_at).toLocaleDateString('pt-BR'),
-        order.items_count || 0
-      ]);
-
-      const csvContent = [
-        headers.join(','),
-        ...rows.map(row => row.map(cell => `"${String(cell).replace(/"/g, '""')}"`).join(','))
-      ].join('\n');
-
-      res.setHeader('Content-Type', 'text/csv; charset=utf-8');
-      res.setHeader('Content-Disposition', `attachment; filename=pedidos_${new Date().toISOString().split('T')[0]}.csv`);
-      res.send('\ufeff' + csvContent); // BOM para Excel
-    } else {
-      // JSON como fallback
-      res.setHeader('Content-Type', 'application/json');
-      res.setHeader('Content-Disposition', `attachment; filename=pedidos_${new Date().toISOString().split('T')[0]}.json`);
-      res.json(orders);
-    }
-  } catch (error) {
-    console.error('‚ùå Erro ao exportar pedidos:', error);
-    res.status(500).json({ error: 'Erro ao exportar pedidos', message: error?.message });
-  }
-});
-
-// Rota para criar pedidos de teste (apenas para desenvolvimento)
-app.post('/api/admin/orders/test-data', async (req, res) => {
-  try {
-    // Verificar se j√° existem pedidos
-    const [existingOrders] = await pool.execute('SELECT COUNT(*) as count FROM orders');
-    if (existingOrders[0].count > 0) {
-      return res.json({ message: 'Pedidos j√° existem no sistema', count: existingOrders[0].count });
-    }
-
-    // Criar pedidos de teste
-    const testOrders = [
-      {
-        id: 'PED-' + Date.now() + '-001',
-        user_id: 'user-001',
-        status: 'pending',
-        total: 150.00,
-        nome: 'Jo√£o Silva',
-        email: 'joao@email.com',
-        telefone: '11999999999',
-        endereco: 'Rua das Flores, 123 - S√£o Paulo/SP',
-        metodo_pagamento: 'PIX',
-        created_at: new Date().toISOString(),
-        updated_at: new Date().toISOString()
-      },
-      {
-        id: 'PED-' + Date.now() + '-002',
-        user_id: 'user-002',
-        status: 'delivered',
-        total: 89.90,
-        nome: 'Maria Santos',
-        email: 'maria@email.com',
-        telefone: '11988888888',
-        endereco: 'Av. Paulista, 456 - S√£o Paulo/SP',
-        metodo_pagamento: 'Cart√£o de Cr√©dito',
-        created_at: new Date(Date.now() - 86400000).toISOString(), // 1 dia atr√°s
-        updated_at: new Date().toISOString()
-      }
-    ];
-
-    // Inserir pedidos
-    for (const order of testOrders) {
-      await pool.execute(`
-        INSERT INTO orders (id, user_id, status, total, nome, email, telefone, endereco, metodo_pagamento, created_at, updated_at)
-        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
-      `, [
-        order.id,
-        order.user_id,
-        order.status,
-        order.total,
-        order.nome,
-        order.email,
-        order.telefone,
-        order.endereco,
-        order.metodo_pagamento,
-        order.created_at,
-        order.updated_at
-      ]);
-
-      // Criar itens de teste para cada pedido
-      await pool.execute(`
-        INSERT INTO order_items (order_id, product_id, name, price, quantity, created_at)
-        VALUES (?, ?, ?, ?, ?, ?)
-      `, [
-        order.id,
-        'PROD-001',
-        'Boneco de A√ß√£o Super Her√≥i',
-        order.total * 0.7,
-        1,
-        order.created_at
-      ]);
-
-      await pool.execute(`
-        INSERT INTO order_items (order_id, product_id, name, price, quantity, created_at)
-        VALUES (?, ?, ?, ?, ?, ?)
-      `, [
-        order.id,
-        'PROD-002',
-        'Carrinho de Controle Remoto',
-        order.total * 0.3,
-        1,
-        order.created_at
-      ]);
-    }
-
-    res.json({
-      message: 'Pedidos de teste criados com sucesso',
-      count: testOrders.length,
-      orders: testOrders.map(o => ({ id: o.id, nome: o.nome, total: o.total, status: o.status }))
-    });
-  } catch (error) {
-    console.error('Erro ao criar pedidos de teste:', error);
-    res.status(500).json({ error: 'Erro ao criar pedidos de teste' });
-  }
-});
-
-// Lista todos os pedidos evolu√≠do (com dados dos clientes sincronizados)
-app.get('/api/admin/orders-evolved', async (req, res) => {
-  try {
-    // Primeiro, tentar com JOIN para customers (se a tabela existir)
-    let orders;
-    try {
-      [orders] = await pool.execute(`
-        SELECT 
-          o.*,
-          c.id as customer_id,
-          c.nome as customer_nome,
-          c.email as customer_email,
-          c.telefone as customer_telefone,
-          c.total_pedidos as customer_total_pedidos,
-          c.total_gasto as customer_total_gasto,
-          c.ultimo_pedido as customer_ultimo_pedido,
-          CASE 
-            WHEN c.id IS NOT NULL THEN 'Cliente Sincronizado'
-            WHEN o.user_id IS NOT NULL THEN 'Cliente Registrado'
-            ELSE 'Cliente An√¥nimo'
-          END as customer_type
-        FROM orders o
-        LEFT JOIN users u ON o.user_id COLLATE utf8mb4_unicode_ci = u.id COLLATE utf8mb4_unicode_ci
-        ORDER BY o.created_at DESC
-      `);
-    } catch (joinError) {
-      // Se der erro no JOIN, usar query simples
-      console.log('Tabela users n√£o existe ou erro no JOIN, usando query simples');
-      [orders] = await pool.execute(`
-        SELECT 
-          o.*,
-          CASE 
-            WHEN o.user_id IS NOT NULL THEN 'Cliente Registrado'
-            ELSE 'Cliente An√¥nimo'
-          END as customer_type
-        FROM orders o
-        ORDER BY o.created_at DESC
-      `);
-    }
-
-    // Transformar dados para facilitar o uso no frontend
-    const ordersWithCustomer = orders.map(order => ({
-      ...order,
-      customer: order.customer_id ? {
-        id: order.customer_id,
-        nome: order.customer_nome || 'Cliente Associado',
-        email: order.customer_email || order.email || 'Email n√£o informado',
-        telefone: order.customer_telefone || order.telefone || 'Telefone n√£o informado',
-        total_pedidos: order.customer_total_pedidos || 0,
-        total_gasto: order.customer_total_gasto || 0,
-        ultimo_pedido: order.customer_ultimo_pedido || order.created_at,
-      } : null
-    }));
-
-    res.json(ordersWithCustomer);
-  } catch (error) {
-    console.error('Erro ao buscar pedidos evolu√≠do:', error);
-    res.status(500).json({ error: 'Erro interno do servidor' });
-  }
-});
-
-// Estat√≠sticas de pedidos evolu√≠do (Admin)
-app.get('/api/admin/orders-stats-evolved', async (req, res) => {
-  try {
-    const [stats] = await pool.execute(`
-      SELECT 
-        COUNT(*) as total,
-        SUM(CASE WHEN o.status = 'pending' THEN 1 ELSE 0 END) as pending,
-        SUM(CASE WHEN o.status = 'processing' THEN 1 ELSE 0 END) as processing,
-        SUM(CASE WHEN o.status = 'shipped' THEN 1 ELSE 0 END) as shipped,
-        SUM(CASE WHEN o.status = 'delivered' THEN 1 ELSE 0 END) as delivered,
-        SUM(CASE WHEN o.status = 'cancelled' THEN 1 ELSE 0 END) as cancelled,
-        SUM(o.total) as totalRevenue,
-        AVG(o.total) as averageTicket,
-        SUM(CASE WHEN DATE(o.created_at) = CURDATE() THEN 1 ELSE 0 END) as todayOrders,
-        SUM(CASE WHEN DATE(o.created_at) = CURDATE() THEN o.total ELSE 0 END) as todayRevenue,
-        COUNT(DISTINCT o.user_id) as totalCustomers,
-        SUM(CASE WHEN DATE(o.created_at) = CURDATE() AND o.user_id IS NOT NULL THEN 1 ELSE 0 END) as newCustomers
-      FROM orders o
-    `);
-
-    res.json(stats[0] || {});
-  } catch (error) {
-    console.error('Erro ao buscar estat√≠sticas evolu√≠do:', error);
-    res.status(500).json({ error: 'Erro interno do servidor' });
-  }
-});
-
-// Buscar clientes para associa√ß√£o
-app.get('/api/admin/customers/search', async (req, res) => {
-  try {
-    const { q } = req.query;
-
-    if (!q || q.length < 2) {
-      return res.json([]);
-    }
-
-    const [customers] = await pool.execute(`
-      SELECT 
-        id,
-        nome,
-        email,
-        telefone,
-        total_pedidos,
-        total_gasto,
-        status,
-        created_at
-      FROM customers 
-      WHERE 
-        nome LIKE ? OR 
-        email LIKE ? OR 
-        telefone LIKE ?
-      ORDER BY 
-        CASE WHEN nome LIKE ? THEN 1 ELSE 2 END,
-        total_gasto DESC
-      LIMIT 10
-    `, [`%${q}%`, `%${q}%`, `%${q}%`, `${q}%`]);
-
-    res.json(customers);
-  } catch (error) {
-    console.error('Erro ao buscar clientes:', error);
-    res.status(500).json({ error: 'Erro interno do servidor' });
-  }
-});
-
-// Associar pedido com cliente
-app.patch('/api/orders/:id/associate-customer', async (req, res) => {
-  try {
-    const { id } = req.params;
-    const { customer_id } = req.body;
-
-    if (!customer_id) {
-      return res.status(400).json({ error: 'ID do cliente √© obrigat√≥rio' });
-    }
-
-    // Verificar se o pedido existe
-    const [orders] = await pool.execute('SELECT * FROM orders WHERE id = ?', [id]);
-    if (orders.length === 0) {
-      return res.status(404).json({ error: 'Pedido n√£o encontrado' });
-    }
-
-    // Verificar se o cliente existe
-    const [customers] = await pool.execute('SELECT * FROM customers WHERE id = ?', [customer_id]);
-    if (customers.length === 0) {
-      return res.status(404).json({ error: 'Cliente n√£o encontrado' });
-    }
-
-    // Atualizar pedido (usar user_id que √© o nome correto da coluna)
-    await pool.execute(
-      'UPDATE `rare_toy_companion`.`orders` SET user_id = ?, updated_at = NOW() WHERE id = ?',
-      [customer_id, id]
-    );
-
-    // Atualizar estat√≠sticas do cliente
-    const customer = customers[0];
-    const [orderStats] = await pool.execute(`
-      SELECT 
-        COUNT(*) as total_pedidos,
-        SUM(total) as total_gasto,
-        MAX(created_at) as ultimo_pedido
-      FROM orders 
-      WHERE customer_id = ?
-    `, [customer_id]);
-
-    const stats = orderStats[0];
-    await pool.execute(`
-      UPDATE customers 
-      SET 
-        total_pedidos = ?,
-        total_gasto = ?,
-        ultimo_pedido = ?,
-        updated_at = NOW()
-      WHERE id = ?
-    `, [stats.total_pedidos, stats.total_gasto, stats.ultimo_pedido, customer_id]);
-
-    // Inserir no hist√≥rico do cliente
-    await pool.execute(`
-      INSERT INTO customer_order_history (id, customer_id, order_id, total, status, data_pedido)
-      VALUES (?, ?, ?, ?, ?, ?)
-      ON DUPLICATE KEY UPDATE 
-        total = VALUES(total),
-        status = VALUES(status),
-        data_pedido = VALUES(data_pedido)
-    `, [
-      require('crypto').randomUUID(),
-      customer_id,
-      id,
-      orders[0].total,
-      orders[0].status,
-      orders[0].created_at
-    ]);
-
-    res.json({ success: true, message: 'Cliente associado com sucesso' });
-  } catch (error) {
-    console.error('Erro ao associar cliente:', error);
-    res.status(500).json({ error: 'Erro interno do servidor' });
-  }
-});
-
-// API Simplificada para Pedidos Evolved (sem JOIN)
-app.get('/api/admin/orders-evolved-simple', async (req, res) => {
-  try {
-    const [orders] = await pool.execute(`
-      SELECT 
-        o.*,
-        u.nome as customer_nome,
-        u.email as customer_email,
-        CASE 
-          WHEN o.user_id IS NOT NULL THEN 'Cliente Registrado'
-          ELSE 'Cliente An√¥nimo'
-        END as customer_type
-      FROM orders o
-      LEFT JOIN users u ON o.user_id COLLATE utf8mb4_unicode_ci = u.id COLLATE utf8mb4_unicode_ci
-      ORDER BY o.created_at DESC
-    `);
-
-    const ordersWithCustomer = orders.map(order => ({
-      ...order,
-      customer: order.user_id ? {
-        id: order.user_id,
-        nome: order.customer_nome || 'Cliente',
-        email: order.customer_email || 'Email n√£o informado',
-        telefone: order.telefone || 'Telefone n√£o informado', // Usar telefone do pedido
-        total_pedidos: 1,
-        total_gasto: order.total || 0,
-        ultimo_pedido: order.created_at,
-      } : null
-    }));
-
-    res.json(ordersWithCustomer);
-  } catch (error) {
-    console.error('Erro ao buscar pedidos evolu√≠do:', error);
-    res.status(500).json({ error: 'Erro interno do servidor' });
-  }
-});
-
-// Estat√≠sticas simplificadas para Pedidos Evolved
-app.get('/api/admin/orders-stats-evolved-simple', async (req, res) => {
-  try {
-    const [stats] = await pool.execute(`
-      SELECT 
-        COUNT(*) as total,
-        SUM(CASE WHEN status = 'pending' THEN 1 ELSE 0 END) as pending,
-        SUM(CASE WHEN status = 'processing' THEN 1 ELSE 0 END) as processing,
-        SUM(CASE WHEN status = 'shipped' THEN 1 ELSE 0 END) as shipped,
-        SUM(CASE WHEN status = 'delivered' THEN 1 ELSE 0 END) as delivered,
-        SUM(CASE WHEN status = 'cancelled' THEN 1 ELSE 0 END) as cancelled,
-        SUM(total) as totalRevenue,
-        AVG(total) as averageTicket,
-        SUM(CASE WHEN DATE(created_at) = CURDATE() THEN 1 ELSE 0 END) as todayOrders,
-        SUM(CASE WHEN DATE(created_at) = CURDATE() THEN total ELSE 0 END) as todayRevenue,
-        COUNT(DISTINCT user_id) as totalCustomers,
-        SUM(CASE WHEN DATE(created_at) = CURDATE() AND user_id IS NOT NULL THEN 1 ELSE 0 END) as newCustomers
-      FROM orders
-    `);
-
-    res.json(stats[0] || {});
-  } catch (error) {
-    console.error('Erro ao buscar estat√≠sticas evolu√≠do:', error);
-    res.status(500).json({ error: 'Erro interno do servidor' });
-  }
-});
-
-// Estat√≠sticas de pedidos (Admin)
-app.get('/api/orders/stats', async (req, res) => {
-  try {
-    const [stats] = await pool.execute(`
-      SELECT 
-        COUNT(*) as total,
-        SUM(CASE WHEN status = 'pending' THEN 1 ELSE 0 END) as pending,
-        SUM(CASE WHEN status = 'processing' THEN 1 ELSE 0 END) as processing,
-        SUM(CASE WHEN status = 'shipped' THEN 1 ELSE 0 END) as shipped,
-        SUM(CASE WHEN status = 'delivered' THEN 1 ELSE 0 END) as delivered,
-        SUM(CASE WHEN status = 'cancelled' THEN 1 ELSE 0 END) as cancelled,
-        COALESCE(SUM(CASE WHEN status != 'cancelled' THEN total ELSE 0 END), 0) as total_revenue,
-        COALESCE(AVG(CASE WHEN status != 'cancelled' THEN total ELSE NULL END), 0) as average_ticket,
-        SUM(CASE WHEN DATE(created_at) = CURDATE() THEN 1 ELSE 0 END) as today_orders,
-        COALESCE(SUM(CASE WHEN DATE(created_at) = CURDATE() AND status != 'cancelled' THEN total ELSE 0 END), 0) as today_revenue
-      FROM orders
-    `);
-
-    res.json({
-      total: Number(stats[0].total) || 0,
-      pending: Number(stats[0].pending) || 0,
-      processing: Number(stats[0].processing) || 0,
-      shipped: Number(stats[0].shipped) || 0,
-      delivered: Number(stats[0].delivered) || 0,
-      cancelled: Number(stats[0].cancelled) || 0,
-      totalRevenue: Number(stats[0].total_revenue) || 0,
-      averageTicket: Number(stats[0].average_ticket) || 0,
-      todayOrders: Number(stats[0].today_orders) || 0,
-      todayRevenue: Number(stats[0].today_revenue) || 0,
-    });
-  } catch (error) {
-    logger.logError(error, req);
-    res.status(500).json({ error: 'Erro ao buscar estat√≠sticas' });
-  }
-});
-
-// Inicializar servi√ßos de automa√ß√£o
-const OrderAutomationService = require('./services/orderAutomationService.cjs');
-const NotificationTemplateService = require('./services/notificationTemplateService.cjs');
-
-let orderAutomationService;
-let notificationTemplateService;
-
-// Inicializar servi√ßos ap√≥s pool estar pronto (delay para garantir que pool est√° inicializado)
-setTimeout(async () => {
-  try {
-    if (pool) {
-      orderAutomationService = new OrderAutomationService(pool);
-      notificationTemplateService = new NotificationTemplateService();
-      logger.info('‚úÖ Servi√ßos de automa√ß√£o inicializados');
-    } else {
-      logger.warn('‚ö†Ô∏è Pool n√£o dispon√≠vel, servi√ßos de automa√ß√£o n√£o inicializados');
-    }
-  } catch (error) {
-    logger.error('Erro ao inicializar servi√ßos de automa√ß√£o:', error);
-    // N√£o falhar o servidor se automa√ß√µes n√£o inicializarem
-  }
-}, 1000);
-
-// ==================== ENDPOINTS DE AUTOMA√á√ïES ====================
-
-// Listar todas as regras de automa√ß√£o
-app.get('/api/admin/automations/rules', async (req, res) => {
-  try {
-    if (!orderAutomationService) {
-      return res.status(503).json({ error: 'Servi√ßo de automa√ß√£o n√£o inicializado' });
-    }
-    const rules = orderAutomationService.getRules();
-    res.json({ success: true, data: rules });
-  } catch (error) {
-    logger.logError(error, req);
-    res.status(500).json({ error: 'Erro ao listar regras' });
-  }
-});
-
-// Obter regra espec√≠fica
-app.get('/api/admin/automations/rules/:id', async (req, res) => {
-  try {
-    if (!orderAutomationService) {
-      return res.status(503).json({ error: 'Servi√ßo de automa√ß√£o n√£o inicializado' });
-    }
-    const rule = orderAutomationService.getRule(req.params.id);
-    if (!rule) {
-      return res.status(404).json({ error: 'Regra n√£o encontrada' });
-    }
-    res.json({ success: true, data: rule });
-  } catch (error) {
-    logger.logError(error, req);
-    res.status(500).json({ error: 'Erro ao obter regra' });
-  }
-});
-
-// Criar nova regra
-app.post('/api/admin/automations/rules', async (req, res) => {
-  try {
-    if (!orderAutomationService) {
-      return res.status(503).json({ error: 'Servi√ßo de automa√ß√£o n√£o inicializado' });
-    }
-    const rule = orderAutomationService.addRule(req.body);
-    res.json({ success: true, data: rule });
-  } catch (error) {
-    logger.logError(error, req);
-    res.status(500).json({ error: 'Erro ao criar regra' });
-  }
-});
-
-// Atualizar regra
-app.put('/api/admin/automations/rules/:id', async (req, res) => {
-  try {
-    if (!orderAutomationService) {
-      return res.status(503).json({ error: 'Servi√ßo de automa√ß√£o n√£o inicializado' });
-    }
-    orderAutomationService.removeRule(req.params.id);
-    const rule = orderAutomationService.addRule({ ...req.body, id: req.params.id });
-    res.json({ success: true, data: rule });
-  } catch (error) {
-    logger.logError(error, req);
-    res.status(500).json({ error: 'Erro ao atualizar regra' });
-  }
-});
-
-// Ativar/desativar regra
-app.patch('/api/admin/automations/rules/:id/toggle', async (req, res) => {
-  try {
-    if (!orderAutomationService) {
-      return res.status(503).json({ error: 'Servi√ßo de automa√ß√£o n√£o inicializado' });
-    }
-    const { enabled } = req.body;
-    orderAutomationService.toggleRule(req.params.id, enabled);
-    res.json({ success: true, message: `Regra ${enabled ? 'ativada' : 'desativada'}` });
-  } catch (error) {
-    logger.logError(error, req);
-    res.status(500).json({ error: 'Erro ao alterar estado da regra' });
-  }
-});
-
-// Remover regra
-app.delete('/api/admin/automations/rules/:id', async (req, res) => {
-  try {
-    if (!orderAutomationService) {
-      return res.status(503).json({ error: 'Servi√ßo de automa√ß√£o n√£o inicializado' });
-    }
-    orderAutomationService.removeRule(req.params.id);
-    res.json({ success: true, message: 'Regra removida' });
-  } catch (error) {
-    logger.logError(error, req);
-    res.status(500).json({ error: 'Erro ao remover regra' });
-  }
-});
-
-// Listar templates de notifica√ß√£o
-app.get('/api/admin/automations/templates', async (req, res) => {
-  try {
-    if (!notificationTemplateService) {
-      return res.status(503).json({ error: 'Servi√ßo de templates n√£o inicializado' });
-    }
-    const templates = notificationTemplateService.listTemplates();
-    res.json({ success: true, data: templates });
-  } catch (error) {
-    logger.logError(error, req);
-    res.status(500).json({ error: 'Erro ao listar templates' });
-  }
-});
-
-// Renderizar template
-app.post('/api/admin/automations/templates/:name/render', async (req, res) => {
-  try {
-    if (!notificationTemplateService) {
-      return res.status(503).json({ error: 'Servi√ßo de templates n√£o inicializado' });
-    }
-    const { format = 'html', data = {} } = req.body;
-    const rendered = notificationTemplateService.renderTemplate(req.params.name, data, format);
-    if (!rendered) {
-      return res.status(404).json({ error: 'Template n√£o encontrado' });
-    }
-    res.json({ success: true, data: rendered });
-  } catch (error) {
-    logger.logError(error, req);
-    res.status(500).json({ error: 'Erro ao renderizar template' });
-  }
-});
-
-// Atualizar status do pedido (Admin) com automa√ß√µes
-app.patch('/api/orders/:id/status', async (req, res) => {
-  try {
-    const { id } = req.params;
-    const { status, notes, previous_status } = req.body;
-
-    if (!status) {
-      return res.status(400).json({ error: 'Status √© obrigat√≥rio' });
-    }
-
-    const validStatuses = ['pending', 'confirmed', 'processing', 'shipped', 'delivered', 'cancelled'];
-    if (!validStatuses.includes(status)) {
-      return res.status(400).json({ error: 'Status inv√°lido' });
-    }
-
-    // Buscar dados do pedido antes da atualiza√ß√£o
-    const [orders] = await pool.execute(`
-      SELECT o.*, u.email as customer_email, u.nome as customer_name, u.id as user_id
-      FROM orders o
-      LEFT JOIN users u ON o.user_id COLLATE utf8mb4_unicode_ci = u.id COLLATE utf8mb4_unicode_ci
-      WHERE o.id = ?
-    `, [id]);
-
-    if (orders.length === 0) {
-      return res.status(404).json({ error: 'Pedido n√£o encontrado' });
-    }
-
-    const order = orders[0];
-    const oldStatus = previous_status || order.status;
-
-    // Atualizar status do pedido
-    await pool.execute(
-      'UPDATE orders SET status = ?, updated_at = NOW() WHERE id = ?',
-      [status, id]
-    );
-
-    // Registrar hist√≥rico de status
-    try {
-      await pool.execute(`
-        INSERT INTO order_status_history (order_id, status, notes, created_at)
-        VALUES (?, ?, ?, NOW())
-      `, [id, status, notes || null]);
-    } catch (error) {
-      // Tabela pode n√£o existir, ignorar erro
-      logger.warn('Tabela order_status_history n√£o encontrada, continuando...');
-    }
-
-    // Processar automa√ß√µes
-    if (orderAutomationService) {
-      const eventData = {
-        order_id: id,
-        previous_status: oldStatus,
-        new_status: status,
-        customer_email: order.customer_email,
-        customer_name: order.customer_name,
-        customer_id: order.customer_id,
-        customer_type: order.customer_type,
-        total: parseFloat(order.total || 0),
-        tracking_code: order.tracking_code,
-        notes: notes
-      };
-
-      await orderAutomationService.processEvent('order_status_changed', eventData);
-    }
-
-    res.json({ success: true, message: 'Status atualizado com sucesso' });
-  } catch (error) {
-    logger.logError(error, req);
-    res.status(500).json({ error: 'Erro ao atualizar status' });
-  }
-});
-
-// Adicionar c√≥digo de rastreamento (Admin)
-app.post('/api/orders/:id/tracking', async (req, res) => {
-  try {
-    const { id } = req.params;
-    const { tracking_code } = req.body;
-
-    if (!tracking_code) {
-      return res.status(400).json({ error: 'C√≥digo de rastreamento √© obrigat√≥rio' });
-    }
-
-    // Verificar se a coluna tracking_code existe
-    try {
-      await pool.execute(
-        'UPDATE orders SET tracking_code = ?, status = "shipped", updated_at = NOW() WHERE id = ?',
-        [tracking_code, id]
-      );
-    } catch (colError) {
-      // Se a coluna n√£o existir, apenas atualizar o status
-      console.log('‚ö†Ô∏è Coluna tracking_code n√£o existe, atualizando apenas status');
-      await pool.execute(
-        'UPDATE orders SET status = "shipped", updated_at = NOW() WHERE id = ?',
-        [id]
-      );
-    }
-
-    // Buscar dados do pedido
-    const [orders] = await pool.execute(
-      'SELECT customer_email, customer_name FROM orders WHERE id = ?',
-      [id]
-    );
-
-    if (orders.length > 0 && orders[0].customer_email) {
-      console.log(`üìß Enviar c√≥digo de rastreamento ${tracking_code} para ${orders[0].customer_email}`);
-      // Aqui voc√™ pode adicionar l√≥gica para enviar email
-    }
-
-    res.json({ success: true, message: 'C√≥digo de rastreamento adicionado' });
-  } catch (error) {
-    logger.logError(error, req);
-    res.status(500).json({ error: 'Erro ao adicionar c√≥digo de rastreamento' });
-  }
-});
-
-// Associar pedido com usu√°rio (Admin)
-app.patch('/api/orders/:id/associate-user', async (req, res) => {
-  try {
-    const { id } = req.params;
-    const { user_id, customer_email } = req.body;
-
-    if (!user_id && !customer_email) {
-      return res.status(400).json({ error: 'user_id ou customer_email √© obrigat√≥rio' });
-    }
-
-    let userIdToUse = user_id;
-
-    // Se n√£o tem user_id mas tem email, tentar encontrar o usu√°rio
-    if (!userIdToUse && customer_email) {
-      const [users] = await pool.execute(
-        'SELECT id FROM users WHERE email = ?',
-        [customer_email]
-      );
-
-      if (users.length > 0) {
-        userIdToUse = users[0].id;
-      }
-    }
-
-    if (!userIdToUse) {
-      return res.status(404).json({ error: 'Usu√°rio n√£o encontrado' });
-    }
-
-    // Atualizar o pedido com o user_id
-    await pool.execute(
-      'UPDATE orders SET user_id = ?, updated_at = NOW() WHERE id = ?',
-      [userIdToUse, id]
-    );
-
-    // Buscar dados do usu√°rio para retornar
-    const [users] = await pool.execute(
-      'SELECT nome, email, telefone FROM users WHERE id = ?',
-      [userIdToUse]
-    );
-
-    res.json({
-      success: true,
-      message: 'Pedido associado ao cliente com sucesso',
-      customer: users[0] || null
-    });
-  } catch (error) {
-    logger.logError(error, req);
-    res.status(500).json({ error: 'Erro ao associar pedido com cliente' });
-  }
-});
-
-// Buscar usu√°rios para associa√ß√£o (Admin)
-app.get('/api/admin/users/search', async (req, res) => {
-  try {
-    const { q } = req.query;
-
-    if (!q || q.length < 2) {
-      return res.json([]);
-    }
-
-    const [users] = await pool.execute(`
-      SELECT id, nome, email, telefone 
-      FROM users 
-      WHERE nome LIKE ? OR email LIKE ?
-      LIMIT 10
-    `, [`%${q}%`, `%${q}%`]);
-
-    res.json(users);
-  } catch (error) {
-    logger.logError(error, req);
-    res.status(500).json({ error: 'Erro ao buscar usu√°rios' });
-  }
-});
-
-// A√ß√µes em massa (Admin)
-app.post('/api/orders/bulk-action', async (req, res) => {
-  try {
-    const { orderIds, action } = req.body;
-
-    if (!Array.isArray(orderIds) || orderIds.length === 0) {
-      return res.status(400).json({ error: 'IDs de pedidos s√£o obrigat√≥rios' });
-    }
-
-    if (!action) {
-      return res.status(400).json({ error: 'A√ß√£o √© obrigat√≥ria' });
-    }
-
-    const validActions = ['processing', 'shipped', 'delivered', 'cancelled'];
-    if (!validActions.includes(action)) {
-      return res.status(400).json({ error: 'A√ß√£o inv√°lida' });
-    }
-
-    // Atualizar todos os pedidos
-    const placeholders = orderIds.map(() => '?').join(',');
-    await pool.execute(
-      `UPDATE orders SET status = ?, updated_at = NOW() WHERE id IN (${placeholders})`,
-      [action, ...orderIds]
-    );
-
-    res.json({
-      success: true,
-      message: `${orderIds.length} pedido(s) atualizado(s)`,
-      updated: orderIds.length
-    });
-  } catch (error) {
-    logger.logError(error, req);
-    res.status(500).json({ error: 'Erro ao executar a√ß√£o em massa' });
-  }
-});
-
-// Criar tabelas para p√°gina Sobre
-(async () => {
-  try {
-    // Tabela para conte√∫do da p√°gina Sobre
-    await pool.execute(`
-      CREATE TABLE IF NOT EXISTS sobre_content (
-        id VARCHAR(191) PRIMARY KEY,
-        section VARCHAR(100) NOT NULL,
-        title VARCHAR(255),
-        subtitle VARCHAR(255),
-        description TEXT,
-        image_url VARCHAR(500),
-        order_index INT DEFAULT 0,
-        is_active BOOLEAN DEFAULT TRUE,
-        metadata JSON,
-        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
-        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
-        UNIQUE KEY unique_section (section)
-      )
-    `);
-    console.log('‚úÖ Tabela sobre_content criada/verificada');
-
-    // Tabela para valores da empresa
-    await pool.execute(`
-      CREATE TABLE IF NOT EXISTS company_values (
-        id VARCHAR(191) PRIMARY KEY,
-        title VARCHAR(255) NOT NULL,
-        description TEXT,
-        icon VARCHAR(100),
-        order_index INT DEFAULT 0,
-        is_active BOOLEAN DEFAULT TRUE,
-        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
-        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
-      )
-    `);
-    console.log('‚úÖ Tabela company_values criada/verificada');
-
-    // Tabela para equipe
-    await pool.execute(`
-      CREATE TABLE IF NOT EXISTS team_members (
-        id VARCHAR(191) PRIMARY KEY,
-        name VARCHAR(255) NOT NULL,
-        position VARCHAR(255),
-        description TEXT,
-        image_url VARCHAR(500),
-        order_index INT DEFAULT 0,
-        is_active BOOLEAN DEFAULT TRUE,
-        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
-        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
-      )
-    `);
-    console.log('‚úÖ Tabela team_members criada/verificada');
-
-    // Tabela para estat√≠sticas
-    await pool.execute(`
-      CREATE TABLE IF NOT EXISTS company_stats (
-        id VARCHAR(191) PRIMARY KEY,
-        title VARCHAR(255) NOT NULL,
-        value VARCHAR(100) NOT NULL,
-        icon VARCHAR(100),
-        order_index INT DEFAULT 0,
-        is_active BOOLEAN DEFAULT TRUE,
-        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
-        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
-      )
-    `);
-    console.log('‚úÖ Tabela company_stats criada/verificada');
-
-    // Tabela para informa√ß√µes de contato
-    await pool.execute(`
-      CREATE TABLE IF NOT EXISTS contact_info (
-        id VARCHAR(191) PRIMARY KEY,
-        type VARCHAR(100) NOT NULL,
-        title VARCHAR(255) NOT NULL,
-        value VARCHAR(255) NOT NULL,
-        icon VARCHAR(100),
-        order_index INT DEFAULT 0,
-        is_active BOOLEAN DEFAULT TRUE,
-        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
-        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
-      )
-    `);
-    console.log('‚úÖ Tabela contact_info criada/verificada');
-
-    // Inserir dados iniciais para a se√ß√£o hero se n√£o existir
-    const [existingHero] = await pool.execute('SELECT id FROM sobre_content WHERE section = ?', ['hero']);
-    if (existingHero.length === 0) {
-      const heroId = require('crypto').randomUUID();
-      await pool.execute(`
-        INSERT INTO sobre_content (id, section, title, subtitle, description, metadata, is_active)
-        VALUES (?, 'hero', 'Nossa Hist√≥ria', '', 'A MuhlStore nasceu do sonho de conectar pessoas atrav√©s de brinquedos √∫nicos e especiais. Desde 2020, nossa miss√£o √© descobrir e compartilhar tesouros de brinquedos raros e seminovos de todo o Brasil.', ?, TRUE)
-      `, [heroId, JSON.stringify({
-        badge_text: 'Nossa Hist√≥ria',
-        badge_icon: 'Sparkles',
-        show_badge: true,
-        buttons: [
-          {
-            id: '1',
-            text: 'Conhe√ßa Nossos Produtos',
-            icon: 'Gift',
-            variant: 'primary',
-            action: '/loja',
-            color: 'orange'
-          },
-          {
-            id: '2',
-            text: 'Nossa Miss√£o',
-            icon: 'Heart',
-            variant: 'outline',
-            action: '/about',
-            color: 'orange'
-          }
-        ]
-      })]);
-      console.log('‚úÖ Dados iniciais da se√ß√£o hero criados');
-    }
-
-  } catch (err) {
-    console.error('‚ùå Erro ao criar tabelas da p√°gina Sobre:', { message: err?.message, code: err?.code });
-  }
-})();
-
-// ==========================
-// Endere√ßos do cliente (por cart_id)
-// ==========================
-(async () => {
-  try {
-    await pool.execute(`
-      CREATE TABLE IF NOT EXISTS addresses (
-        id VARCHAR(191) PRIMARY KEY,
-        cart_id VARCHAR(191) NOT NULL,
-        nome VARCHAR(255),
-        telefone VARCHAR(100),
-        cep VARCHAR(20),
-        endereco VARCHAR(255),
-        numero VARCHAR(50),
-        complemento VARCHAR(255),
-        bairro VARCHAR(255),
-        cidade VARCHAR(255),
-        estado VARCHAR(50),
-        shipping_default TINYINT(1) DEFAULT 0,
-        billing_default TINYINT(1) DEFAULT 0,
-        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
-        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
-        INDEX idx_cart (cart_id)
-      )
-    `);
-    console.log('‚úÖ Tabela addresses criada/verificada');
-  } catch (e) {
-    console.error('‚ùå Erro ao criar tabela addresses', e);
-  }
-})();
-
-const { randomUUID: uuidv4 } = require('crypto');
-
-app.get('/api/addresses', highFrequencyLimiter, async (req, res) => {
-  try {
-    console.log('üìç GET /api/addresses - Buscando endere√ßos do usu√°rio logado');
-
-    // Tentar obter o usu√°rio da sess√£o
-    let userId = null;
-
-    // Verificar se h√° session_id no cookie
-    const sessionId = req.cookies?.session_id;
-    if (sessionId) {
-      console.log('üîç Verificando sess√£o:', sessionId);
-      try {
-        const [sessions] = await pool.execute('SELECT * FROM sessions WHERE id = ?', [sessionId]);
-        if (sessions && sessions[0]) {
-          userId = sessions[0].user_id;
-          console.log('‚úÖ Usu√°rio encontrado na sess√£o:', userId);
-        }
-      } catch (e) {
-        console.log('‚ö†Ô∏è Erro ao verificar sess√£o:', e.message);
-      }
-    }
-
-    // Se n√£o encontrou usu√°rio na sess√£o, tentar obter do cart_id existente
-    if (!userId) {
-      // Primeiro, tentar obter cart_id do cookie sem criar um novo
-      const existingCartId = req.cookies?.cart_id;
-      if (existingCartId) {
-        console.log('üîç Tentando encontrar usu√°rio pelo cart_id existente:', existingCartId);
-        try {
-          const [carts] = await pool.execute('SELECT * FROM carts WHERE id = ?', [existingCartId]);
-          if (carts && carts[0] && carts[0].user_id) {
-            userId = carts[0].user_id;
-            console.log('‚úÖ Usu√°rio encontrado pelo cart_id existente:', userId);
-          }
-        } catch (e) {
-          console.log('‚ö†Ô∏è Erro ao buscar usu√°rio pelo cart_id existente:', e.message);
-        }
-      }
-
-      // Se ainda n√£o encontrou, criar novo cart_id
-      if (!userId) {
-        const cartId = getOrCreateCartId(req, res);
-        console.log('üîç Tentando encontrar usu√°rio pelo novo cart_id:', cartId);
-        try {
-          const [carts] = await pool.execute('SELECT * FROM carts WHERE id = ?', [cartId]);
-          if (carts && carts[0] && carts[0].user_id) {
-            userId = carts[0].user_id;
-            console.log('‚úÖ Usu√°rio encontrado pelo novo cart_id:', userId);
-          }
-        } catch (e) {
-          console.log('‚ö†Ô∏è Erro ao buscar usu√°rio pelo novo cart_id:', e.message);
-        }
-      }
-    }
-
-    // Se ainda n√£o tem userId, buscar endere√ßos da tabela addresses (para usu√°rios n√£o logados)
-    if (!userId) {
-      console.log('üîç Buscando endere√ßos da tabela addresses (usu√°rio n√£o logado)');
-      const cartId = getOrCreateCartId(req, res);
-      try {
-        const [addresses] = await pool.execute(`
-          SELECT 
-            id,
-            nome,
-            cep,
-            endereco,
-            numero,
-            complemento,
-            bairro,
-            cidade,
-            estado,
-            shipping_default as principal,
-            created_at,
-            updated_at
-          FROM addresses 
-          WHERE cart_id = ?
-          ORDER BY shipping_default DESC, created_at DESC
-        `, [cartId]);
-
-        console.log(`‚úÖ Encontrados ${addresses.length} endere√ßos na tabela addresses`);
-        res.json(addresses);
-        return;
-      } catch (e) {
-        console.log('‚ö†Ô∏è Erro ao buscar endere√ßos da tabela addresses:', e.message);
-      }
-    }
-
-    // Buscar endere√ßos do usu√°rio logado na tabela customer_addresses
-    console.log('üîç Buscando endere√ßos do usu√°rio logado na tabela customer_addresses');
-    try {
-      const [addresses] = await pool.execute(`
-        SELECT 
-          id,
-          tipo,
-          nome,
-          cep,
-          rua as endereco,
-          numero,
-          complemento,
-          bairro,
-          cidade,
-          estado,
-          padrao as principal,
-          created_at
-        FROM customer_addresses 
-        WHERE customer_id = ?
-        ORDER BY padrao DESC, created_at DESC
-      `, [userId]);
-
-      console.log(`‚úÖ Encontrados ${addresses.length} endere√ßos para o usu√°rio ${userId}`);
-      res.json(addresses);
-
-    } catch (e) {
-      console.error('‚ùå Erro ao buscar endere√ßos do usu√°rio:', e);
-      res.status(500).json({ error: 'addresses_list_failed', details: e.message });
-    }
-
-  } catch (e) {
-    console.error('Addresses list error', e);
-    res.status(500).json({ error: 'addresses_list_failed' });
-  }
-});
-
-app.post('/api/addresses', async (req, res) => {
-  console.log('üö® ENDPOINT /api/addresses CHAMADO!');
-  try {
-    console.log('üìç POST /api/addresses - Criando novo endere√ßo');
-    console.log('üìç Headers:', req.headers);
-    console.log('üìç Cookies:', req.cookies);
-    console.log('üìç Body:', req.body);
-
-    // Tentar obter o usu√°rio da sess√£o
-    let userId = null;
-
-    // Verificar se h√° session_id no cookie
-    const sessionId = req.cookies?.session_id;
-    if (sessionId) {
-      console.log('üîç Verificando sess√£o:', sessionId);
-      try {
-        const [sessions] = await pool.execute('SELECT * FROM sessions WHERE id = ?', [sessionId]);
-        if (sessions && sessions[0]) {
-          userId = sessions[0].user_id;
-          console.log('‚úÖ Usu√°rio encontrado na sess√£o:', userId);
-        }
-      } catch (e) {
-        console.log('‚ö†Ô∏è Erro ao verificar sess√£o:', e.message);
-      }
-    }
-
-    // Se n√£o encontrou usu√°rio na sess√£o, tentar obter do cart_id existente
-    if (!userId) {
-      // Primeiro, tentar obter cart_id do cookie sem criar um novo
-      const existingCartId = req.cookies?.cart_id;
-      if (existingCartId) {
-        console.log('üîç Tentando encontrar usu√°rio pelo cart_id existente:', existingCartId);
-        try {
-          const [carts] = await pool.execute('SELECT * FROM carts WHERE id = ?', [existingCartId]);
-          if (carts && carts[0] && carts[0].user_id) {
-            userId = carts[0].user_id;
-            console.log('‚úÖ Usu√°rio encontrado pelo cart_id existente:', userId);
-          }
-        } catch (e) {
-          console.log('‚ö†Ô∏è Erro ao buscar usu√°rio pelo cart_id existente:', e.message);
-        }
-      }
-
-      // Se ainda n√£o encontrou, criar novo cart_id
-      if (!userId) {
-        const cartId = getOrCreateCartId(req, res);
-        console.log('üîç Tentando encontrar usu√°rio pelo novo cart_id:', cartId);
-        try {
-          const [carts] = await pool.execute('SELECT * FROM carts WHERE id = ?', [cartId]);
-          if (carts && carts[0] && carts[0].user_id) {
-            userId = carts[0].user_id;
-            console.log('‚úÖ Usu√°rio encontrado pelo novo cart_id:', userId);
-          }
-        } catch (e) {
-          console.log('‚ö†Ô∏è Erro ao buscar usu√°rio pelo novo cart_id:', e.message);
-        }
-      }
-    }
-
-    const { nome, telefone, cep, endereco, numero, complemento, bairro, cidade, estado, shipping_default, billing_default } = req.body || {};
-    let savedAddressId = uuidv4();
-
-    console.log('üìù Dados do endere√ßo:', { nome, cep, endereco, numero, cidade, estado, shipping_default });
-
-    // Se tem usu√°rio logado, salvar na tabela enderecos
-    if (userId) {
-      console.log('üíæ Salvando endere√ßo na tabela customer_addresses para usu√°rio:', userId);
-
-      // Se for padr√£o, remover padr√£o dos outros endere√ßos
-      if (shipping_default) {
-        await pool.execute('UPDATE customer_addresses SET padrao = 0 WHERE customer_id = ?', [userId]);
-      }
-
-      savedAddressId = uuidv4();
-      await pool.execute(
-        `INSERT INTO customer_addresses (id, customer_id, tipo, nome, cep, rua, numero, complemento, bairro, cidade, estado, padrao, created_at)
-         VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, NOW())`,
-        [savedAddressId, userId, 'casa', nome || 'Endere√ßo Principal', cep, endereco, numero || '', complemento || '', bairro || '', cidade, estado, shipping_default ? 1 : 0]
-      );
-
-      console.log('‚úÖ Endere√ßo salvo na tabela customer_addresses com ID:', savedAddressId);
-
-    } else {
-      // Se n√£o tem usu√°rio logado, salvar na tabela addresses
-      console.log('üíæ Salvando endere√ßo na tabela addresses (usu√°rio n√£o logado)');
-
-      const cartId = getOrCreateCartId(req, res);
-
-      if (shipping_default) {
-        await pool.execute('UPDATE addresses SET shipping_default = 0 WHERE cart_id = ?', [cartId]);
-      }
-      if (billing_default) {
-        await pool.execute('UPDATE addresses SET billing_default = 0 WHERE cart_id = ?', [cartId]);
-      }
-
-      await pool.execute(
-        `INSERT INTO addresses (id, cart_id, nome, telefone, cep, endereco, numero, complemento, bairro, cidade, estado, shipping_default, billing_default)
-         VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?)`,
-        [savedAddressId, cartId, nome || null, telefone || null, cep || null, endereco || null, numero || null, complemento || null, bairro || null, cidade || null, estado || null, shipping_default ? 1 : 0, billing_default ? 1 : 0]
-      );
-
-      console.log('‚úÖ Endere√ßo salvo na tabela addresses');
-    }
-
-    // Retornar o endere√ßo criado
-    const responseData = {
-      id: savedAddressId,
-      nome: nome || 'Endere√ßo',
-      cep,
-      endereco,
-      numero,
-      complemento,
-      bairro,
-      cidade,
-      estado,
-      principal: shipping_default ? 1 : 0,
-      created_at: new Date().toISOString(),
-      updated_at: new Date().toISOString()
-    };
-
-    console.log('‚úÖ Endere√ßo criado com sucesso:', savedAddressId);
-    res.status(201).json(responseData);
-
-  } catch (e) {
-    console.error('‚ùå Addresses create error:', e);
-    res.status(500).json({ error: 'addresses_create_failed', details: e.message });
-  }
-});
-
-app.put('/api/addresses/:id', async (req, res) => {
-  try {
-    console.log('üìç PUT /api/addresses/:id - Atualizando endere√ßo');
-
-    // Tentar obter o usu√°rio da sess√£o
-    let userId = null;
-
-    // Verificar se h√° session_id no cookie
-    const sessionId = req.cookies?.session_id;
-    if (sessionId) {
-      console.log('üîç Verificando sess√£o:', sessionId);
-      try {
-        const [sessions] = await pool.execute('SELECT * FROM sessions WHERE id = ?', [sessionId]);
-        if (sessions && sessions[0]) {
-          userId = sessions[0].user_id;
-          console.log('‚úÖ Usu√°rio encontrado na sess√£o:', userId);
-        }
-      } catch (e) {
-        console.log('‚ö†Ô∏è Erro ao verificar sess√£o:', e.message);
-      }
-    }
-
-    // Se n√£o encontrou usu√°rio na sess√£o, tentar obter do cart_id
-    if (!userId) {
-      const cartId = getOrCreateCartId(req, res);
-      console.log('üîç Tentando encontrar usu√°rio pelo cart_id:', cartId);
-      try {
-        const [carts] = await pool.execute('SELECT * FROM carts WHERE id = ?', [cartId]);
-        if (carts && carts[0] && carts[0].user_id) {
-          userId = carts[0].user_id;
-          console.log('‚úÖ Usu√°rio encontrado pelo cart_id:', userId);
-        }
-      } catch (e) {
-        console.log('‚ö†Ô∏è Erro ao buscar usu√°rio pelo cart_id:', e.message);
-      }
-    }
-
-    const { id } = req.params;
-    const { nome, telefone, cep, endereco, numero, complemento, bairro, cidade, estado, shipping_default, billing_default } = req.body || {};
-
-    console.log('üìù Dados do endere√ßo para atualizar:', { nome, cep, endereco, numero, cidade, estado, shipping_default });
-
-    // Se tem usu√°rio logado, atualizar na tabela customer_addresses
-    if (userId) {
-      console.log('üíæ Atualizando endere√ßo na tabela customer_addresses para usu√°rio:', userId);
-
-      // Se for padr√£o, remover padr√£o dos outros endere√ßos
-      if (shipping_default) {
-        await pool.execute('UPDATE customer_addresses SET padrao = 0 WHERE customer_id = ? AND id != ?', [userId, id]);
-      }
-
-      await pool.execute(
-        `UPDATE customer_addresses SET nome = ?, rua = ?, numero = ?, complemento = ?, bairro = ?, cidade = ?, estado = ?, cep = ?, padrao = ?, updated_at = NOW() WHERE id = ? AND customer_id = ?`,
-        [nome || 'Endere√ßo', endereco, numero || '', complemento || '', bairro || '', cidade, estado, cep, shipping_default ? 1 : 0, id, userId]
-      );
-
-      console.log('‚úÖ Endere√ßo atualizado na tabela customer_addresses');
-
-    } else {
-      // Se n√£o tem usu√°rio logado, atualizar na tabela addresses
-      console.log('üíæ Atualizando endere√ßo na tabela addresses (usu√°rio n√£o logado)');
-
-      const cartId = getOrCreateCartId(req, res);
-
-      if (shipping_default) {
-        await pool.execute('UPDATE addresses SET shipping_default = 0 WHERE cart_id = ?', [cartId]);
-      }
-      if (billing_default) {
-        await pool.execute('UPDATE addresses SET billing_default = 0 WHERE cart_id = ?', [cartId]);
-      }
-
-      await pool.execute(
-        `UPDATE addresses SET nome=?, telefone=?, cep=?, endereco=?, numero=?, complemento=?, bairro=?, cidade=?, estado=?, shipping_default=?, billing_default=? WHERE id = ? AND cart_id = ?`,
-        [nome || null, telefone || null, cep || null, endereco || null, numero || null, complemento || null, bairro || null, cidade || null, estado || null, shipping_default ? 1 : 0, billing_default ? 1 : 0, id, cartId]
-      );
-
-      console.log('‚úÖ Endere√ßo atualizado na tabela addresses');
-    }
-
-    // Retornar o endere√ßo atualizado
-    const responseData = {
-      id,
-      nome: nome || 'Endere√ßo',
-      cep,
-      endereco,
-      numero,
-      complemento,
-      bairro,
-      cidade,
-      estado,
-      principal: shipping_default ? 1 : 0,
-      updated_at: new Date().toISOString()
-    };
-
-    console.log('‚úÖ Endere√ßo atualizado com sucesso:', id);
-    res.json(responseData);
-  } catch (e) {
-    console.error('Addresses update error', e);
-    res.status(500).json({ error: 'addresses_update_failed' });
-  }
-});
-
-app.delete('/api/addresses/:id', async (req, res) => {
-  try {
-    const cartId = getOrCreateCartId(req, res);
-    const { id } = req.params;
-    await pool.execute('DELETE FROM addresses WHERE id = ? AND cart_id = ?', [id, cartId]);
-    res.json({ ok: true });
-  } catch (e) {
-    console.error('Addresses delete error', e);
-    res.status(500).json({ error: 'addresses_delete_failed' });
-  }
-});
-
-
-// POST /api/collections/:id/products - Vincular produto √† cole√ß√£o
-app.post('/api/collections/:id/products', async (req, res) => {
-  try {
-    const { id } = req.params;
-    const { product_id, order_index } = req.body || {};
-    if (!product_id) {
-      return res.status(400).json({ error: 'product_id √© obrigat√≥rio' });
-    }
-
-    // Checar exist√™ncia de cole√ß√£o
-    const [cRows] = await pool.execute('SELECT id FROM collections WHERE id = ?', [id]);
-    if (!cRows || cRows.length === 0) return res.status(404).json({ error: 'Cole√ß√£o n√£o encontrada' });
-
-    // Checar exist√™ncia de produto (tabela products OU produtos)
-    let productExists = false;
-    try {
-      const [pRows] = await pool.execute('SELECT id FROM products WHERE id = ?', [product_id]);
-      productExists = Array.isArray(pRows) && pRows.length > 0;
-    } catch (e) {
-      // Se a tabela products n√£o existir, vamos tentar na tabela produtos
-      if (e && (e.code === 'ER_NO_SUCH_TABLE' || /doesn\'t exist/i.test(String(e.message)))) {
-        // segue para tentar na tabela produtos
-      } else {
-        console.error('‚ùå Erro ao consultar tabela products:', { code: e?.code, message: e?.message });
-      }
-    }
-
-    if (!productExists) {
-      try {
-        const [pRows2] = await pool.execute('SELECT id FROM produtos WHERE id = ?', [product_id]);
-        productExists = Array.isArray(pRows2) && pRows2.length > 0;
-      } catch (e2) {
-        console.error('‚ùå Erro ao consultar tabela produtos:', { code: e2?.code, message: e2?.message });
-      }
-    }
-
-    if (!productExists) {
-      return res.status(404).json({ error: 'Produto n√£o encontrado' });
-    }
-
-    const ord = Number.isFinite(order_index) ? order_index : 0;
-    const [result] = await pool.execute(
-      'INSERT INTO collection_products (collection_id, product_id, order_index, created_at, updated_at) VALUES (?, ?, ?, NOW(), NOW())',
-      [id, product_id, ord]
-    );
-
-    res.status(201).json({ id: result.insertId, collection_id: id, product_id, order_index: ord });
-  } catch (error) {
-    console.error('‚ùå Erro ao adicionar produto na cole√ß√£o:', { message: error?.message, code: error?.code });
-    res.status(500).json({ error: 'Erro interno do servidor', message: error?.message, code: error?.code });
-  }
-});
-
-// DELETE /api/collections/:id/products/:productId - Remover v√≠nculo
-app.delete('/api/collections/:id/products/:productId', async (req, res) => {
-  try {
-    const { id, productId } = req.params;
-
-    console.log(`üóëÔ∏è Removendo produto ${productId} da cole√ß√£o ${id}`);
-
-    // Verificar se o v√≠nculo existe
-    const [existing] = await pool.execute(
-      'SELECT id FROM collection_products WHERE collection_id = ? AND product_id = ?',
-      [id, productId]
-    );
-
-    if (!existing || existing.length === 0) {
-      console.log(`‚ùå V√≠nculo n√£o encontrado: cole√ß√£o ${id}, produto ${productId}`);
-      return res.status(404).json({ error: 'Produto n√£o encontrado nesta cole√ß√£o' });
-    }
-
-    // Remover o v√≠nculo
-    const [result] = await pool.execute(
-      'DELETE FROM collection_products WHERE collection_id = ? AND product_id = ?',
-      [id, productId]
-    );
-
-    if (result.affectedRows === 0) {
-      console.log(`‚ùå Nenhum v√≠nculo foi removido`);
-      return res.status(404).json({ error: 'Produto n√£o encontrado nesta cole√ß√£o' });
-    }
-
-    console.log(`‚úÖ Produto ${productId} removido da cole√ß√£o ${id} (${result.affectedRows} v√≠nculo(s) removido(s))`);
-    res.json({
-      success: true,
-      message: 'Produto removido com sucesso',
-      removed_count: result.affectedRows
-    });
-
-  } catch (error) {
-    console.error('‚ùå Erro ao remover produto da cole√ß√£o:', {
-      message: error?.message,
-      code: error?.code,
-      collectionId: req.params.id,
-      productId: req.params.productId
-    });
-    res.status(500).json({
-      error: 'Erro interno do servidor',
-      message: error?.message,
-      code: error?.code
-    });
-  }
-});
-
-// PATCH /api/collections/:id/products/reorder - Reordenar produtos vinculados
-app.patch('/api/collections/:id/products/reorder', async (req, res) => {
-  try {
-    const { id } = req.params;
-    const { product_ids } = req.body || {};
-    if (!Array.isArray(product_ids) || product_ids.length === 0) {
-      return res.status(400).json({ error: 'product_ids √© obrigat√≥rio (array)' });
-    }
-
-    const connection = await pool.getConnection();
-    try {
-      await connection.beginTransaction();
-      for (let i = 0; i < product_ids.length; i++) {
-        await connection.execute(
-          'UPDATE collection_products SET order_index = ?, updated_at = NOW() WHERE collection_id = ? AND product_id = ?',
-          [i, id, product_ids[i]]
-        );
-      }
-      await connection.commit();
-    } catch (e) {
-      await connection.rollback();
-      throw e;
-    } finally {
-      connection.release();
-    }
-
-    res.json({ success: true });
-  } catch (error) {
-    console.error('‚ùå Erro ao reordenar produtos da cole√ß√£o:', { message: error?.message, code: error?.code });
-    res.status(500).json({ error: 'Erro interno do servidor', message: error?.message, code: error?.code });
-  }
-});
-
-// DEBUG: resumo de cole√ß√£o e v√≠nculos
-app.get('/api/debug/collections/:id/summary', async (req, res) => {
-  try {
-    const { id } = req.params;
-    const [[cRows], [lRows]] = await Promise.all([
-      pool.execute('SELECT * FROM collections WHERE id = ?', [id]),
-      pool.execute('SELECT * FROM collection_products WHERE collection_id = ?', [id])
-    ]);
-    const collection = cRows && cRows[0] ? cRows[0] : null;
-    res.json({ collection, links_count: lRows.length, sample_links: lRows.slice(0, 5) });
-  } catch (error) {
-    console.error('‚ùå Debug summary error:', error);
-    res.status(500).json({ error: 'debug_failed' });
-  }
-});
-
-// PUT /api/collections/reorder - Reordenar cole√ß√µes
-app.put('/api/collections/reorder', async (req, res) => {
-  try {
-    const { ids } = req.body;
-    console.log('üîÑ Reordenando cole√ß√µes...');
-
-    if (!Array.isArray(ids) || ids.length === 0) {
-      return res.status(400).json({ error: 'Lista de IDs √© obrigat√≥ria' });
-    }
-
-    // Atualizar ordem de cada cole√ß√£o (se a coluna ordem existir)
-    const [cols] = await pool.execute("SELECT COLUMN_NAME FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_SCHEMA = DATABASE() AND TABLE_NAME = 'collections'");
-    const hasOrdem = cols.some((c) => c.COLUMN_NAME === 'ordem');
-    for (let i = 0; i < ids.length; i++) {
-      if (hasOrdem) {
-        await pool.execute('UPDATE collections SET ordem = ?, updated_at = NOW() WHERE id = ?', [i, ids[i]]);
-      } else {
-        await pool.execute('UPDATE collections SET updated_at = NOW() WHERE id = ?', [ids[i]]);
-      }
-    }
-
-    console.log(`‚úÖ ${ids.length} cole√ß√µes reordenadas com sucesso`);
-    res.json({ message: 'Cole√ß√µes reordenadas com sucesso' });
-  } catch (error) {
-    console.error('‚ùå Erro ao reordenar cole√ß√µes:', error);
-    res.status(500).json({ error: 'Erro interno do servidor' });
-  }
-});
-
-// POST /api/collections/seed - Popular cole√ß√µes de exemplo
-app.post('/api/collections/seed', async (req, res) => {
-  try {
-    console.log('üîÑ Populando cole√ß√µes de exemplo...');
-
-    const colecoesExemplo = [
-      {
-        nome: 'Action Figures Premium',
-        descricao: 'Bonecos de a√ß√£o de alta qualidade com detalhes incr√≠veis e articula√ß√µes avan√ßadas',
-        imagem_url: '/lovable-uploads/action-figures-collection.jpg',
-        destaque: true
-      },
-      {
-        nome: 'Colecion√°veis Vintage',
-        descricao: 'Itens raros e vintage para colecionadores apaixonados por pe√ßas √∫nicas',
-        imagem_url: '/lovable-uploads/vintage-collection.jpg',
-        destaque: true
-      },
-      {
-        nome: 'Brinquedos Educativos',
-        descricao: 'Jogos e brinquedos que estimulam o aprendizado e desenvolvimento infantil',
-        imagem_url: '/lovable-uploads/educational-toys.jpg',
-        destaque: false
-      },
-      {
-        nome: 'Pel√∫cias Premium',
-        descricao: 'Pel√∫cias macias e fofas, perfeitas para conforto e decora√ß√£o',
-        imagem_url: '/lovable-uploads/plush-toys.jpg',
-        destaque: false
-      },
-      {
-        nome: 'Jogos de Tabuleiro',
-        descricao: 'Cl√°ssicos e modernos jogos de tabuleiro para divers√£o em fam√≠lia',
-        imagem_url: '/lovable-uploads/board-games.jpg',
-        destaque: true
-      },
-      {
-        nome: 'Carrinhos e Ve√≠culos',
-        descricao: 'Carros, caminh√µes e ve√≠culos de todos os tipos para pequenos motoristas',
-        imagem_url: '/lovable-uploads/vehicles-collection.jpg',
-        destaque: false
-      }
-    ];
-
-    for (const colecao of colecoesExemplo) {
-      await pool.execute(
-        'INSERT IGNORE INTO collections (nome, descricao, imagem_url, destaque, ativo, created_at, updated_at) VALUES (?, ?, ?, ?, 1, NOW(), NOW())',
-        [colecao.nome, colecao.descricao, colecao.imagem_url, colecao.destaque]
-      );
-    }
-
-    console.log(`‚úÖ ${colecoesExemplo.length} cole√ß√µes de exemplo criadas`);
-    res.json({ message: `${colecoesExemplo.length} cole√ß√µes de exemplo criadas com sucesso` });
-  } catch (error) {
-    console.error('‚ùå Erro ao popular cole√ß√µes:', error);
-    res.status(500).json({ error: 'Erro interno do servidor' });
-  }
-});
-
-// Fun√ß√£o utilit√°ria para verificar se uma imagem existe
-function imageExists(imageUrl) {
-  if (!imageUrl) return false;
-
-  // Remover query params e fragmentos
-  const cleanUrl = imageUrl.split('?')[0].split('#')[0];
-
-  // Se for URL absoluta, extrair o path
-  let filePath = cleanUrl;
-  if (cleanUrl.startsWith('http')) {
-    try {
-      const url = new URL(cleanUrl);
-      filePath = url.pathname;
-    } catch (e) {
-      return false;
-    }
-  }
-
-  // Remover /lovable-uploads/ do in√≠cio se existir
-  const filename = filePath.replace(/^\/lovable-uploads\//, '');
-  const uploadsDir = path.join(__dirname, '../public/lovable-uploads');
-  const fullPath = path.join(uploadsDir, filename);
-
-  try {
-    return fs.existsSync(fullPath) && fs.statSync(fullPath).isFile();
-  } catch (e) {
-    return false;
-  }
-}
-
-// Upload de imagem para cole√ß√µes
-app.post('/api/collections/upload-image', upload.single('image'), async (req, res) => {
-  try {
-    if (!req.file) {
-      return res.status(400).json({ error: 'Nenhuma imagem foi enviada' });
-    }
-
-    // Verificar se o arquivo foi realmente salvo
-    const uploadsDir = path.join(__dirname, '../public/lovable-uploads');
-    const filePath = path.join(uploadsDir, req.file.filename);
-
-    if (!fs.existsSync(filePath)) {
-      console.error(`‚ùå Arquivo n√£o foi salvo: ${req.file.filename}`);
-      return res.status(500).json({ error: 'Erro ao salvar arquivo' });
-    }
-
-    const imageUrl = `/lovable-uploads/${req.file.filename}`;
-    const fullUrl = getPublicUrl(req, imageUrl);
-
-    console.log(`‚úÖ Imagem de cole√ß√£o enviada e validada: ${req.file.filename}`);
-
-    res.json({
-      success: true,
-      imageUrl: imageUrl,
-      fullUrl: fullUrl,
-      filename: req.file.filename
-    });
-  } catch (error) {
-    console.error('‚ùå Erro no upload de imagem:', error);
-    res.status(500).json({ error: 'Erro interno do servidor' });
-  }
-});
-
-// Upload direto da imagem da cole√ß√£o (multipart) e atualizar registro
-app.post('/api/collections/:id/image', upload.single('image'), async (req, res) => {
-  try {
-    const { id } = req.params;
-    if (!req.file) return res.status(400).json({ error: 'Nenhuma imagem foi enviada' });
-    // garantir que a cole√ß√£o existe
-    const [rows] = await pool.execute('SELECT id FROM collections WHERE id = ?', [id]);
-    if (!rows || rows.length === 0) return res.status(404).json({ error: 'Cole√ß√£o n√£o encontrada' });
-
-    const imageUrl = `/lovable-uploads/${req.file.filename}`;
-    await pool.execute('UPDATE collections SET imagem_url = ?, updated_at = NOW() WHERE id = ?', [imageUrl, id]);
-
-    const host = req.get('host');
-    const proto = req.protocol || 'http';
-    const fullUrl = getPublicUrl(req, imageUrl);
-    res.json({ success: true, id, imagem_url: imageUrl, imagem: fullUrl, filename: req.file.filename });
-  } catch (error) {
-    console.error('‚ùå Erro ao atualizar imagem da cole√ß√£o:', error);
-    res.status(500).json({ error: 'Erro interno do servidor' });
-  }
-});
-
-// Rota para verificar estrutura da tabela collections
-app.get('/api/debug/collections-structure', async (req, res) => {
-  try {
-    const [rows] = await pool.execute('DESCRIBE collections');
-    res.json({ structure: rows });
-  } catch (error) {
-    res.status(500).json({ error: error.message });
-  }
-});
-
-// Rota para adicionar colunas faltantes
-app.post('/api/debug/fix-collections-table', async (req, res) => {
-  try {
-    console.log('üîÑ Verificando e corrigindo estrutura da tabela collections...');
-
-    // Verificar se a coluna destaque existe
-    const [columns] = await pool.execute("SHOW COLUMNS FROM collections LIKE 'destaque'");
-    if (columns.length === 0) {
-      await pool.execute('ALTER TABLE collections ADD COLUMN destaque BOOLEAN DEFAULT FALSE');
-      console.log('‚úÖ Coluna destaque adicionada');
-    }
-
-    // Verificar se a coluna tags existe
-    const [tagsColumns] = await pool.execute("SHOW COLUMNS FROM collections LIKE 'tags'");
-    if (tagsColumns.length === 0) {
-      await pool.execute('ALTER TABLE collections ADD COLUMN tags JSON');
-      console.log('‚úÖ Coluna tags adicionada');
-    }
-
-    // Verificar se a coluna ordem existe
-    const [ordemColumns] = await pool.execute("SHOW COLUMNS FROM collections LIKE 'ordem'");
-    if (ordemColumns.length === 0) {
-      await pool.execute('ALTER TABLE collections ADD COLUMN ordem INT DEFAULT 0');
-      console.log('‚úÖ Coluna ordem adicionada');
-    }
-
-    res.json({ message: 'Estrutura da tabela corrigida com sucesso' });
-  } catch (error) {
-    console.error('‚ùå Erro ao corrigir tabela:', error);
-    res.status(500).json({ error: error.message });
-  }
-});
-
-// ===== P√ÅGINA SOBRE API =====
-
-// GET /api/sobre/content - Buscar conte√∫do da p√°gina Sobre
-app.get('/api/sobre/content', async (req, res) => {
-  try {
-    const [rows] = await pool.execute(`
-      SELECT * FROM sobre_content 
-      WHERE is_active = TRUE 
-      ORDER BY order_index ASC, created_at ASC
-    `);
-    res.json(rows);
-  } catch (error) {
-    console.error('‚ùå Erro ao buscar conte√∫do da p√°gina Sobre:', error);
-    res.status(500).json({ error: 'Erro interno do servidor' });
-  }
-});
-
-// PUT /api/sobre/content/:section - Atualizar conte√∫do de uma se√ß√£o
-app.put('/api/sobre/content/:section', async (req, res) => {
-  try {
-    const { section } = req.params;
-    const { title, subtitle, description, image_url, metadata } = req.body;
-
-    const id = require('crypto').randomUUID();
-
-    // Garantir que os valores n√£o sejam undefined
-    const safeTitle = title || null;
-    const safeSubtitle = subtitle || null;
-    const safeDescription = description || null;
-    const safeImageUrl = image_url || null;
-    const safeMetadata = metadata ? JSON.stringify(metadata) : null;
-
-
-    await pool.execute(`
-      INSERT INTO sobre_content (id, section, title, subtitle, description, image_url, metadata, is_active)
-      VALUES (?, ?, ?, ?, ?, ?, ?, TRUE)
-      ON DUPLICATE KEY UPDATE
-        title = VALUES(title),
-        subtitle = VALUES(subtitle),
-        description = VALUES(description),
-        image_url = VALUES(image_url),
-        metadata = VALUES(metadata),
-        updated_at = CURRENT_TIMESTAMP
-    `, [id, section, safeTitle, safeSubtitle, safeDescription, safeImageUrl, safeMetadata]);
-
-    res.json({ success: true, message: 'Conte√∫do atualizado com sucesso' });
-  } catch (error) {
-    console.error('‚ùå Erro ao atualizar conte√∫do da p√°gina Sobre:', error);
-    res.status(500).json({ error: 'Erro interno do servidor' });
-  }
-});
-
-// PUT /api/sobre/content/:id - Atualizar conte√∫do espec√≠fico por ID
-app.put('/api/sobre/content/:id', async (req, res) => {
-  try {
-    const { id } = req.params;
-    const { title, subtitle, description, image_url, metadata } = req.body;
-
-    // Garantir que os valores n√£o sejam undefined
-    const safeTitle = title || null;
-    const safeSubtitle = subtitle || null;
-    const safeDescription = description || null;
-    const safeImageUrl = image_url || null;
-    const safeMetadata = metadata ? JSON.stringify(metadata) : null;
-
-    await pool.execute(`
-      UPDATE sobre_content 
-      SET title = ?, subtitle = ?, description = ?, image_url = ?, metadata = ?, updated_at = CURRENT_TIMESTAMP
-      WHERE id = ?
-    `, [safeTitle, safeSubtitle, safeDescription, safeImageUrl, safeMetadata, id]);
-
-    res.json({ success: true, message: 'Conte√∫do atualizado com sucesso' });
-  } catch (error) {
-    console.error('‚ùå Erro ao atualizar conte√∫do da p√°gina Sobre:', error);
-    res.status(500).json({ error: 'Erro interno do servidor' });
-  }
-});
-
-// POST /api/sobre/upload-image - Upload de imagem para p√°gina Sobre
-app.post('/api/sobre/upload-image', upload.single('image'), async (req, res) => {
-  try {
-    if (!req.file) {
-      return res.status(400).json({ error: 'Nenhuma imagem enviada' });
-    }
-
-    const imageUrl = `/lovable-uploads/${req.file.filename}`;
-    res.json({
-      success: true,
-      image_url: imageUrl,
-      message: 'Imagem enviada com sucesso'
-    });
-  } catch (error) {
-    console.error('‚ùå Erro no upload de imagem da p√°gina Sobre:', error);
-    res.status(500).json({ error: 'Erro interno do servidor' });
-  }
-});
-
-// GET /api/sobre/values - Buscar valores da empresa
-app.get('/api/sobre/values', async (req, res) => {
-  try {
-    const [rows] = await pool.execute(`
-      SELECT * FROM company_values 
-      WHERE is_active = TRUE 
-      ORDER BY order_index ASC, created_at ASC
-    `);
-    res.json(rows);
-  } catch (error) {
-    console.error('‚ùå Erro ao buscar valores da empresa:', error);
-    res.status(500).json({ error: 'Erro interno do servidor' });
-  }
-});
-
-// POST /api/sobre/values - Criar novo valor
-app.post('/api/sobre/values', async (req, res) => {
-  try {
-    const { title, description, icon, order_index } = req.body;
-    const id = require('crypto').randomUUID();
-
-    await pool.execute(`
-      INSERT INTO company_values (id, title, description, icon, order_index, is_active)
-      VALUES (?, ?, ?, ?, ?, TRUE)
-    `, [id, title, description, icon, order_index || 0]);
-
-    res.json({ success: true, id, message: 'Valor criado com sucesso' });
-  } catch (error) {
-    console.error('‚ùå Erro ao criar valor:', error);
-    res.status(500).json({ error: 'Erro interno do servidor' });
-  }
-});
-
-// PUT /api/sobre/values/:id - Atualizar valor
-app.put('/api/sobre/values/:id', async (req, res) => {
-  try {
-    const { id } = req.params;
-    const { title, description, icon, order_index, is_active } = req.body;
-
-    await pool.execute(`
-      UPDATE company_values 
-      SET title = ?, description = ?, icon = ?, order_index = ?, is_active = ?
-      WHERE id = ?
-    `, [title, description, icon, order_index || 0, is_active !== false, id]);
-
-    res.json({ success: true, message: 'Valor atualizado com sucesso' });
-  } catch (error) {
-    console.error('‚ùå Erro ao atualizar valor:', error);
-    res.status(500).json({ error: 'Erro interno do servidor' });
-  }
-});
-
-// DELETE /api/sobre/values/:id - Deletar valor
-app.delete('/api/sobre/values/:id', async (req, res) => {
-  try {
-    const { id } = req.params;
-
-    await pool.execute('DELETE FROM company_values WHERE id = ?', [id]);
-
-    res.json({ success: true, message: 'Valor deletado com sucesso' });
-  } catch (error) {
-    console.error('‚ùå Erro ao deletar valor:', error);
-    res.status(500).json({ error: 'Erro interno do servidor' });
-  }
-});
-
-// GET /api/sobre/team - Buscar membros da equipe
-app.get('/api/sobre/team', async (req, res) => {
-  try {
-    const [rows] = await pool.execute(`
-      SELECT * FROM team_members 
-      WHERE is_active = 1 
-      ORDER BY order_index ASC, created_at ASC
-    `);
-    res.json(rows);
-  } catch (error) {
-    console.error('‚ùå Erro ao buscar membros da equipe:', error);
-    res.status(500).json({ error: 'Erro interno do servidor' });
-  }
-});
-
-// POST /api/sobre/team - Criar novo membro da equipe
-app.post('/api/sobre/team', async (req, res) => {
-  try {
-    const { name, position, description, image_url, order_index } = req.body;
-    const id = require('crypto').randomUUID();
-
-    await pool.execute(`
-      INSERT INTO team_members (id, name, position, description, image_url, order_index, is_active)
-      VALUES (?, ?, ?, ?, ?, ?, TRUE)
-    `, [
-      id,
-      name ?? null,
-      position ?? null,
-      description ?? null,
-      image_url ?? null,
-      order_index ?? 0
-    ]);
-
-    res.json({ success: true, id, message: 'Membro da equipe criado com sucesso' });
-  } catch (error) {
-    console.error('‚ùå Erro ao criar membro da equipe:', error);
-    console.error('Detalhes do erro:', error.message);
-    console.error('SQL State:', error.sqlState);
-    console.error('Dados recebidos:', req.body);
-    res.status(500).json({
-      error: 'Erro interno do servidor',
-      message: error.message
-    });
-  }
-});
-
-// PUT /api/sobre/team/:id - Atualizar membro da equipe
-app.put('/api/sobre/team/:id', async (req, res) => {
-  try {
-    const { id } = req.params;
-    const { name, position, description, image_url, order_index, is_active } = req.body;
-
-    await pool.execute(`
-      UPDATE team_members 
-      SET name = ?, position = ?, description = ?, image_url = ?, order_index = ?, is_active = ?
-      WHERE id = ?
-    `, [name, position, description, image_url, order_index || 0, is_active !== false, id]);
-
-    res.json({ success: true, message: 'Membro da equipe atualizado com sucesso' });
-  } catch (error) {
-    console.error('‚ùå Erro ao atualizar membro da equipe:', error);
-    res.status(500).json({ error: 'Erro interno do servidor' });
-  }
-});
-
-// DELETE /api/sobre/team/:id - Deletar membro da equipe
-app.delete('/api/sobre/team/:id', async (req, res) => {
-  try {
-    const { id } = req.params;
-
-    await pool.execute('DELETE FROM team_members WHERE id = ?', [id]);
-
-    res.json({ success: true, message: 'Membro da equipe deletado com sucesso' });
-  } catch (error) {
-    console.error('‚ùå Erro ao deletar membro da equipe:', error);
-    res.status(500).json({ error: 'Erro interno do servidor' });
-  }
-});
-
-// GET /api/sobre/stats - Buscar estat√≠sticas da empresa
-app.get('/api/sobre/stats', async (req, res) => {
-  try {
-    const [rows] = await pool.execute(`
-      SELECT * FROM company_stats 
-      WHERE is_active = TRUE 
-      ORDER BY order_index ASC, created_at ASC
-    `);
-    res.json(rows);
-  } catch (error) {
-    console.error('‚ùå Erro ao buscar estat√≠sticas da empresa:', error);
-    res.status(500).json({ error: 'Erro interno do servidor' });
-  }
-});
-
-// POST /api/sobre/stats - Criar nova estat√≠stica
-app.post('/api/sobre/stats', async (req, res) => {
-  try {
-    const { title, value, icon, order_index } = req.body;
-    const id = require('crypto').randomUUID();
-
-    await pool.execute(`
-      INSERT INTO company_stats (id, title, value, icon, order_index, is_active)
-      VALUES (?, ?, ?, ?, ?, TRUE)
-    `, [id, title, value, icon, order_index || 0]);
-
-    res.json({ success: true, id, message: 'Estat√≠stica criada com sucesso' });
-  } catch (error) {
-    console.error('‚ùå Erro ao criar estat√≠stica:', error);
-    res.status(500).json({ error: 'Erro interno do servidor' });
-  }
-});
-
-// PUT /api/sobre/stats/:id - Atualizar estat√≠stica
-app.put('/api/sobre/stats/:id', async (req, res) => {
-  try {
-    const { id } = req.params;
-    const { title, value, icon, order_index, is_active } = req.body;
-
-    await pool.execute(`
-      UPDATE company_stats 
-      SET title = ?, value = ?, icon = ?, order_index = ?, is_active = ?
-      WHERE id = ?
-    `, [title, value, icon, order_index || 0, is_active !== false, id]);
-
-    res.json({ success: true, message: 'Estat√≠stica atualizada com sucesso' });
-  } catch (error) {
-    console.error('‚ùå Erro ao atualizar estat√≠stica:', error);
-    res.status(500).json({ error: 'Erro interno do servidor' });
-  }
-});
-
-// DELETE /api/sobre/stats/:id - Deletar estat√≠stica
-app.delete('/api/sobre/stats/:id', async (req, res) => {
-  try {
-    const { id } = req.params;
-
-    await pool.execute('DELETE FROM company_stats WHERE id = ?', [id]);
-
-    res.json({ success: true, message: 'Estat√≠stica deletada com sucesso' });
-  } catch (error) {
-    console.error('‚ùå Erro ao deletar estat√≠stica:', error);
-    res.status(500).json({ error: 'Erro interno do servidor' });
-  }
-});
-
-// GET /api/sobre/contact - Buscar informa√ß√µes de contato
-app.get('/api/sobre/contact', async (req, res) => {
-  try {
-    const [rows] = await pool.execute(`
-      SELECT * FROM contact_info 
-      WHERE is_active = TRUE 
-      ORDER BY order_index ASC, created_at ASC
-    `);
-    res.json(rows);
-  } catch (error) {
-    console.error('‚ùå Erro ao buscar informa√ß√µes de contato:', error);
-    res.status(500).json({ error: 'Erro interno do servidor' });
-  }
-});
-
-// POST /api/sobre/contact - Criar nova informa√ß√£o de contato
-app.post('/api/sobre/contact', async (req, res) => {
-  try {
-    const { type, title, value, icon, order_index } = req.body;
-    const id = require('crypto').randomUUID();
-
-    await pool.execute(`
-      INSERT INTO contact_info (id, type, title, value, icon, order_index, is_active)
-      VALUES (?, ?, ?, ?, ?, ?, TRUE)
-    `, [id, type, title, value, icon, order_index || 0]);
-
-    res.json({ success: true, id, message: 'Informa√ß√£o de contato criada com sucesso' });
-  } catch (error) {
-    console.error('‚ùå Erro ao criar informa√ß√£o de contato:', error);
-    res.status(500).json({ error: 'Erro interno do servidor' });
-  }
-});
-
-// PUT /api/sobre/contact/:id - Atualizar informa√ß√£o de contato
-app.put('/api/sobre/contact/:id', async (req, res) => {
-  try {
-    const { id } = req.params;
-    const { type, title, value, icon, order_index, is_active } = req.body;
-
-    await pool.execute(`
-      UPDATE contact_info 
-      SET type = ?, title = ?, value = ?, icon = ?, order_index = ?, is_active = ?
-      WHERE id = ?
-    `, [type, title, value, icon, order_index || 0, is_active !== false, id]);
-
-    res.json({ success: true, message: 'Informa√ß√£o de contato atualizada com sucesso' });
-  } catch (error) {
-    console.error('‚ùå Erro ao atualizar informa√ß√£o de contato:', error);
-    res.status(500).json({ error: 'Erro interno do servidor' });
-  }
-});
-
-// DELETE /api/sobre/contact/:id - Deletar informa√ß√£o de contato
-app.delete('/api/sobre/contact/:id', async (req, res) => {
-  try {
-    const { id } = req.params;
-
-    await pool.execute('DELETE FROM contact_info WHERE id = ?', [id]);
-
-    res.json({ success: true, message: 'Informa√ß√£o de contato deletada com sucesso' });
-  } catch (error) {
-    console.error('‚ùå Erro ao deletar informa√ß√£o de contato:', error);
-    res.status(500).json({ error: 'Erro interno do servidor' });
-  }
-});
-
-// ===== UPLOAD DE IMAGENS PARA P√ÅGINA SOBRE =====
-
-// Upload de imagem geral para p√°gina sobre
-app.post('/api/sobre/upload-image', upload.single('image'), async (req, res) => {
-  try {
-    if (!req.file) {
-      return res.status(400).json({ error: 'Nenhuma imagem foi enviada' });
-    }
-
-    const imageUrl = `/lovable-uploads/${req.file.filename}`;
-    const fullUrl = getPublicUrl(req, imageUrl);
-
-    console.log(`‚úÖ Imagem da p√°gina sobre enviada: ${req.file.filename}`);
-
-    res.json({
-      success: true,
-      imageUrl: imageUrl,
-      fullUrl: fullUrl,
-      filename: req.file.filename
-    });
-  } catch (error) {
-    console.error('‚ùå Erro no upload de imagem da p√°gina sobre:', error);
-    res.status(500).json({ error: 'Erro interno do servidor' });
-  }
-});
-
-// Upload de imagem para membro da equipe
-app.post('/api/sobre/team/:id/image', upload.single('image'), async (req, res) => {
-  try {
-    const { id } = req.params;
-    if (!req.file) return res.status(400).json({ error: 'Nenhuma imagem foi enviada' });
-
-    const imageUrl = `/lovable-uploads/${req.file.filename}`;
-    const fullUrl = getPublicUrl(req, imageUrl);
-
-    // Atualizar o registro do membro da equipe
-    await pool.execute(
-      'UPDATE team_members SET image_url = ? WHERE id = ?',
-      [fullUrl, id]
-    );
-
-    console.log(`‚úÖ Imagem do membro da equipe ${id} atualizada: ${req.file.filename}`);
-
-    res.json({
-      success: true,
-      imageUrl: imageUrl,
-      fullUrl: fullUrl,
-      filename: req.file.filename
-    });
-  } catch (error) {
-    console.error('‚ùå Erro no upload de imagem do membro da equipe:', error);
-    res.status(500).json({ error: 'Erro interno do servidor' });
-  }
-});
-
-app.get('/api/health', async (req, res) => {
-  try {
-    await pool.execute('SELECT 1');
-    res.json({ status: 'healthy', database: 'connected' });
-  } catch (error) {
-    res.status(500).json({ status: 'unhealthy', database: 'disconnected', error: error.message });
-  }
-});
-
-// Sitemap.xml din√¢mico
-const { generateSitemap } = require('../config/sitemapGenerator.cjs');
-
-app.get('/sitemap.xml', async (req, res) => {
-  try {
-    const sitemapXml = await generateSitemap(pool);
-    res.header('Content-Type', 'application/xml');
-    res.header('Cache-Control', 'public, max-age=86400'); // Cache de 24 horas
-    res.send(sitemapXml);
-    logger.info('Sitemap gerado com sucesso');
-  } catch (error) {
-    logger.error('Erro ao gerar sitemap:', error);
-    res.status(500).send('<?xml version="1.0" encoding="UTF-8"?><urlset xmlns="http://www.sitemaps.org/schemas/sitemap/0.9"></urlset>');
-  }
-});
-
-// ==================== PUSH NOTIFICATIONS API ====================
-
-// Obter VAPID public key
-app.get('/api/push/vapid-public-key', (req, res) => {
-  const publicKey = pushNotifications.getPublicKey();
-  if (!publicKey) {
-    return res.status(503).json({ error: 'Push notifications n√£o configuradas' });
-  }
-  res.json({ publicKey });
-});
-
-// Inscrever em push notifications
-app.post('/api/push/subscribe', async (req, res) => {
-  try {
-    const { subscription } = req.body;
-    const userId = req.cookies?.user_id || null; // Ajustar conforme seu sistema de auth
-    const id = crypto.randomUUID();
-
-    // Extrair keys da subscription
-    const endpoint = subscription.endpoint;
-    const p256dhKey = subscription.keys.p256dh;
-    const authKey = subscription.keys.auth;
-
-    // Detectar tipo de device
-    const userAgent = req.headers['user-agent'] || '';
-    let deviceType = 'desktop';
-    if (/mobile/i.test(userAgent)) deviceType = 'mobile';
-    if (/tablet|ipad/i.test(userAgent)) deviceType = 'tablet';
-
-    // Salvar no banco
-    await pool.execute(`
-      INSERT INTO push_subscriptions (id, user_id, endpoint, p256dh_key, auth_key, user_agent, device_type)
-      VALUES (?, ?, ?, ?, ?, ?, ?)
-      ON DUPLICATE KEY UPDATE 
-        p256dh_key = VALUES(p256dh_key),
-        auth_key = VALUES(auth_key),
-        is_active = TRUE,
-        updated_at = NOW()
-    `, [id, userId, endpoint, p256dhKey, authKey, userAgent, deviceType]);
-
-    logger.info('Push subscription salva', { userId, deviceType });
-    res.json({ success: true, id });
-  } catch (error) {
-    logger.logError(error, req);
-    res.status(500).json({ error: 'Erro ao salvar subscription' });
-  }
-});
-
-// Desinscrever
-app.post('/api/push/unsubscribe', async (req, res) => {
-  try {
-    const { endpoint } = req.body;
-
-    await pool.execute(
-      'UPDATE push_subscriptions SET is_active = FALSE WHERE endpoint = ?',
-      [endpoint]
-    );
-
-    logger.info('Push subscription desativada', { endpoint: endpoint.substring(0, 50) });
-    res.json({ success: true });
-  } catch (error) {
-    logger.logError(error, req);
-    res.status(500).json({ error: 'Erro ao desinscrever' });
-  }
-});
-
-// Enviar notifica√ß√£o de teste
-app.post('/api/push/test', async (req, res) => {
-  try {
-    const { userId } = req.body;
-
-    // Buscar subscription do usu√°rio
-    const [subs] = await pool.execute(
-      'SELECT endpoint, p256dh_key, auth_key FROM push_subscriptions WHERE user_id = ? AND is_active = TRUE LIMIT 1',
-      [userId]
-    );
-
-    if (subs.length === 0) {
-      return res.status(404).json({ error: 'Nenhuma subscription ativa encontrada' });
-    }
-
-    const sub = subs[0];
-    const subscription = {
-      endpoint: sub.endpoint,
-      keys: {
-        p256dh: sub.p256dh_key,
-        auth: sub.auth_key,
-      },
-    };
-
-    const payload = {
-      title: 'MuhlStore - Notifica√ß√£o de Teste! üéâ',
-      body: 'Suas notifica√ß√µes est√£o funcionando perfeitamente!',
-      icon: '/icon-192x192.png',
-      badge: '/icon-72x72.png',
-      data: { url: '/' },
-    };
-
-    const result = await pushNotifications.sendNotification(subscription, payload);
-
-    if (result.success) {
-      res.json({ success: true, message: 'Notifica√ß√£o de teste enviada!' });
-    } else {
-      res.status(500).json({ success: false, error: result.error });
-    }
-  } catch (error) {
-    logger.logError(error, req);
-    res.status(500).json({ error: 'Erro ao enviar notifica√ß√£o de teste' });
-  }
-});
-
-// Enviar notifica√ß√£o em massa (campanhas)
-app.post('/api/push/campaign', async (req, res) => {
-  try {
-    const { title, body, targetAudience, targetUrl } = req.body;
-
-    // Buscar subscriptions ativas
-    let query = 'SELECT id, endpoint, p256dh_key, auth_key FROM push_subscriptions WHERE is_active = TRUE';
-
-    if (targetAudience === 'mobile') {
-      query += " AND device_type = 'mobile'";
-    } else if (targetAudience === 'desktop') {
-      query += " AND device_type = 'desktop'";
-    }
-
-    const [subs] = await pool.execute(query);
-
-    if (subs.length === 0) {
-      return res.status(404).json({ error: 'Nenhuma subscription ativa' });
-    }
-
-    const subscriptions = subs.map(s => ({
-      endpoint: s.endpoint,
-      keys: {
-        p256dh: s.p256dh_key,
-        auth: s.auth_key,
-      },
-    }));
-
-    const payload = {
-      title,
-      body,
-      icon: '/icon-192x192.png',
-      badge: '/icon-72x72.png',
-      data: { url: targetUrl || '/' },
-    };
-
-    const result = await pushNotifications.sendToMultiple(subscriptions, payload);
-
-    logger.info('Campanha de push enviada', result);
-    res.json({ success: true, ...result });
-  } catch (error) {
-    logger.logError(error, req);
-    res.status(500).json({ error: 'Erro ao enviar campanha' });
-  }
-});
-
-// ==================== CUSTOMERS API (COMPLETO E AVAN√áADO) ====================
-
-// Estat√≠sticas do usu√°rio logado (current user stats)
-app.get('/api/customers/current/stats', highFrequencyLimiter, async (req, res) => {
-  try {
-    console.log('üìä GET /api/customers/current/stats');
-
-    // Tentar obter o usu√°rio da sess√£o
-    let userId = null;
-    let userEmail = null;
-
-    // 1. Tentar via session_id usando nome completo do banco
-    const sessionId = req.cookies?.session_id;
-    if (sessionId) {
-      try {
-        const [sessions] = await pool.execute('SELECT * FROM `rare_toy_companion`.`sessions` WHERE id = ?', [sessionId]);
-        if (sessions && sessions[0]) {
-          userId = sessions[0].user_id;
-          console.log('‚úÖ Usu√°rio identificado via session_id:', userId);
-        }
-      } catch (e) {
-        console.log('‚ö†Ô∏è Erro ao verificar sess√£o:', e.message);
-      }
-    }
-
-    // 2. Tentar via cart_id usando nome completo do banco
-    if (!userId) {
-      const cartId = req.cookies?.cart_id;
-      if (cartId) {
-        try {
-          const [carts] = await pool.execute('SELECT * FROM `rare_toy_companion`.`carts` WHERE id = ?', [cartId]);
-          if (carts && carts[0] && carts[0].user_id) {
-            userId = carts[0].user_id;
-            console.log('‚úÖ Usu√°rio identificado via cart_id:', userId);
-          }
-        } catch (e) {
-          console.log('‚ö†Ô∏è Erro ao buscar usu√°rio pelo cart_id:', e.message);
-        }
-      }
-    }
-
-    // 3. Tentar via Authorization header (JWT)
-    if (!userId) {
-      const authHeader = req.headers.authorization;
-      if (authHeader?.startsWith('Bearer ')) {
-        try {
-          const token = authHeader.split(' ')[1];
-          // Decodificar token JWT (implementar conforme necess√°rio)
-          console.log('üîë Token JWT recebido:', token.substring(0, 20) + '...');
-        } catch (e) {
-          console.log('‚ö†Ô∏è Erro ao processar JWT:', e.message);
-        }
-      }
-    }
-
-    // 4. N√ÉO USAR FALLBACKS - Cada usu√°rio deve ter sua pr√≥pria sess√£o
-    // Removido fallbacks que permitiam acesso a dados de outros usu√°rios
-
-    if (!userId) {
-      console.log('‚ùå Nenhum usu√°rio identificado');
-      return res.status(401).json({
-        error: 'N√£o autorizado - usu√°rio n√£o identificado',
-        debug: {
-          hasSessionId: !!sessionId,
-          hasCartId: !!req.cookies?.cart_id,
-          hasAuthHeader: !!req.headers.authorization,
-          environment: process.env.NODE_ENV
-        },
-        totalPedidos: 0,
-        pedidosPendentes: 0,
-        totalGasto: 0,
-        favoritos: 0,
-        enderecos: 0,
-        cupons: 0
-      });
-    }
-
-    // Buscar estat√≠sticas do usu√°rio
-    const [orders] = await pool.execute('SELECT COUNT(*) as total FROM orders WHERE user_id = ?', [userId]);
-    const [pendingOrders] = await pool.execute('SELECT COUNT(*) as total FROM orders WHERE user_id = ? AND status IN ("pending", "processing")', [userId]);
-    const [totalSpent] = await pool.execute('SELECT SUM(total) as total FROM orders WHERE user_id = ? AND status != "cancelled"', [userId]);
-    // Buscar email do usu√°rio para favoritos
-    if (!userEmail) {
-      const [userEmailResult] = await pool.execute('SELECT email FROM users WHERE id = ?', [userId]);
-      userEmail = userEmailResult[0]?.email || userId; // Fallback para userId se for email
-    }
-
-    const [favorites] = await pool.execute('SELECT COUNT(*) as total FROM favorites WHERE user_email = ?', [userEmail]);
-    const [addresses] = await pool.execute('SELECT COUNT(*) as total FROM customer_addresses WHERE customer_id = ?', [userId]);
-    // CORRIGIDO: customer_coupons n√£o tem 'usado', usa 'status' ('active', 'used', 'expired')
-    // E n√£o tem 'data_fim', usa 'expires_at'
-    const [coupons] = await pool.execute('SELECT COUNT(*) as total FROM customer_coupons WHERE customer_id = ? AND status = "active" AND expires_at >= NOW()', [userId]);
-
-    const stats = {
-      totalPedidos: orders[0]?.total || 0,
-      pedidosPendentes: pendingOrders[0]?.total || 0,
-      totalGasto: parseFloat(totalSpent[0]?.total || 0),
-      favoritos: favorites[0]?.total || 0,
-      enderecos: addresses[0]?.total || 0,
-      cupons: coupons[0]?.total || 0
-    };
-
-    console.log('‚úÖ Estat√≠sticas do usu√°rio calculadas:', stats);
-    res.json(stats);
-  } catch (error) {
-    console.error('‚ùå Erro ao buscar estat√≠sticas do usu√°rio:', error);
-    res.status(500).json({
-      error: 'Erro ao buscar estat√≠sticas',
-      totalPedidos: 0,
-      pedidosPendentes: 0,
-      totalGasto: 0,
-      favoritos: 0,
-      enderecos: 0,
-      cupons: 0
-    });
-  }
-});
-
-// Estat√≠sticas gerais de clientes (DEVE VIR ANTES de :userId)
-app.get('/api/customers/stats', highFrequencyLimiter, async (req, res) => {
-  try {
-    console.log('üìä GET /api/customers/stats');
-
-    // Buscar estat√≠sticas gerais
-    const [totalCustomers] = await pool.execute('SELECT COUNT(*) as total FROM customers');
-    const [totalOrders] = await pool.execute('SELECT COUNT(*) as total FROM orders');
-    const [totalRevenue] = await pool.execute('SELECT SUM(total) as total FROM orders WHERE status != "cancelled"');
-    const [avgOrderValue] = await pool.execute('SELECT AVG(total) as average FROM orders WHERE status != "cancelled"');
-
-    const stats = {
-      totalCustomers: totalCustomers[0]?.total || 0,
-      totalOrders: totalOrders[0]?.total || 0,
-      totalRevenue: parseFloat(totalRevenue[0]?.total || 0),
-      averageOrderValue: parseFloat(avgOrderValue[0]?.average || 0)
-    };
-
-    console.log('‚úÖ Estat√≠sticas gerais calculadas:', stats);
-    res.json(stats);
-  } catch (error) {
-    console.error('‚ùå Erro ao buscar estat√≠sticas gerais:', error);
-    res.status(500).json({
-      error: 'Erro ao buscar estat√≠sticas',
-      totalCustomers: 0,
-      totalOrders: 0,
-      totalRevenue: 0,
-      averageOrderValue: 0
-    });
-  }
-});
-
-// Buscar dados completos do cliente
-app.get('/api/customers/:userId', async (req, res) => {
-  try {
-    let { userId } = req.params;
-    console.log(`üë§ GET /api/customers/${userId}`);
-
-    let customer = null;
-    let actualUserId = userId;
-    let searchedIn = [];
-
-    // Se userId parece ser email, buscar o ID primeiro
-    if (userId.includes('@')) {
-      console.log('üîç Buscando ID por email:', userId);
-      try {
-        const [userRows] = await pool.execute('SELECT id FROM `rare_toy_companion`.`users` WHERE email = ? LIMIT 1', [userId]);
-        if (userRows && userRows.length > 0) {
-          actualUserId = userRows[0].id;
-          searchedIn.push('users (por email)');
-          console.log('‚úÖ ID encontrado em users:', actualUserId);
-        } else {
-          const [customerRows] = await pool.execute('SELECT id FROM `rare_toy_companion`.`customers` WHERE email = ? LIMIT 1', [userId]);
-          if (customerRows && customerRows.length > 0) {
-            actualUserId = customerRows[0].id;
-            searchedIn.push('customers (por email)');
-            console.log('‚úÖ ID encontrado em customers:', actualUserId);
-          } else {
-            console.log('‚ùå Email n√£o encontrado em users nem customers:', userId);
-            return res.status(404).json({
-              error: 'Cliente n√£o encontrado',
-              message: 'Nenhum cliente encontrado com este email.',
-              searchedIn: ['users', 'customers']
-            });
-          }
-        }
-      } catch (e) {
-        console.error('‚ö†Ô∏è Erro ao buscar usu√°rio por email:', e);
-        return res.status(500).json({ error: 'Erro ao buscar cliente', message: e.message });
-      }
-    }
-
-    // Tentar buscar em users primeiro
-    try {
-      console.log('üîç Buscando em users com ID:', actualUserId);
-      const [users] = await pool.execute(`
-      SELECT 
-        id, nome, email, telefone, avatar_url, created_at,
-          (SELECT COUNT(*) FROM \`rare_toy_companion\`.\`orders\` WHERE user_id = users.id) as total_orders,
-          (SELECT COALESCE(SUM(total), 0) FROM \`rare_toy_companion\`.\`orders\` WHERE user_id = users.id AND status != 'cancelled') as total_spent
-        FROM \`rare_toy_companion\`.\`users\`
-      WHERE id = ?
-      `, [actualUserId]);
-
-      if (users && users.length > 0) {
-        customer = users[0];
-        searchedIn.push('users');
-        console.log('‚úÖ Cliente encontrado em users:', customer.email);
-      } else {
-        console.log('‚ö†Ô∏è Cliente n√£o encontrado em users com ID:', actualUserId);
-      }
-    } catch (e) {
-      console.error('‚ö†Ô∏è Erro ao buscar em users:', e.message);
-      console.error('‚ö†Ô∏è Stack:', e.stack);
-    }
-
-    // Se n√£o encontrou em users, tentar em customers (sem avatar_url pois n√£o existe nessa tabela)
-    if (!customer) {
-      try {
-        console.log('üîç Buscando em customers com ID:', actualUserId);
-        const [customers] = await pool.execute(`
-          SELECT 
-            id, nome, email, telefone, NULL as avatar_url, 
-            COALESCE((SELECT MIN(created_at) FROM \`rare_toy_companion\`.\`orders\` WHERE user_id = customers.id), NOW()) as created_at,
-            (SELECT COUNT(*) FROM \`rare_toy_companion\`.\`orders\` WHERE user_id = customers.id) as total_orders,
-            (SELECT COALESCE(SUM(total), 0) FROM \`rare_toy_companion\`.\`orders\` WHERE user_id = customers.id AND status != 'cancelled') as total_spent
-          FROM \`rare_toy_companion\`.\`customers\`
-          WHERE id = ?
-        `, [actualUserId]);
-
-        if (customers && customers.length > 0) {
-          customer = customers[0];
-          searchedIn.push('customers');
-          console.log('‚úÖ Cliente encontrado em customers:', customer.email);
-        } else {
-          console.log('‚ö†Ô∏è Cliente n√£o encontrado em customers com ID:', actualUserId);
-        }
-      } catch (e) {
-        console.error('‚ö†Ô∏è Erro ao buscar em customers:', e);
-        console.error('‚ö†Ô∏è Detalhes do erro:', e.message, e.code);
-        console.error('‚ö†Ô∏è Stack:', e.stack);
-      }
-    }
-
-    if (!customer) {
-      console.log('‚ùå Cliente n√£o encontrado ap√≥s buscar em users e customers. ID:', actualUserId);
-      // Verificar se o ID existe em alguma tabela (para debug)
-      try {
-        const [checkUsers] = await pool.execute('SELECT COUNT(*) as count FROM users WHERE id = ?', [actualUserId]);
-        const [checkCustomers] = await pool.execute('SELECT COUNT(*) as count FROM customers WHERE id = ?', [actualUserId]);
-        console.log('üîç Verifica√ß√£o: users count =', checkUsers[0]?.count, ', customers count =', checkCustomers[0]?.count);
-      } catch (e) {
-        console.error('‚ö†Ô∏è Erro ao verificar exist√™ncia:', e.message);
-      }
-
-      return res.status(404).json({
-        error: 'Cliente n√£o encontrado',
-        message: 'Nenhum cliente encontrado com este ID.',
-        searchedIn: searchedIn.length > 0 ? searchedIn : ['users', 'customers'],
-        userId: actualUserId
-      });
-    }
-
-    // Calcular pontos de fidelidade
-    customer.loyalty_points = Math.floor(Number(customer.total_spent || 0) / 10);
-
-    // Adicionar campos vazios para compatibilidade
-    customer.cpf = customer.cpf || null;
-    customer.data_nascimento = customer.data_nascimento || null;
-    customer.bio = customer.bio || null;
-
-    console.log(`‚úÖ Cliente encontrado: ${customer.email}`);
-    res.json(customer);
-  } catch (error) {
-    console.error('‚ùå Erro ao buscar cliente:', error);
-    console.error('‚ùå Stack:', error.stack);
-    logger.logError(error, req);
-    res.status(500).json({
-      error: 'Erro ao buscar cliente',
-      message: error.message
-    });
-  }
-});
-
-// Atualizar dados do cliente
-app.put('/api/customers/:userId', async (req, res) => {
-  try {
-    const { userId } = req.params;
-    const { nome, telefone, avatar_url } = req.body;
-
-    await pool.execute(`
-      UPDATE users
-      SET nome = ?, telefone = ?, avatar_url = ?
-      WHERE id = ?
-    `, [nome, telefone || null, avatar_url || null, userId]);
-
-    logger.info('Cliente atualizado', { userId, nome });
-    res.json({ success: true });
-  } catch (error) {
-    logger.logError(error, req);
-    res.status(500).json({ error: 'Erro ao atualizar cliente' });
-  }
-});
-
-// Estat√≠sticas do cliente (dashboard)
-app.get('/api/customers/:userId/stats', highFrequencyLimiter, async (req, res) => {
-  try {
-    let { userId } = req.params;
-    let userEmail = userId; // Preservar email original
-
-    // Se userId parece ser email, buscar o ID do usu√°rio
-    if (userId.includes('@')) {
-      try {
-        // Tentar buscar em users primeiro
-        const [user] = await pool.execute('SELECT id, email FROM users WHERE email = ? LIMIT 1', [userId]);
-        if (user && user[0]) {
-          userId = user[0].id;
-          userEmail = user[0].email || userId;
-        } else {
-          // Tentar buscar em customers
-          const [customer] = await pool.execute('SELECT id, email FROM customers WHERE email = ? LIMIT 1', [userId]);
-          if (customer && customer[0]) {
-            userId = customer[0].id;
-            userEmail = customer[0].email || userId;
-          } else {
-            // Se n√£o encontrou, retornar zeros mas n√£o erro
-            console.log(`‚ö†Ô∏è Usu√°rio n√£o encontrado para email: ${userId}`);
-            return res.json({
-              totalOrders: 0,
-              totalSpent: 0,
-              favoriteProducts: 0,
-              lastOrderDate: null,
-              loyaltyPoints: 0,
-              nextReward: 100
-            });
-          }
-        }
-      } catch (e) {
-        console.error('‚ö†Ô∏è Erro ao buscar usu√°rio por email:', e);
-        return res.status(500).json({
-          error: 'Erro ao buscar usu√°rio',
-          totalOrders: 0,
-          totalSpent: 0,
-          favoriteProducts: 0,
-          lastOrderDate: null,
-          loyaltyPoints: 0,
-          nextReward: 100
-        });
-      }
-    } else {
-      // Se √© ID, buscar email tamb√©m
-      try {
-        const [userEmailResult] = await pool.execute('SELECT email FROM users WHERE id = ? LIMIT 1', [userId]);
-        if (userEmailResult && userEmailResult[0]) {
-          userEmail = userEmailResult[0].email || userId;
-        } else {
-          const [customerEmailResult] = await pool.execute('SELECT email FROM customers WHERE id = ? LIMIT 1', [userId]);
-          if (customerEmailResult && customerEmailResult[0]) {
-            userEmail = customerEmailResult[0].email || userId;
-          }
-        }
-      } catch (e) {
-        console.log('‚ö†Ô∏è Erro ao buscar email do usu√°rio:', e.message);
-        // Continuar mesmo sem email
-      }
-    }
-
-    // Buscar estat√≠sticas de pedidos
-    // CORRIGIDO: orders n√£o tem email, apenas user_id
-    // Se userId √© email, j√° foi convertido para ID antes
-    const [orderStats] = await pool.execute(`
-      SELECT 
-        COUNT(*) as total_orders,
-        COALESCE(SUM(total), 0) as total_spent,
-        MAX(created_at) as last_order_date
-      FROM orders
-      WHERE user_id = ?
-    `, [userId]);
-
-    // Buscar favoritos (usar tabela favorites com email do usu√°rio)
-    let favoriteCount = 0;
-    try {
-      const [favStats] = await pool.execute(`
-      SELECT COUNT(*) as favorite_count
-      FROM favorites
-      WHERE user_email = ?
-      `, [userEmail]);
-      favoriteCount = Number(favStats[0]?.favorite_count || 0);
-    } catch (e) {
-      console.log('‚ö†Ô∏è Erro ao buscar favoritos:', e.message);
-      // Continuar mesmo sem favoritos
-    }
-
-    // Calcular pontos de fidelidade (1 ponto a cada R$ 10 gastos)
-    const totalSpent = Number(orderStats[0]?.total_spent || 0);
-    const loyaltyPoints = Math.floor(totalSpent / 10);
-    const nextReward = 100; // Pr√≥xima recompensa em 100 pontos
-
-    res.json({
-      totalOrders: Number(orderStats[0]?.total_orders || 0),
-      totalSpent: totalSpent,
-      favoriteProducts: favoriteCount,
-      lastOrderDate: orderStats[0]?.last_order_date || null,
-      loyaltyPoints,
-      nextReward,
-    });
-  } catch (error) {
-    console.error('‚ùå Erro ao buscar estat√≠sticas do cliente:', error);
-    logger.logError(error, req);
-    res.status(500).json({
-      error: 'Erro ao buscar estat√≠sticas do cliente',
-      message: error.message,
-      totalOrders: 0,
-      totalSpent: 0,
-      favoriteProducts: 0,
-      lastOrderDate: null,
-      loyaltyPoints: 0,
-      nextReward: 100
-    });
-  }
-});
-
-// Estat√≠sticas de pedidos do cliente (para aba pedidos)
-app.get('/api/customers/:userId/order-stats', async (req, res) => {
-  try {
-    const { userId } = req.params;
-
-    const [stats] = await pool.execute(`
-      SELECT 
-        COUNT(*) as total,
-        SUM(CASE WHEN status = 'pending' THEN 1 ELSE 0 END) as pending,
-        SUM(CASE WHEN status = 'delivered' THEN 1 ELSE 0 END) as delivered,
-        COALESCE(SUM(CASE WHEN status != 'cancelled' THEN total ELSE 0 END), 0) as total_spent,
-        SUM(CASE WHEN created_at >= DATE_SUB(NOW(), INTERVAL 1 MONTH) THEN 1 ELSE 0 END) as last_month
-      FROM orders
-      WHERE customer_id = ? OR user_id = ?
-    `, [userId, userId]);
-
-    res.json({
-      total: Number(stats[0].total) || 0,
-      pending: Number(stats[0].pending) || 0,
-      delivered: Number(stats[0].delivered) || 0,
-      totalSpent: Number(stats[0].total_spent) || 0,
-      lastMonth: Number(stats[0].last_month) || 0,
-    });
-  } catch (error) {
-    logger.logError(error, req);
-    res.status(500).json({ error: 'Erro ao buscar estat√≠sticas de pedidos' });
-  }
-});
-
-// ==================== ORDER STATUS API ====================
-
-// Endpoint para verificar status do pedido
-app.get('/api/orders/:orderId/status', async (req, res) => {
-  try {
-    const { orderId } = req.params;
-    console.log(`üìä GET /api/orders/${orderId}/status`);
-
-    // Buscar status do pedido
-    const [orders] = await pool.execute(`
-      SELECT 
-        id,
-        status,
-        payment_status,
-        payment_method,
-        total,
-        created_at,
-        updated_at
-      FROM orders 
-      WHERE id = ?
-    `, [orderId]);
-
-    if (orders.length === 0) {
-      return res.status(404).json({ error: 'Pedido n√£o encontrado' });
-    }
-
-    const order = orders[0];
-    console.log(`‚úÖ Status do pedido encontrado:`, order);
-    res.json(order);
-
-  } catch (error) {
-    console.error('‚ùå Erro ao buscar status do pedido:', error);
-    res.status(500).json({ error: 'Erro ao buscar status do pedido' });
-  }
-});
-
-// ==================== USER STATS API ====================
-
-// Endpoint para estat√≠sticas do usu√°rio
-app.get('/api/user-stats/stats/:userId', async (req, res) => {
-  try {
-    let { userId } = req.params;
-    console.log(`üìä GET /api/user-stats/stats/${userId}`);
-
-    // Se userId parece ser email, buscar o ID do usu√°rio
-    let actualUserId = userId;
-    if (String(userId).includes('@')) {
-      try {
-        // Tentar buscar em users primeiro
-        const [users] = await pool.execute('SELECT id FROM users WHERE email = ? LIMIT 1', [userId]);
-        if (users && users[0] && users[0].id) {
-          actualUserId = users[0].id;
-        } else {
-          // Tentar buscar em customers
-          const [customers] = await pool.execute('SELECT id FROM customers WHERE email = ? LIMIT 1', [userId]);
-          if (customers && customers[0] && customers[0].id) {
-            actualUserId = customers[0].id;
-          } else {
-            // Se n√£o encontrou, retornar zeros mas n√£o erro
-            console.log(`‚ö†Ô∏è Usu√°rio n√£o encontrado para email: ${userId}`);
-            return res.json({
-              total_pedidos: 0,
-              total_gasto: 0,
-              ultimo_pedido: null
-            });
-          }
-        }
-      } catch (e) {
-        console.error('‚ùå Erro ao buscar usu√°rio por email:', e);
-        return res.status(500).json({
-          error: 'Erro ao buscar usu√°rio',
-          total_pedidos: 0,
-          total_gasto: 0,
-          ultimo_pedido: null
-        });
-      }
-    }
-
-    // Buscar estat√≠sticas do usu√°rio
-    // CORRIGIDO: orders n√£o tem customer_id nem email, apenas user_id
-    const [orders] = await pool.execute(`
-      SELECT 
-        COUNT(*) as total_pedidos,
-        COALESCE(SUM(total), 0) as total_gasto,
-        MAX(created_at) as ultimo_pedido
-      FROM orders 
-      WHERE user_id = ?
-    `, [actualUserId]);
-
-    const stats = orders[0] || {
-      total_pedidos: 0,
-      total_gasto: 0,
-      ultimo_pedido: null
-    };
-
-    console.log(`‚úÖ Estat√≠sticas encontradas:`, stats);
-    res.json(stats);
-
-  } catch (error) {
-    console.error('‚ùå Erro ao buscar estat√≠sticas:', error);
-    res.status(500).json({
-      error: 'Erro ao buscar estat√≠sticas',
-      message: error.message,
-      total_pedidos: 0,
-      total_gasto: 0,
-      ultimo_pedido: null
-    });
-  }
-});
-
-// ==================== TESTE E DESENVOLVIMENTO ====================
-
-// Endpoint para criar dados de teste
-app.post('/api/test/create-test-data', async (req, res) => {
-  try {
-    console.log('üß™ Criando dados de teste...');
-
-    // Criar usu√°rio de teste se n√£o existir
-    const testEmail = 'cliente@exemplo.com';
-    const [existingUser] = await pool.execute('SELECT id FROM users WHERE email = ?', [testEmail]);
-
-    let userId;
-    if (existingUser.length === 0) {
-      const [result] = await pool.execute(`
-        INSERT INTO users (email, nome, telefone, created_at) 
-        VALUES (?, 'Cliente Exemplo', '11999999999', NOW())
-      `, [testEmail]);
-      userId = result.insertId;
-    } else {
-      userId = existingUser[0].id;
-    }
-
-    // Criar sess√£o de teste
-    const sessionId = 'test-session-' + Date.now();
-    await pool.execute(`
-      INSERT INTO sessions (id, user_id, expires_at) 
-      VALUES (?, ?, DATE_ADD(NOW(), INTERVAL 1 DAY))
-    `, [sessionId, userId]);
-
-    // Criar endere√ßo de teste
-    const [existingAddress] = await pool.execute('SELECT id FROM customer_addresses WHERE customer_id = ?', [userId]);
-    if (existingAddress.length === 0) {
-      const addressId = uuidv4();
-      await pool.execute(`
-        INSERT INTO customer_addresses 
-        (id, customer_id, nome, rua, numero, complemento, bairro, cidade, estado, cep, tipo, padrao, created_at)
-        VALUES (?, ?, 'Casa', 'Rua das Flores', '123', 'Apto 45', 'Centro', 'S√£o Paulo', 'SP', '01234567', 'casa', 1, NOW())
-      `, [addressId, userId]);
-    }
-
-    res.json({
-      success: true,
-      userId,
-      sessionId,
-      message: 'Dados de teste criados com sucesso!'
-    });
-  } catch (error) {
-    console.error('‚ùå Erro ao criar dados de teste:', error);
-    res.status(500).json({ error: 'Erro interno' });
-  }
-});
-
-// Endpoint para testar com dados de teste
-app.get('/api/test/stats', async (req, res) => {
-  try {
-    const testEmail = 'cliente@exemplo.com';
-    const [user] = await pool.execute('SELECT id FROM users WHERE email = ?', [testEmail]);
-
-    if (user.length === 0) {
-      return res.status(404).json({ error: 'Usu√°rio de teste n√£o encontrado' });
-    }
-
-    const userId = user[0].id;
-
-    // Buscar estat√≠sticas
-    const [orders] = await pool.execute('SELECT COUNT(*) as total FROM orders WHERE user_id = ?', [userId]);
-    const [pendingOrders] = await pool.execute('SELECT COUNT(*) as total FROM orders WHERE user_id = ? AND status IN ("pending", "processing")', [userId]);
-    const [totalSpent] = await pool.execute('SELECT SUM(total) as total FROM orders WHERE user_id = ? AND status != "cancelled"', [userId]);
-    const [addresses] = await pool.execute('SELECT COUNT(*) as total FROM customer_addresses WHERE customer_id = ?', [userId]);
-
-    const stats = {
-      totalPedidos: orders[0]?.total || 0,
-      pedidosPendentes: pendingOrders[0]?.total || 0,
-      totalGasto: parseFloat(totalSpent[0]?.total || 0),
-      favoritos: 0,
-      enderecos: addresses[0]?.total || 0,
-      cupons: 0
-    };
-
-    res.json(stats);
-  } catch (error) {
-    console.error('‚ùå Erro ao buscar estat√≠sticas de teste:', error);
-    res.status(500).json({ error: 'Erro interno' });
-  }
-});
-
-// ==================== ADDRESSES API (ENDERE√áOS M√öLTIPLOS) ====================
-
-// Listar endere√ßos do cliente
-app.get('/api/customers/addresses', async (req, res) => {
-  try {
-    console.log('üè† GET /api/customers/addresses');
-
-    // Obter usu√°rio da sess√£o (mesma l√≥gica do stats)
-    let userId = null;
-    const sessionId = req.cookies?.session_id;
-    if (sessionId) {
-      try {
-        const [sessions] = await pool.execute('SELECT * FROM sessions WHERE id = ?', [sessionId]);
-        if (sessions && sessions[0] && sessions[0].user_email) {
-          const userEmail = sessions[0].user_email;
-          console.log('üë§ Usu√°rio logado via sess√£o:', userEmail);
-
-          // Buscar o user_id na tabela customers baseado no email
-          const [customers] = await pool.execute('SELECT id FROM customers WHERE email = ?', [userEmail]);
-          if (customers && customers[0]) {
-            userId = customers[0].id;
-            console.log('‚úÖ User ID encontrado:', userId);
-          } else {
-            console.log('‚ö†Ô∏è Cliente n√£o encontrado para email:', userEmail);
-          }
-        }
-      } catch (e) {
-        console.log('‚ö†Ô∏è Erro ao verificar sess√£o:', e.message);
-      }
-    }
-
-    // N√ÉO USAR FALLBACKS - Cada usu√°rio deve ter sua pr√≥pria sess√£o
-
-    if (!userId) {
-      return res.status(401).json({ error: 'N√£o autorizado' });
-    }
-
-    // Buscar endere√ßos
-    const [addresses] = await pool.execute(`
-      SELECT * FROM customer_addresses 
-      WHERE customer_id = ? 
-      ORDER BY padrao DESC, created_at DESC
-    `, [userId]);
-
-    res.json(addresses);
-  } catch (error) {
-    console.error('‚ùå Erro ao buscar endere√ßos:', error);
-    res.status(500).json({ error: 'Erro interno' });
-  }
-});
-
-// Criar novo endere√ßo
-app.post('/api/customers/addresses', async (req, res) => {
-  try {
-    console.log('üè† POST /api/customers/addresses');
-
-    const { nome, rua, numero, complemento, bairro, cidade, estado, cep, tipo, is_default } = req.body;
-
-    // Validar dados obrigat√≥rios
-    if (!nome || !rua || !cidade || !estado || !cep) {
-      return res.status(400).json({ error: 'Dados obrigat√≥rios n√£o fornecidos' });
-    }
-
-    // Obter usu√°rio da sess√£o
-    let userId = null;
-    const sessionId = req.cookies?.session_id;
-    if (sessionId) {
-      try {
-        const [sessions] = await pool.execute('SELECT * FROM sessions WHERE id = ?', [sessionId]);
-        if (sessions && sessions[0] && sessions[0].user_email) {
-          const userEmail = sessions[0].user_email;
-          console.log('üë§ Usu√°rio logado via sess√£o:', userEmail);
-
-          // Buscar o user_id na tabela customers baseado no email
-          const [customers] = await pool.execute('SELECT id FROM customers WHERE email = ?', [userEmail]);
-          if (customers && customers[0]) {
-            userId = customers[0].id;
-            console.log('‚úÖ User ID encontrado:', userId);
-          } else {
-            console.log('‚ö†Ô∏è Cliente n√£o encontrado para email:', userEmail);
-          }
-        }
-      } catch (e) {
-        console.log('‚ö†Ô∏è Erro ao verificar sess√£o:', e.message);
-      }
-    }
-
-    // N√ÉO USAR FALLBACKS - Cada usu√°rio deve ter sua pr√≥pria sess√£o
-
-    if (!userId) {
-      return res.status(401).json({ error: 'N√£o autorizado' });
-    }
-
-    // Se for endere√ßo padr√£o, remover padr√£o dos outros
-    if (is_default) {
-      await pool.execute('UPDATE customer_addresses SET padrao = 0 WHERE customer_id = ?', [userId]);
-    }
-
-    // Inserir novo endere√ßo
-    const [result] = await pool.execute(`
-      INSERT INTO customer_addresses 
-      (customer_id, nome, rua, numero, complemento, bairro, cidade, estado, cep, tipo, padrao, created_at)
-      VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, NOW())
-    `, [userId, nome, rua, numero, complemento, bairro, cidade, estado, cep, tipo, is_default || 0]);
-
-    res.json({ success: true, id: result.insertId });
-  } catch (error) {
-    console.error('‚ùå Erro ao salvar endere√ßo:', error);
-    res.status(500).json({ error: 'Erro interno' });
-  }
-});
-
-// Atualizar endere√ßo
-app.put('/api/customers/addresses/:id', async (req, res) => {
-  try {
-    console.log('üè† PUT /api/customers/addresses/' + req.params.id);
-
-    const { id } = req.params;
-    const { nome, rua, numero, complemento, bairro, cidade, estado, cep, tipo, is_default } = req.body;
-
-    // Obter usu√°rio da sess√£o
-    let userId = null;
-    const sessionId = req.cookies?.session_id;
-    if (sessionId) {
-      try {
-        const [sessions] = await pool.execute('SELECT * FROM sessions WHERE id = ?', [sessionId]);
-        if (sessions && sessions[0] && sessions[0].user_email) {
-          const userEmail = sessions[0].user_email;
-          console.log('üë§ Usu√°rio logado via sess√£o:', userEmail);
-
-          // Buscar o user_id na tabela customers baseado no email
-          const [customers] = await pool.execute('SELECT id FROM customers WHERE email = ?', [userEmail]);
-          if (customers && customers[0]) {
-            userId = customers[0].id;
-            console.log('‚úÖ User ID encontrado:', userId);
-          } else {
-            console.log('‚ö†Ô∏è Cliente n√£o encontrado para email:', userEmail);
-          }
-        }
-      } catch (e) {
-        console.log('‚ö†Ô∏è Erro ao verificar sess√£o:', e.message);
-      }
-    }
-
-    // N√ÉO USAR FALLBACKS - Cada usu√°rio deve ter sua pr√≥pria sess√£o
-
-    if (!userId) {
-      return res.status(401).json({ error: 'N√£o autorizado' });
-    }
-
-    // Se for endere√ßo padr√£o, remover padr√£o dos outros
-    if (is_default) {
-      await pool.execute('UPDATE customer_addresses SET padrao = 0 WHERE customer_id = ?', [userId]);
-    }
-
-    // Atualizar endere√ßo
-    await pool.execute(`
-      UPDATE customer_addresses 
-      SET nome = ?, rua = ?, numero = ?, complemento = ?, bairro = ?, 
-          cidade = ?, estado = ?, cep = ?, tipo = ?, padrao = ?, updated_at = NOW()
-      WHERE id = ? AND customer_id = ?
-    `, [nome, rua, numero, complemento, bairro, cidade, estado, cep, tipo, is_default || 0, id, userId]);
-
-    res.json({ success: true });
-  } catch (error) {
-    console.error('‚ùå Erro ao atualizar endere√ßo:', error);
-    res.status(500).json({ error: 'Erro interno' });
-  }
-});
-
-// Deletar endere√ßo
-app.delete('/api/customers/addresses/:id', async (req, res) => {
-  try {
-    console.log('üè† DELETE /api/customers/addresses/' + req.params.id);
-
-    const { id } = req.params;
-
-    // Obter usu√°rio da sess√£o
-    let userId = null;
-    const sessionId = req.cookies?.session_id;
-    if (sessionId) {
-      try {
-        const [sessions] = await pool.execute('SELECT * FROM sessions WHERE id = ?', [sessionId]);
-        if (sessions && sessions[0] && sessions[0].user_email) {
-          const userEmail = sessions[0].user_email;
-          console.log('üë§ Usu√°rio logado via sess√£o:', userEmail);
-
-          // Buscar o user_id na tabela customers baseado no email
-          const [customers] = await pool.execute('SELECT id FROM customers WHERE email = ?', [userEmail]);
-          if (customers && customers[0]) {
-            userId = customers[0].id;
-            console.log('‚úÖ User ID encontrado:', userId);
-          } else {
-            console.log('‚ö†Ô∏è Cliente n√£o encontrado para email:', userEmail);
-          }
-        }
-      } catch (e) {
-        console.log('‚ö†Ô∏è Erro ao verificar sess√£o:', e.message);
-      }
-    }
-
-    // N√ÉO USAR FALLBACKS - Cada usu√°rio deve ter sua pr√≥pria sess√£o
-
-    if (!userId) {
-      return res.status(401).json({ error: 'N√£o autorizado' });
-    }
-
-    // Deletar endere√ßo
-    await pool.execute('DELETE FROM customer_addresses WHERE id = ? AND customer_id = ?', [id, userId]);
-
-    res.json({ success: true });
-  } catch (error) {
-    console.error('‚ùå Erro ao deletar endere√ßo:', error);
-    res.status(500).json({ error: 'Erro interno' });
-  }
-});
-
-// ==================== ADDRESSES API (ENDERE√áOS M√öLTIPLOS) ====================
-
-// Debug endpoint para testar conex√£o
-app.get('/api/debug/connection', async (req, res) => {
-  try {
-    console.log('üîç Testando conex√£o...');
-
-    // Testar SELECT DATABASE()
-    const [db] = await pool.execute('SELECT DATABASE() as db');
-    console.log('üìç Banco:', db[0].db);
-
-    // Testar SHOW TABLES
-    const [tables] = await pool.execute('SHOW TABLES');
-    const tableNames = tables.map(t => Object.values(t)[0]);
-    console.log('üìã Tabelas:', tableNames);
-
-    // Verificar se customer_addresses existe
-    if (tableNames.includes('customer_addresses')) {
-      console.log('‚úÖ Tabela customer_addresses encontrada!');
-
-      // Testar SELECT na tabela
-      const [count] = await pool.execute('SELECT COUNT(*) as total FROM customer_addresses');
-      console.log('üè† Total de endere√ßos:', count[0].total);
-
-      res.json({
-        success: true,
-        database: db[0].db,
-        tables: tableNames,
-        customer_addresses_exists: true,
-        total_addresses: count[0].total
-      });
-    } else {
-      console.log('‚ùå Tabela customer_addresses N√ÉO encontrada!');
-      res.json({
-        success: false,
-        database: db[0].db,
-        tables: tableNames,
-        customer_addresses_exists: false
-      });
-    }
-  } catch (e) {
-    console.error('‚ùå Erro no debug:', e.message);
-    res.status(500).json({ error: e.message });
-  }
-});
-
-// Listar endere√ßos do cliente
-app.get('/api/customers/:userId/addresses', async (req, res) => {
-  try {
-    let { userId } = req.params;
-    console.log(`üìç GET /api/customers/${userId}/addresses`);
-
-    // Se userId parece ser email, buscar o ID do usu√°rio
-    if (userId.includes('@')) {
-      try {
-        console.log(`üîç Buscando usu√°rio por email: ${userId}`);
-        const [user] = await pool.execute('SELECT id FROM users WHERE email = ?', [userId]);
-        if (user && user[0]) {
-          userId = user[0].id;
-          console.log(`‚úÖ Usu√°rio encontrado com ID: ${userId}`);
-        } else {
-          console.log(`‚ùå Usu√°rio n√£o encontrado para email: ${userId}`);
-          return res.status(404).json({ error: 'Usu√°rio n√£o encontrado', addresses: [] });
-        }
-      } catch (e) {
-        console.error('‚ö†Ô∏è Erro ao buscar usu√°rio por email:', e);
-        return res.status(500).json({ error: 'Erro ao buscar usu√°rio', details: e.message, addresses: [] });
-      }
-    }
-
-    // Debug: verificar banco atual
-    console.log(`üîç Verificando banco atual...`);
-    const [dbInfo] = await pool.execute('SELECT DATABASE() as current_db');
-    console.log(`üìç Banco atual: ${dbInfo[0].current_db}`);
-
-    // Debug: listar tabelas
-    console.log(`üîç Listando tabelas...`);
-    const [tables] = await pool.execute('SHOW TABLES');
-    console.log(`üìã Tabelas encontradas:`, tables.map(t => Object.values(t)[0]));
-
-    // Buscar endere√ßos
-    console.log(`üîç Buscando endere√ßos para userId: ${userId}`);
-    const [addresses] = await pool.execute(`
-      SELECT id, nome as label, cep, rua as endereco, numero, complemento, bairro, cidade, estado, padrao as is_default, created_at, updated_at
-      FROM customer_addresses
-      WHERE customer_id = ?
-      ORDER BY padrao DESC, created_at DESC
-    `, [userId]);
-
-    console.log(`‚úÖ Encontrados ${addresses.length} endere√ßos`);
-    res.json({ addresses: addresses || [] });
-  } catch (error) {
-    console.error('‚ùå Erro ao buscar endere√ßos:', error);
-    logger.logError(error, req);
-    res.status(500).json({
-      error: 'Erro ao buscar endere√ßos',
-      details: error.message,
-      addresses: [] // Sempre retornar array vazio em caso de erro
-    });
-  }
-});
-
-// Criar novo endere√ßo
-app.post('/api/customers/:userId/addresses', async (req, res) => {
-  try {
-    let { userId } = req.params;
-    console.log(`üîç POST /api/customers/${userId}/addresses - Iniciando...`);
-
-    // Se userId parece ser email, buscar o ID do usu√°rio
-    if (userId.includes('@')) {
-      try {
-        console.log(`üîç Buscando usu√°rio por email: ${userId}`);
-        const [user] = await pool.execute('SELECT id FROM users WHERE email = ?', [userId]);
-        if (user && user[0]) {
-          userId = user[0].id;
-          console.log(`‚úÖ Usu√°rio encontrado: ${userId}`);
-        } else {
-          console.log(`‚ùå Usu√°rio n√£o encontrado para email: ${userId}`);
-          return res.status(404).json({ error: 'Usu√°rio n√£o encontrado' });
-        }
-      } catch (e) {
-        console.log('‚ö†Ô∏è Erro ao buscar usu√°rio por email:', e.message);
-        return res.status(500).json({ error: 'Erro ao buscar usu√°rio' });
-      }
-    }
-
-    const { label, cep, endereco, numero, complemento, bairro, cidade, estado, is_default } = req.body;
-    const id = crypto.randomUUID();
-
-    console.log(`üìù Dados do endere√ßo:`, { label, cep, endereco, numero, complemento, bairro, cidade, estado, is_default });
-
-    // Verificar banco atual
-    try {
-      const [db] = await pool.execute('SELECT DATABASE() as current_db');
-      console.log(`üìç Banco atual: ${db[0].current_db}`);
-    } catch (e) {
-      console.log('‚ö†Ô∏è Erro ao verificar banco:', e.message);
-    }
-
-    // Tabela existe e est√° acess√≠vel
-    console.log(`‚úÖ Tentando inserir endere√ßo...`);
-
-    // Inserir endere√ßo
-    console.log(`üíæ Inserindo novo endere√ßo...`);
-    await pool.execute(`
-      INSERT INTO customer_addresses (id, customer_id, tipo, nome, rua, numero, complemento, bairro, cidade, estado, cep, padrao)
-      VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
-    `, [id, userId, label.toLowerCase(), label, endereco, numero, complemento || null, bairro, cidade, estado, cep, is_default ? 1 : 0]);
-
-    // Se for padr√£o, remover padr√£o dos outros
-    if (is_default) {
-      console.log(`üîÑ Removendo padr√£o dos outros endere√ßos...`);
-      await pool.execute('UPDATE customer_addresses SET padrao = 0 WHERE customer_id = ? AND id != ?', [userId, id]);
-    }
-
-    console.log(`‚úÖ Endere√ßo criado para user_id=${userId}, address_id=${id}`);
-    res.json({ success: true, id });
-  } catch (error) {
-    console.error('‚ùå Erro ao criar endere√ßo:', error);
-    res.status(500).json({ error: 'Erro ao criar endere√ßo' });
-  }
-});
-
-// Atualizar endere√ßo
-app.put('/api/customers/:userId/addresses/:addressId', async (req, res) => {
-  try {
-    let { userId, addressId } = req.params;
-
-    // Converter email para userId se necess√°rio
-    if (userId.includes('@')) {
-      const [user] = await pool.execute('SELECT id FROM users WHERE email = ?', [userId]);
-      if (user && user[0]) userId = user[0].id;
-      else return res.status(404).json({ error: 'Usu√°rio n√£o encontrado' });
-    }
-
-    const { label, cep, endereco, numero, complemento, bairro, cidade, estado, is_default } = req.body;
-
-    if (is_default) {
-      await pool.execute('UPDATE customer_addresses SET padrao = 0 WHERE customer_id = ?', [userId]);
-    }
-
-    await pool.execute(`
-      UPDATE customer_addresses
-      SET tipo = ?, nome = ?, cep = ?, rua = ?, numero = ?, complemento = ?, bairro = ?, cidade = ?, estado = ?, padrao = ?, updated_at = NOW()
-      WHERE id = ? AND customer_id = ?
-    `, [label.toLowerCase(), label, cep, endereco, numero, complemento || null, bairro, cidade, estado, is_default ? 1 : 0, addressId, userId]);
-
-    console.log(`‚úÖ Endere√ßo ${addressId} atualizado para user_id=${userId}`);
-    res.json({ success: true });
-  } catch (error) {
-    console.error('Erro ao atualizar endere√ßo:', error);
-    res.status(500).json({ error: 'Erro ao atualizar endere√ßo' });
-  }
-});
-
-// Deletar endere√ßo
-app.delete('/api/customers/:userId/addresses/:addressId', async (req, res) => {
-  try {
-    let { userId, addressId } = req.params;
-
-    // Converter email para userId se necess√°rio
-    if (userId.includes('@')) {
-      const [user] = await pool.execute('SELECT id FROM users WHERE email = ?', [userId]);
-      if (user && user[0]) userId = user[0].id;
-      else return res.status(404).json({ error: 'Usu√°rio n√£o encontrado' });
-    }
-
-    await pool.execute('DELETE FROM customer_addresses WHERE id = ? AND customer_id = ?', [addressId, userId]);
-
-    console.log(`‚úÖ Endere√ßo ${addressId} deletado para user_id=${userId}`);
-    res.json({ success: true });
-  } catch (error) {
-    console.error('Erro ao deletar endere√ßo:', error);
-    res.status(500).json({ error: 'Erro ao deletar endere√ßo' });
-  }
-});
-
-// Definir endere√ßo como padr√£o
-app.patch('/api/customers/:userId/addresses/:addressId/set-default', async (req, res) => {
-  try {
-    let { userId, addressId } = req.params;
-
-    // Converter email para userId se necess√°rio
-    if (userId.includes('@')) {
-      const [user] = await pool.execute('SELECT id FROM users WHERE email = ?', [userId]);
-      if (user && user[0]) userId = user[0].id;
-      else return res.status(404).json({ error: 'Usu√°rio n√£o encontrado' });
-    }
-
-    await pool.execute('UPDATE customer_addresses SET padrao = 0 WHERE customer_id = ?', [userId]);
-    await pool.execute('UPDATE customer_addresses SET padrao = 1 WHERE id = ? AND customer_id = ?', [addressId, userId]);
-
-    console.log(`‚úÖ Endere√ßo ${addressId} definido como padr√£o para user_id=${userId}`);
-    res.json({ success: true });
-  } catch (error) {
-    console.error('Erro ao definir endere√ßo padr√£o:', error);
-    res.status(500).json({ error: 'Erro ao definir endere√ßo padr√£o' });
-  }
-});
-
-// ==================== FAVORITES/WISHLIST API ====================
-
-// Listar favoritos do cliente
-app.get('/api/customers/:userId/favorites', async (req, res) => {
-  try {
-    const { userId } = req.params;
-
-    // Buscar email do usu√°rio
-    const [userEmail] = await pool.execute('SELECT email FROM users WHERE id = ?', [userId]);
-    const email = userEmail[0]?.email || null;
-
-    if (!email) {
-      return res.json({ favorites: [] });
-    }
-
-    const [favorites] = await pool.execute(`
-      SELECT p.*
-      FROM favorites f
-      JOIN products p ON f.product_id = p.id
-      WHERE f.user_email = ?
-      ORDER BY f.created_at DESC
-    `, [email]);
-
-    res.json({ favorites });
-  } catch (error) {
-    logger.logError(error, req);
-    res.status(500).json({ error: 'Erro ao buscar favoritos' });
-  }
-});
-
-// Adicionar aos favoritos
-app.post('/api/customers/:userId/favorites/:productId', async (req, res) => {
-  try {
-    const { userId, productId } = req.params;
-
-    // Buscar email do usu√°rio
-    const [userEmail] = await pool.execute('SELECT email FROM users WHERE id = ?', [userId]);
-    const email = userEmail[0]?.email || null;
-
-    if (!email) {
-      return res.status(400).json({ error: 'Usu√°rio n√£o encontrado' });
-    }
-
-    const id = crypto.randomUUID();
-
-    await pool.execute(`
-      INSERT IGNORE INTO favorites (id, user_email, product_id)
-      VALUES (?, ?, ?)
-    `, [id, email, productId]);
-
-    res.json({ success: true });
-  } catch (error) {
-    logger.logError(error, req);
-    res.status(500).json({ error: 'Erro ao adicionar favorito' });
-  }
-});
-
-// Remover dos favoritos
-app.delete('/api/customers/:userId/favorites/:productId', async (req, res) => {
-  try {
-    const { userId, productId } = req.params;
-
-    // Buscar email do usu√°rio
-    const [userEmail] = await pool.execute('SELECT email FROM users WHERE id = ?', [userId]);
-    const email = userEmail[0]?.email || null;
-
-    if (!email) {
-      return res.status(400).json({ error: 'Usu√°rio n√£o encontrado' });
-    }
-
-    await pool.execute('DELETE FROM favorites WHERE user_email = ? AND product_id = ?', [email, productId]);
-
-    res.json({ success: true });
-  } catch (error) {
-    logger.logError(error, req);
-    res.status(500).json({ error: 'Erro ao remover favorito' });
-  }
-});
-
-// ==================== REVIEWS API ====================
-
-// Listar reviews de um produto
-app.get('/api/products/:productId/reviews', async (req, res) => {
-  try {
-    const { productId } = req.params;
-    const [reviews] = await pool.execute(`
-      SELECT 
-        r.*,
-        u.nome as user_name,
-        u.avatar_url as user_avatar
-      FROM product_reviews r
-      LEFT JOIN users u ON r.customer_id = u.id
-      WHERE r.product_id = ? AND r.status = 'approved'
-      ORDER BY r.created_at DESC
-    `, [productId]);
-
-    res.json({ reviews });
-  } catch (error) {
-    logger.logError(error, req);
-    res.status(500).json({ error: 'Erro ao buscar avalia√ß√µes' });
-  }
-});
-
-// Criar review
-app.post('/api/products/:productId/reviews', async (req, res) => {
-  try {
-    const { productId } = req.params;
-    const { rating, comment, title, customer_id, images } = req.body;
-
-    // Valida√ß√µes
-    if (!customer_id) {
-      return res.status(401).json({ error: 'Usu√°rio n√£o autenticado' });
-    }
-    if (!rating || rating < 1 || rating > 5) {
-      return res.status(400).json({ error: 'Avalia√ß√£o deve ser entre 1 e 5 estrelas' });
-    }
-    if (!comment || comment.trim().length < 10) {
-      return res.status(400).json({ error: 'Coment√°rio deve ter no m√≠nimo 10 caracteres' });
-    }
-
-    // Inserir review
-    await pool.execute(`
-      INSERT INTO product_reviews (product_id, customer_id, rating, title, comment, images, status)
-      VALUES (?, ?, ?, ?, ?, ?, 'pending')
-    `, [productId, customer_id, rating, title || 'Avalia√ß√£o', comment, images ? JSON.stringify(images) : null]);
-
-    // Atualizar m√©dia de avalia√ß√µes do produto (apenas aprovadas)
-    const [avgResult] = await pool.execute(`
-      SELECT AVG(rating) as avg_rating, COUNT(*) as total_reviews
-      FROM product_reviews
-      WHERE product_id = ? AND status = 'approved'
-    `, [productId]);
-
-    if (avgResult[0].total_reviews > 0) {
-      await pool.execute(`
-        UPDATE products
-        SET avaliacao = ?, total_avaliacoes = ?
-        WHERE id = ?
-      `, [avgResult[0].avg_rating, avgResult[0].total_reviews, productId]);
-    }
-
-    logger.info('Review criado', { productId, customerId: customer_id, rating });
-    res.json({ success: true, message: 'Avalia√ß√£o enviada para modera√ß√£o' });
-  } catch (error) {
-    logger.logError(error, req);
-    res.status(500).json({ error: 'Erro ao criar avalia√ß√£o' });
-  }
-});
-
-// Marcar review como √∫til
-app.post('/api/reviews/:reviewId/helpful', async (req, res) => {
-  try {
-    const { reviewId } = req.params;
-    const { customer_id } = req.body;
-
-    if (!customer_id) {
-      return res.status(401).json({ error: 'Usu√°rio n√£o autenticado' });
-    }
-
-    // Verificar se j√° votou
-    const [existing] = await pool.execute(
-      'SELECT id FROM review_helpful WHERE review_id = ? AND customer_id = ?',
-      [reviewId, customer_id]
-    );
-
-    if (existing.length > 0) {
-      return res.status(400).json({ error: 'Voc√™ j√° marcou esta avalia√ß√£o como √∫til' });
-    }
-
-    // Inserir voto
-    await pool.execute(
-      'INSERT INTO review_helpful (review_id, customer_id) VALUES (?, ?)',
-      [reviewId, customer_id]
-    );
-
-    // Incrementar contador
-    await pool.execute(
-      'UPDATE product_reviews SET helpful_count = helpful_count + 1 WHERE id = ?',
-      [reviewId]
-    );
-
-    res.json({ success: true });
-  } catch (error) {
-    logger.logError(error, req);
-    res.status(500).json({ error: 'Erro ao marcar avalia√ß√£o como √∫til' });
-  }
-});
-
-// ==================== REVIEWS API AVAN√áADO ====================
-
-// Estat√≠sticas de reviews de um produto
-app.get('/api/products/:productId/reviews/stats', async (req, res) => {
-  try {
-    const { productId } = req.params;
-
-    const [stats] = await pool.execute(`
-      SELECT 
-        COUNT(*) as total_reviews,
-        AVG(rating) as avg_rating,
-        SUM(CASE WHEN rating = 5 THEN 1 ELSE 0 END) as rating_5,
-        SUM(CASE WHEN rating = 4 THEN 1 ELSE 0 END) as rating_4,
-        SUM(CASE WHEN rating = 3 THEN 1 ELSE 0 END) as rating_3,
-        SUM(CASE WHEN rating = 2 THEN 1 ELSE 0 END) as rating_2,
-        SUM(CASE WHEN rating = 1 THEN 1 ELSE 0 END) as rating_1,
-        SUM(CASE WHEN verified_purchase = 1 THEN 1 ELSE 0 END) as verified_purchases
-      FROM product_reviews
-      WHERE product_id = ? AND status = 'approved'
-    `, [productId]);
-
-    res.json(stats[0] || {});
-  } catch (error) {
-    logger.logError(error, req);
-    res.status(500).json({ error: 'Erro ao buscar estat√≠sticas' });
-  }
-});
-
-// Reportar review
-app.post('/api/reviews/:reviewId/report', async (req, res) => {
-  try {
-    const { reviewId } = req.params;
-    const { customer_id, reason, description } = req.body;
-
-    if (!customer_id) {
-      return res.status(401).json({ error: 'Usu√°rio n√£o autenticado' });
-    }
-
-    if (!reason) {
-      return res.status(400).json({ error: 'Motivo √© obrigat√≥rio' });
-    }
-
-    // Inserir reporte
-    await pool.execute(`
-      INSERT INTO review_reports (review_id, customer_id, reason, description, status)
-      VALUES (?, ?, ?, ?, 'pending')
-    `, [reviewId, customer_id, reason, description || null]);
-
-    // Incrementar contador de reports
-    await pool.execute(
-      'UPDATE product_reviews SET reported_count = reported_count + 1 WHERE id = ?',
-      [reviewId]
-    );
-
-    logger.info('Review reportado', { reviewId, reason });
-    res.json({ success: true, message: 'Den√∫ncia registrada com sucesso' });
-  } catch (error) {
-    logger.logError(error, req);
-    res.status(500).json({ error: 'Erro ao reportar avalia√ß√£o' });
-  }
-});
-
-// ==================== ADMIN REVIEWS API ====================
-
-// Listar todos os reviews (admin)
-app.get('/api/admin/reviews', async (req, res) => {
-  try {
-    const { status, product_id } = req.query;
-
-    // Query corrigida usando nome completo do banco e tabela correta
-    // Usar subquery ou nome completo da coluna no WHERE para evitar problemas com alias
-    let whereConditions = [];
-    const params = [];
-
-    // Filtrar por status usando nome completo da tabela no WHERE
-    if (status && status !== 'all') {
-      whereConditions.push('\`rare_toy_companion\`.\`product_reviews\`.\`status\` = ?');
-      params.push(status);
-    }
-
-    if (product_id) {
-      whereConditions.push('r.product_id = ?');
-      params.push(product_id);
-    }
-
-    const whereClause = whereConditions.length > 0
-      ? 'WHERE ' + whereConditions.join(' AND ')
-      : '';
-
-    let query = `
-      SELECT 
-        r.id,
-        r.product_id,
-        r.customer_id,
-        r.order_id,
-        r.rating,
-        r.title,
-        r.comment,
-        r.images,
-        r.verified_purchase,
-        r.helpful_count,
-        r.reported_count,
-        r.status,
-        r.admin_notes,
-        r.created_at,
-        r.updated_at,
-        COALESCE(u.nome, u.email, 'Cliente') as customer_name,
-        u.email as customer_email,
-        p.nome as product_name,
-        p.imagem_url as product_image
-      FROM \`rare_toy_companion\`.\`product_reviews\` r
-      LEFT JOIN \`rare_toy_companion\`.\`users\` u ON CAST(r.customer_id AS CHAR) = CAST(u.id AS CHAR)
-      LEFT JOIN \`rare_toy_companion\`.\`produtos\` p ON CAST(r.product_id AS CHAR) = CAST(p.id AS CHAR)
-      ${whereClause}
-      ORDER BY r.created_at DESC
-      LIMIT 500
-    `;
-
-    console.log('üîç Query reviews:', query);
-    console.log('üìä Params:', params);
-
-    const [reviews] = await pool.execute(query, params);
-
-    logger.info('Reviews carregados (admin)', { count: reviews.length, status });
-    res.json({ reviews });
-  } catch (error) {
-    logger.logError(error, req);
-    console.error('‚ùå Erro ao buscar reviews:', error.message);
-    console.error('‚ùå SQL Error Code:', error.code);
-    console.error('‚ùå SQL State:', error.sqlState);
-    res.status(500).json({ error: 'Erro ao buscar reviews', details: error.message });
-  }
-});
-
-// Aprovar review
-app.put('/api/admin/reviews/:reviewId/approve', async (req, res) => {
-  try {
-    const { reviewId } = req.params;
-
-    // Atualizar status do review
-    await pool.execute(
-      'UPDATE product_reviews SET status = ?, updated_at = NOW() WHERE id = ?',
-      ['approved', reviewId]
-    );
-
-    // Atualizar m√©dia de avalia√ß√µes do produto
-    const [review] = await pool.execute(
-      'SELECT product_id FROM product_reviews WHERE id = ?',
-      [reviewId]
-    );
-
-    if (review.length > 0) {
-      const productId = review[0].product_id;
-
-      const [avgResult] = await pool.execute(`
-        SELECT AVG(rating) as avg_rating, COUNT(*) as total_reviews
-        FROM product_reviews
-        WHERE product_id = ? AND status = 'approved'
-      `, [productId]);
-
-      await pool.execute(`
-        UPDATE products
-        SET avaliacao = ?, total_avaliacoes = ?
-        WHERE id = ?
-      `, [avgResult[0].avg_rating || 0, avgResult[0].total_reviews || 0, productId]);
-    }
-
-    logger.info('Review aprovado', { reviewId });
-    res.json({ success: true, message: 'Avalia√ß√£o aprovada com sucesso' });
-  } catch (error) {
-    logger.logError(error, req);
-    res.status(500).json({ error: 'Erro ao aprovar review' });
-  }
-});
-
-// Rejeitar review
-app.put('/api/admin/reviews/:reviewId/reject', async (req, res) => {
-  try {
-    const { reviewId } = req.params;
-    const { admin_notes } = req.body;
-
-    await pool.execute(
-      'UPDATE product_reviews SET status = ?, admin_notes = ?, updated_at = NOW() WHERE id = ?',
-      ['rejected', admin_notes || 'Rejeitado pelo administrador', reviewId]
-    );
-
-    logger.info('Review rejeitado', { reviewId, admin_notes });
-    res.json({ success: true, message: 'Avalia√ß√£o rejeitada' });
-  } catch (error) {
-    logger.logError(error, req);
-    res.status(500).json({ error: 'Erro ao rejeitar review' });
-  }
-});
-
-// Deletar review (admin)
-app.delete('/api/admin/reviews/:reviewId', async (req, res) => {
-  try {
-    const { reviewId } = req.params;
-
-    // Buscar informa√ß√£o do produto antes de deletar
-    const [review] = await pool.execute(
-      'SELECT product_id FROM product_reviews WHERE id = ?',
-      [reviewId]
-    );
-
-    if (review.length === 0) {
-      return res.status(404).json({ error: 'Avalia√ß√£o n√£o encontrada' });
-    }
-
-    const productId = review[0].product_id;
-
-    // Deletar review
-    await pool.execute('DELETE FROM product_reviews WHERE id = ?', [reviewId]);
-
-    // Recalcular m√©dia de avalia√ß√µes do produto
-    const [avgResult] = await pool.execute(`
-      SELECT AVG(rating) as avg_rating, COUNT(*) as total_reviews
-      FROM product_reviews
-      WHERE product_id = ? AND status = 'approved'
-    `, [productId]);
-
-    await pool.execute(`
-      UPDATE products
-      SET avaliacao = ?, total_avaliacoes = ?
-      WHERE id = ?
-    `, [avgResult[0].avg_rating || 0, avgResult[0].total_reviews || 0, productId]);
-
-    logger.info('Review deletado', { reviewId, productId });
-    res.json({ success: true, message: 'Avalia√ß√£o exclu√≠da com sucesso' });
-  } catch (error) {
-    logger.logError(error, req);
-    res.status(500).json({ error: 'Erro ao excluir avalia√ß√£o' });
-  }
-});
-
-// ==================== ORDERS API (AVAN√áADO) ====================
-
-// Estat√≠sticas de pedidos
-app.get('/api/orders/stats', async (req, res) => {
-  try {
-    const [stats] = await pool.execute(`
-      SELECT 
-        COUNT(*) as total,
-        SUM(CASE WHEN status = 'pending' THEN 1 ELSE 0 END) as pending,
-        SUM(CASE WHEN status = 'processing' THEN 1 ELSE 0 END) as processing,
-        SUM(CASE WHEN status = 'shipped' THEN 1 ELSE 0 END) as shipped,
-        SUM(CASE WHEN status = 'delivered' THEN 1 ELSE 0 END) as delivered,
-        SUM(CASE WHEN status = 'cancelled' THEN 1 ELSE 0 END) as cancelled,
-        COALESCE(SUM(CASE WHEN status != 'cancelled' THEN total ELSE 0 END), 0) as total_revenue
-      FROM orders
-    `);
-
-    res.json({
-      total: Number(stats[0].total) || 0,
-      pending: Number(stats[0].pending) || 0,
-      processing: Number(stats[0].processing) || 0,
-      shipped: Number(stats[0].shipped) || 0,
-      delivered: Number(stats[0].delivered) || 0,
-      cancelled: Number(stats[0].cancelled) || 0,
-      totalRevenue: Number(stats[0].total_revenue) || 0,
-    });
-  } catch (error) {
-    logger.logError(error, req);
-    res.status(500).json({ error: 'Erro ao buscar estat√≠sticas de pedidos' });
-  }
-});
-
-// Atualizar status do pedido
-app.patch('/api/orders/:id/status', async (req, res) => {
-  try {
-    const { id } = req.params;
-    const { status } = req.body;
-
-    await pool.execute('UPDATE orders SET status = ?, updated_at = NOW() WHERE id = ?', [status, id]);
-
-    logger.info('Status do pedido atualizado', { orderId: id, newStatus: status });
-    res.json({ success: true });
-  } catch (error) {
-    logger.logError(error, req);
-    res.status(500).json({ error: 'Erro ao atualizar status' });
-  }
-});
-
-// Atualizar pedido (gen√©rico - para cancelar, etc) - PUT
-app.put('/api/orders/:id', async (req, res) => {
-  try {
-    const { id } = req.params;
-    const { status, payment_method, tracking_code } = req.body;
-
-    console.log(`üì¶ PUT /api/orders/${id} - Atualizando pedido`, { status, payment_method, tracking_code });
-
-    // Verificar se o pedido existe e obter customer_id
-    const [existingOrders] = await pool.execute(
-      'SELECT customer_id, status as current_status FROM orders WHERE id = ?',
-      [id]
-    );
-
-    if (existingOrders.length === 0) {
-      return res.status(404).json({
-        success: false,
-        message: 'Pedido n√£o encontrado'
-      });
-    }
-
-    const order = existingOrders[0];
-
-    // Construir query dinamicamente
-    const updates = [];
-    const values = [];
-
-    if (status) {
-      // Validar status
-      const validStatuses = ['pending', 'processing', 'shipped', 'delivered', 'cancelled', 'confirmed'];
-      if (!validStatuses.includes(status)) {
-        return res.status(400).json({
-          success: false,
-          message: 'Status inv√°lido'
-        });
-      }
-
-      // Clientes s√≥ podem cancelar pedidos pendentes ou em processamento
-      if (status === 'cancelled' && !['pending', 'processing'].includes(order.current_status)) {
-        return res.status(403).json({
-          success: false,
-          message: 'Voc√™ s√≥ pode cancelar pedidos pendentes ou em processamento'
-        });
-      }
-
-      updates.push('status = ?');
-      values.push(status);
-    }
-
-    if (payment_method !== undefined) {
-      updates.push('payment_method = ?');
-      values.push(payment_method || null);
-    }
-
-    if (tracking_code !== undefined) {
-      updates.push('tracking_code = ?');
-      values.push(tracking_code || null);
-    }
-
-    if (updates.length === 0) {
-      return res.status(400).json({
-        success: false,
-        error: 'Nenhum campo para atualizar'
-      });
-    }
-
-    updates.push('updated_at = NOW()');
-    values.push(id);
-
-    const query = `UPDATE orders SET ${updates.join(', ')} WHERE id = ?`;
-    await pool.execute(query, values);
-
-    logger.info('Pedido atualizado', { orderId: id, updates: { status, payment_method, tracking_code } });
-
-    // Buscar pedido atualizado
-    const [updatedOrders] = await pool.execute(
-      'SELECT * FROM orders WHERE id = ?',
-      [id]
-    );
-
-    res.json({
-      success: true,
-      message: 'Pedido atualizado com sucesso',
-      data: updatedOrders[0]
-    });
-  } catch (error) {
-    logger.logError(error, req);
-    res.status(500).json({
-      success: false,
-      error: 'Erro ao atualizar pedido',
-      message: error.message
-    });
-  }
-});
-
-// Atualizar pedido (gen√©rico - para cancelar, etc) - PATCH
-app.patch('/api/orders/:id', async (req, res) => {
-  try {
-    const { id } = req.params;
-    const { status, payment_method, tracking_code } = req.body;
-
-    // Construir query dinamicamente
-    const updates = [];
-    const values = [];
-
-    if (status) {
-      updates.push('status = ?');
-      values.push(status);
-    }
-
-    if (payment_method !== undefined) {
-      updates.push('payment_method = ?');
-      values.push(payment_method || null);
-    }
-
-    if (tracking_code !== undefined) {
-      updates.push('tracking_code = ?');
-      values.push(tracking_code || null);
-    }
-
-    if (updates.length === 0) {
-      return res.status(400).json({ error: 'Nenhum campo para atualizar' });
-    }
-
-    updates.push('updated_at = NOW()');
-    values.push(id);
-
-    const query = `UPDATE orders SET ${updates.join(', ')} WHERE id = ?`;
-    await pool.execute(query, values);
-
-    logger.info('Pedido atualizado', { orderId: id, updates: { status, payment_method, tracking_code } });
-    res.json({ success: true, message: 'Pedido atualizado com sucesso' });
-  } catch (error) {
-    logger.logError(error, req);
-    res.status(500).json({ error: 'Erro ao atualizar pedido' });
-  }
-});
-
-// DELETE /api/admin/orders/:id - Excluir pedido (Admin)
-app.delete('/api/admin/orders/:id', authenticateAdmin, async (req, res) => {
-  try {
-    const { id } = req.params;
-
-    console.log(`üóëÔ∏è [Admin] Tentando excluir pedido ${id}`);
-
-    // Verificar se o pedido existe
-    const [orders] = await pool.execute('SELECT * FROM orders WHERE id = ?', [id]);
-
-    if (orders.length === 0) {
-      return res.status(404).json({ error: 'Pedido n√£o encontrado' });
-    }
-
-    const order = orders[0];
-
-    // Valida√ß√£o: apenas pedidos pendentes ou cancelados podem ser deletados
-    // Pedidos processados, enviados ou entregues n√£o devem ser deletados
-    const deletableStatuses = ['pending', 'cancelled'];
-    if (!deletableStatuses.includes(order.status)) {
-      return res.status(400).json({
-        error: 'N√£o √© poss√≠vel excluir este pedido',
-        message: `Pedidos com status "${order.status}" n√£o podem ser exclu√≠dos. Apenas pedidos pendentes ou cancelados podem ser exclu√≠dos.`
-      });
-    }
-
-    // Deletar itens do pedido primeiro (se houver)
-    try {
-      await pool.execute('DELETE FROM order_items WHERE order_id = ?', [id]);
-      console.log(`‚úÖ [Admin] Itens do pedido ${id} exclu√≠dos`);
-    } catch (itemsError) {
-      console.warn(`‚ö†Ô∏è [Admin] Erro ao excluir itens do pedido ${id}:`, itemsError);
-      // Continuar mesmo se houver erro ao deletar itens
-    }
-
-    // Deletar hist√≥rico de status (se existir)
-    try {
-      await pool.execute('DELETE FROM order_status_history WHERE order_id = ?', [id]);
-    } catch (historyError) {
-      console.warn(`‚ö†Ô∏è [Admin] Erro ao excluir hist√≥rico do pedido ${id}:`, historyError);
-      // Continuar mesmo se houver erro
-    }
-
-    // Deletar o pedido
-    await pool.execute('DELETE FROM orders WHERE id = ?', [id]);
-
-    // Log de auditoria
-    try {
-      const { logAudit } = require('./utils/audit.cjs');
-      await logAudit({
-        userId: req.admin?.id || null,
-        userEmail: req.admin?.email || null,
-        action: 'order_deleted',
-        resourceType: 'order',
-        resourceId: id,
-        details: {
-          order_status: order.status,
-          order_total: order.total,
-          customer_name: order.nome,
-          customer_email: order.email
-        },
-        ipAddress: req.ip,
-        userAgent: req.get('user-agent')
-      });
-    } catch (auditError) {
-      console.warn('‚ö†Ô∏è Erro ao registrar auditoria:', auditError);
-    }
-
-    console.log(`‚úÖ [Admin] Pedido ${id} exclu√≠do com sucesso`);
-
-    res.json({
-      success: true,
-      message: 'Pedido exclu√≠do com sucesso',
-      order_id: id
-    });
-  } catch (error) {
-    console.error('‚ùå [Admin] Erro ao excluir pedido:', error);
-    logger.logError(error, req);
-    res.status(500).json({
-      error: 'Erro ao excluir pedido',
-      message: error?.message
-    });
-  }
-});
-
-// Excluir pedido (endpoint p√∫blico - mantido para compatibilidade)
-app.delete('/api/orders/:id', async (req, res) => {
-  try {
-    const { id } = req.params;
-
-    // Verificar se o pedido existe
-    const [order] = await pool.execute('SELECT * FROM orders WHERE id = ?', [id]);
-
-    if (order.length === 0) {
-      return res.status(404).json({ error: 'Pedido n√£o encontrado' });
-    }
-
-    // Deletar itens do pedido primeiro
-    await pool.execute('DELETE FROM order_items WHERE order_id = ?', [id]);
-
-    // Deletar o pedido
-    await pool.execute('DELETE FROM orders WHERE id = ?', [id]);
-
-    logger.info('Pedido exclu√≠do', { orderId: id });
-    res.json({ success: true, message: 'Pedido exclu√≠do com sucesso' });
-  } catch (error) {
-    logger.logError(error, req);
-    res.status(500).json({ error: 'Erro ao excluir pedido' });
-  }
-});
-
-// Reordenar (adicionar produtos do pedido ao carrinho)
-app.post('/api/orders/:id/reorder', async (req, res) => {
-  try {
-    const { id } = req.params;
-    const cartId = getOrCreateCartId(req, res);
-
-    // Buscar itens do pedido
-    const [orderItems] = await pool.execute(`
-      SELECT product_id, name, price, image_url, quantity
-      FROM order_items
-      WHERE order_id = ?
-    `, [id]);
-
-    if (orderItems.length === 0) {
-      return res.status(404).json({ error: 'Pedido n√£o encontrado' });
-    }
-
-    // Adicionar cada item ao carrinho
-    for (const item of orderItems) {
-      await pool.execute(`
-        INSERT INTO cart_items (cart_id, product_id, name, price, image_url, quantity)
-        VALUES (?, ?, ?, ?, ?, ?)
-        ON DUPLICATE KEY UPDATE quantity = quantity + VALUES(quantity)
-      `, [cartId, item.product_id, item.name, item.price, item.image_url, item.quantity]);
-    }
-
-    // Retornar carrinho atualizado
-    const [cartItems] = await pool.execute(`
-      SELECT * FROM cart_items WHERE cart_id = ? ORDER BY created_at DESC
-    `, [cartId]);
-
-    logger.info('Pedido readicionado ao carrinho', { orderId: id, itemsCount: orderItems.length });
-    res.json({ success: true, items: cartItems });
-  } catch (error) {
-    logger.logError(error, req);
-    res.status(500).json({ error: 'Erro ao reordenar' });
-  }
-});
-
-// Gerar nota fiscal (simulado)
-app.get('/api/orders/:id/invoice', async (req, res) => {
-  try {
-    const { id } = req.params;
-
-    const [orders] = await pool.execute('SELECT * FROM orders WHERE id = ?', [id]);
-    if (orders.length === 0) {
-      return res.status(404).json({ error: 'Pedido n√£o encontrado' });
-    }
-
-    const order = orders[0];
-
-    // Gerar PDF ou HTML simples da nota fiscal
-    const html = `
-      <!DOCTYPE html>
-      <html>
-      <head>
-        <meta charset="UTF-8">
-        <title>Nota Fiscal - Pedido #${order.id}</title>
-        <style>
-          body { font-family: Arial, sans-serif; max-width: 800px; margin: 0 auto; padding: 20px; }
-          .header { text-align: center; border-bottom: 2px solid #000; padding-bottom: 20px; margin-bottom: 20px; }
-          .info { margin: 20px 0; }
-          .total { font-size: 24px; font-weight: bold; text-align: right; margin-top: 20px; }
-        </style>
-      </head>
-      <body>
-        <div class="header">
-          <h1>NOTA FISCAL SIMPLIFICADA</h1>
-          <p>MuhlStore - Brinquedos Raros</p>
-        </div>
-        <div class="info">
-          <p><strong>Pedido:</strong> #${order.id}</p>
-          <p><strong>Data:</strong> ${new Date(order.created_at).toLocaleString('pt-BR')}</p>
-          <p><strong>Cliente:</strong> ${order.customer_name || 'N/A'}</p>
-          <p><strong>Email:</strong> ${order.customer_email || 'N/A'}</p>
-        </div>
-        <div class="total">
-          <p>TOTAL: R$ ${Number(order.total).toFixed(2)}</p>
-        </div>
-        <div style="margin-top: 40px; text-align: center; color: #666; font-size: 12px;">
-          <p>Este √© um documento simplificado. Para nota fiscal oficial, entre em contato.</p>
-        </div>
-      </body>
-      </html>
-    `;
-
-    res.setHeader('Content-Type', 'text/html');
-    res.send(html);
-  } catch (error) {
-    logger.logError(error, req);
-    res.status(500).json({ error: 'Erro ao gerar nota fiscal' });
-  }
-});
-
-// ==================== FORNECEDORES/SUPPLIERS API ====================
-
-// Buscar todos os fornecedores
-app.get('/api/suppliers', async (req, res) => {
-  try {
-    console.log('üîç Iniciando busca de fornecedores...');
-
-    // Primeiro, verificar se a tabela existe e criar se necess√°rio
-    console.log('üìã Verificando/criando tabela fornecedores...');
-    await pool.execute(`
-      CREATE TABLE IF NOT EXISTS fornecedores (
-        id INT AUTO_INCREMENT PRIMARY KEY,
-        nome VARCHAR(255) NOT NULL,
-        email VARCHAR(255),
-        telefone VARCHAR(20),
-        endereco TEXT,
-        cnpj VARCHAR(20),
-        total_expenses DECIMAL(10,2) DEFAULT 0,
-        last_payment DATE,
-        status ENUM('ativo', 'inativo') DEFAULT 'ativo',
-        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
-        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
-      ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci
-    `);
-    console.log('‚úÖ Tabela fornecedores verificada/criada');
-
-    // Inserir dados de exemplo se a tabela estiver vazia
-    console.log('üî¢ Verificando quantidade de fornecedores...');
-    const [countRows] = await pool.execute('SELECT COUNT(*) as count FROM fornecedores');
-    console.log('üìä Quantidade atual:', countRows[0].count);
-
-    if (countRows[0].count === 0) {
-      console.log('‚ûï Inserindo dados de exemplo...');
-      await pool.execute(`
-        INSERT INTO fornecedores (nome, email, telefone, total_expenses, last_payment, status) VALUES
-        ('Brinquedos ABC Ltda', 'contato@abcbrinquedos.com', '(11) 99999-1111', 1200.00, CURDATE() - INTERVAL 1 DAY, 'ativo'),
-        ('Educacional XYZ', 'vendas@educacionalxyz.com', '(11) 99999-2222', 890.00, CURDATE() - INTERVAL 2 DAY, 'ativo'),
-        ('Distribuidora Kids', 'info@distribuidorakids.com', '(11) 99999-3333', 1560.00, CURDATE() - INTERVAL 3 DAY, 'ativo'),
-        ('Importadora Toys', 'contato@importadoratoys.com', '(11) 99999-4444', 2340.00, CURDATE() - INTERVAL 4 DAY, 'ativo')
-      `);
-      console.log('‚úÖ Dados de exemplo inseridos');
-    }
-
-    console.log('üì• Buscando fornecedores...');
-    const [rows] = await pool.execute(`
-      SELECT 
-        id,
-        nome,
-        email,
-        telefone,
-        endereco,
-        cnpj,
-        total_expenses,
-        last_payment,
-        status,
-        created_at,
-        updated_at
-      FROM fornecedores 
-      ORDER BY nome ASC
-    `);
-
-    console.log('‚úÖ Fornecedores carregados:', rows.length);
-    logger.info('Fornecedores carregados', { count: rows.length });
-    res.json({ suppliers: rows, total: rows.length });
-  } catch (error) {
-    console.error('‚ùå ERRO ao buscar fornecedores:', error);
-    console.error('‚ùå Stack:', error.stack);
-    logger.logError(error, req);
-    res.status(500).json({ error: 'Erro ao buscar fornecedores', details: error.message });
-  }
-});
-
-// Buscar fornecedor por ID
-app.get('/api/suppliers/:id', async (req, res) => {
-  try {
-    const { id } = req.params;
-    const [rows] = await pool.execute('SELECT * FROM fornecedores WHERE id = ?', [id]);
-
-    if (rows.length === 0) {
-      return res.status(404).json({ error: 'Fornecedor n√£o encontrado' });
-    }
-
-    res.json(rows[0]);
-  } catch (error) {
-    logger.logError(error, req);
-    res.status(500).json({ error: 'Erro ao buscar fornecedor' });
-  }
-});
-
-// Criar fornecedor
-app.post('/api/suppliers', async (req, res) => {
-  try {
-    const { nome, cnpj, telefone, email, endereco, cidade, estado, cep, contato } = req.body;
-    const id = crypto.randomUUID();
-
-    await pool.execute(`
-      INSERT INTO fornecedores (id, nome, cnpj, telefone, email, endereco, cidade, estado, cep, contato)
-      VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
-    `, [id, nome, cnpj || null, telefone || null, email || null, endereco || null, cidade || null, estado || null, cep || null, contato || null]);
-
-    logger.info('Fornecedor criado', { id, nome });
-    res.json({ success: true, id });
-  } catch (error) {
-    logger.logError(error, req);
-    res.status(500).json({ error: 'Erro ao criar fornecedor' });
-  }
-});
-
-// Atualizar fornecedor
-app.put('/api/suppliers/:id', async (req, res) => {
-  try {
-    const { id } = req.params;
-    const { nome, cnpj, telefone, email, endereco, cidade, estado, cep, contato } = req.body;
-
-    await pool.execute(`
-      UPDATE fornecedores 
-      SET nome = ?, cnpj = ?, telefone = ?, email = ?, endereco = ?, cidade = ?, estado = ?, cep = ?, contato = ?, updated_at = NOW()
-      WHERE id = ?
-    `, [nome, cnpj || null, telefone || null, email || null, endereco || null, cidade || null, estado || null, cep || null, contato || null, id]);
-
-    logger.info('Fornecedor atualizado', { id, nome });
-    res.json({ success: true });
-  } catch (error) {
-    logger.logError(error, req);
-    res.status(500).json({ error: 'Erro ao atualizar fornecedor' });
-  }
-});
-
-// Deletar fornecedor
-app.delete('/api/suppliers/:id', async (req, res) => {
-  try {
-    const { id } = req.params;
-    await pool.execute('DELETE FROM fornecedores WHERE id = ?', [id]);
-
-    logger.info('Fornecedor deletado', { id });
-    res.json({ success: true });
-  } catch (error) {
-    logger.logError(error, req);
-    res.status(500).json({ error: 'Erro ao deletar fornecedor' });
-  }
-});
-
-// ==================== MERCADO PAGO INTEGRATION ====================
-const {
-  initializeMercadoPago,
-  createPaymentPreference,
-  getPaymentInfo,
-  processWebhookNotification,
-  createPixPayment,
-} = require('../config/mercadopago.cjs');
-
-// Inicializar Mercado Pago
-initializeMercadoPago();
-
-// Inicializar servi√ßo de e-mail
-initializeEmailService();
-
-// Inicializar agendador de recupera√ß√£o de carrinho
-initializeScheduler(pool);
-scheduleMonthlyCleanup();
-
-// Inicializar Redis (opcional - funciona sem)
-redisCache.initializeRedis();
-
-// Inicializar Push Notifications
-const pushNotifications = require('../config/pushNotifications.cjs');
-pushNotifications.initializePushNotifications();
-
-// Criar prefer√™ncia de pagamento
-app.post('/api/payments/mercadopago/create-preference', async (req, res) => {
-  try {
-    const { items, payer, external_reference } = req.body;
-
-    const result = await createPaymentPreference({
-      items,
-      payer,
-      external_reference,
-    });
-
-    if (result.success) {
-      logger.info('Prefer√™ncia MP criada', { preference_id: result.preference_id });
-      res.json(result);
-    } else {
-      res.status(400).json(result);
-    }
-  } catch (error) {
-    logger.logError(error, req);
-    res.status(500).json({ success: false, error: error.message });
-  }
-});
-
-// Criar pagamento PIX via Mercado Pago
-app.post('/api/payments/mercadopago/pix', async (req, res) => {
-  try {
-    const { transaction_amount, description, payer, external_reference } = req.body;
-
-    const result = await createPixPayment({
-      transaction_amount,
-      description,
-      payer,
-      external_reference,
-    });
-
-    if (result.success) {
-      logger.info('PIX MP criado', { payment_id: result.payment_id });
-      res.json(result);
-    } else {
-      res.status(400).json(result);
-    }
-  } catch (error) {
-    logger.logError(error, req);
-    res.status(500).json({ success: false, error: error.message });
-  }
-});
-
-// Webhook do Mercado Pago
-app.post('/api/payments/mercadopago/webhook', async (req, res) => {
-  try {
-    logger.info('Webhook MP recebido', { body: req.body, query: req.query });
-
-    const notificationData = req.body;
-    const result = await processWebhookNotification(notificationData);
-
-    if (result.success && result.action_needed === 'confirm_order') {
-      // Atualizar status do pedido no banco
-      const externalRef = result.payment.external_reference;
-
-      // Aqui voc√™ pode atualizar o status do pedido no banco de dados
-      logger.info('Pedido aprovado via webhook', {
-        external_reference: externalRef,
-        payment_id: result.payment.id,
-        status: result.payment.status,
-      });
-    }
-
-    res.status(200).json({ success: true });
-  } catch (error) {
-    logger.logError(error, req);
-    res.status(500).json({ success: false, error: error.message });
-  }
-});
-
-// Verificar status de pagamento
-app.get('/api/payments/mercadopago/status/:paymentId', async (req, res) => {
-  try {
-    const { paymentId } = req.params;
-    const result = await getPaymentInfo(paymentId);
-
-    if (result.success) {
-      res.json(result);
-    } else {
-      res.status(404).json(result);
-    }
-  } catch (error) {
-    logger.logError(error, req);
-    res.status(500).json({ success: false, error: error.message });
-  }
-});
-
-// =============================================================================
-// ENDPOINT DE DIAGN√ìSTICO (ANTES DOS ERROR HANDLERS)
-// =============================================================================
-app.get('/api/debug/database', async (req, res) => {
-  try {
-    const connection = await pool.getConnection();
-    const [db] = await connection.query('SELECT DATABASE() as db');
-    const [tables] = await connection.query(`
-      SELECT TABLE_NAME 
-      FROM INFORMATION_SCHEMA.TABLES 
-      WHERE TABLE_SCHEMA = 'rare_toy_companion'
-      ORDER BY TABLE_NAME
-    `);
-    const [produtosCols] = await connection.query(`
-      SELECT COLUMN_NAME, DATA_TYPE, IS_NULLABLE
-      FROM INFORMATION_SCHEMA.COLUMNS 
-      WHERE TABLE_SCHEMA = 'rare_toy_companion' 
-      AND TABLE_NAME = 'produtos'
-      ORDER BY ORDINAL_POSITION
-    `);
-    const [fornecedoresCols] = await connection.query(`
-      SELECT COLUMN_NAME, DATA_TYPE, IS_NULLABLE
-      FROM INFORMATION_SCHEMA.COLUMNS 
-      WHERE TABLE_SCHEMA = 'rare_toy_companion' 
-      AND TABLE_NAME = 'fornecedores'
-      ORDER BY ORDINAL_POSITION
-    `);
-    connection.release();
-
-    res.json({
-      success: true,
-      currentDatabase: db[0].db,
-      poolConfig: {
-        database: pool.config?.database || 'n√£o definido',
-        host: pool.config?.host || 'n√£o definido',
-        user: pool.config?.user || 'n√£o definido'
-      },
-      environment: {
-        MYSQL_DATABASE: process.env.MYSQL_DATABASE,
-        DB_NAME: process.env.DB_NAME
-      },
-      tables: tables.map(t => t.TABLE_NAME),
-      produtosColumns: produtosCols.map(c => ({
-        name: c.COLUMN_NAME,
-        type: c.DATA_TYPE,
-        nullable: c.IS_NULLABLE
-      })),
-      fornecedoresColumns: fornecedoresCols.map(c => ({
-        name: c.COLUMN_NAME,
-        type: c.DATA_TYPE,
-        nullable: c.IS_NULLABLE
-      })),
-      timestamp: new Date().toISOString()
-    });
-  } catch (error) {
-    res.status(500).json({
-      success: false,
-      error: error.message,
-      code: error.code,
-      timestamp: new Date().toISOString()
-    });
-  }
-});
-
-// Health check endpoint
-app.get('/api/health', async (req, res) => {
-  try {
-    const connection = await pool.getConnection();
-    const [db] = await connection.query('SELECT DATABASE() as db');
-    connection.release();
-
-    res.json({
-      status: 'ok',
-      database: db[0].db,
-      timestamp: new Date().toISOString(),
-      uptime: process.uptime()
-    });
-  } catch (error) {
-    res.status(500).json({
-      status: 'error',
-      error: error.message,
-      timestamp: new Date().toISOString()
-    });
-  }
-});
-
-// Error handler global
-app.use((err, req, res, next) => {
-  logger.logError(err, req);
-  sentry.captureException(err, {
-    path: req.path,
-    method: req.method,
-    ip: req.ip,
-  });
-
-  res.status(err.status || 500).json({
-    error: process.env.NODE_ENV === 'production'
-      ? 'Erro interno do servidor'
-      : err.message,
-    ...(process.env.NODE_ENV !== 'production' && { stack: err.stack }),
-  });
-});
-
-// Start server
-app.listen(PORT, '0.0.0.0', () => {
-  console.log(`üöÄ Carousel API server running on port ${PORT}`);
-  console.log(`üìä Health check: http://localhost:${PORT}/api/health`);
-  console.log(`üé† Carousel API: http://localhost:${PORT}/api/carousel`);
-  console.log(`üí≥ Mercado Pago: Integrado`);
-  console.log(`üîç Sentry: ${sentry.isInitialized() ? 'Ativo' : 'Desabilitado'}`);
-  console.log(`‚ö° Redis: ${redisCache.isAvailable() ? 'Conectado' : 'Desabilitado'}`);
-});
-
-// Graceful shutdown
-process.on('SIGINT', async () => {
-  console.log('\nüõë Shutting down server...');
-
-  // Flush Sentry events
-  await sentry.flush(2000);
-
-  // Fechar conex√µes
-  await pool.end();
-
-  console.log('‚úÖ Server shut down gracefully');
-  process.exit(0);
-});
-
-app.get('/api/orders/:id', async (req, res) => {
-  try {
-    const { id } = req.params;
-    // Buscar pedido
-    const [orders] = await pool.execute('SELECT * FROM orders WHERE id = ?', [id]);
-    if (!Array.isArray(orders) || orders.length === 0) {
-      return res.status(404).json({ error: 'order_not_found' });
-    }
-    const order = orders[0];
-
-    // Buscar itens do pedido
-    let items;
-    try {
-      const [cols] = await pool.execute('DESCRIBE order_items');
-      const fields = Array.isArray(cols) ? cols.map((c) => c.Field) : [];
-      const nameCol = fields.includes('name') ? 'name' : (fields.includes('product_name') ? 'product_name' : null);
-      const imageCol = fields.includes('image_url') ? 'image_url' : (fields.includes('image') ? 'image' : null);
-      const sql = `SELECT order_id, product_id, ${nameCol || "'Produto' AS name"}, price, ${imageCol || "NULL AS image_url"}, quantity FROM order_items WHERE order_id = ?`;
-      const [rows] = await pool.execute(sql, [id]);
-      items = rows;
-    } catch {
-      const [rows] = await pool.execute('SELECT order_id, product_id, price, quantity FROM order_items WHERE order_id = ?', [id]);
-      items = rows.map((r) => ({ ...r, name: 'Produto', image_url: null }));
-    }
-
-    // Normaliza√ß√£o b√°sica de tipos e URLs
-    let normalizedItems = (items || []).map((it) => ({
-      order_id: it.order_id,
-      product_id: it.product_id,
-      name: it.name,
-      price: Number(it.price || 0),
-      image_url: it.image_url ? getPublicUrl(req, it.image_url) : null,
-      quantity: Number(it.quantity || 1),
-    }));
-
-    // Enriquecer com dados de products quando faltar name/imagem
-    try {
-      const missing = normalizedItems.filter(i => !i.image_url || !i.name || i.name === 'Produto');
-      const productIds = [...new Set(missing.map(i => i.product_id))];
-      if (productIds.length > 0) {
-        const placeholders = productIds.map(() => '?').join(',');
-        // Detectar colunas reais de products
-        let pRows;
-        try {
-          const [pCols] = await pool.execute('DESCRIBE products');
-          const pFields = Array.isArray(pCols) ? pCols.map(c => c.Field) : [];
-          const nameCol = pFields.includes('nome') ? 'nome' : (pFields.includes('name') ? 'name' : null);
-          const imgCol = pFields.includes('imagem_url') ? 'imagem_url'
-            : (pFields.includes('image_url') ? 'image_url'
-              : (pFields.includes('imagemUrl') ? 'imagemUrl'
-                : (pFields.includes('image') ? 'image' : null)));
-          const selectNome = nameCol ? nameCol : "NULL";
-          const selectImg = imgCol ? imgCol : "NULL";
-          const [rows] = await pool.query(
-            `SELECT id, ${selectNome} AS nome, ${selectImg} AS imagem_url FROM produtos WHERE id IN (${placeholders})`,
-            productIds
-          );
-          pRows = rows;
-        } catch (_e) {
-          // Fallback amplo
-          const [rows] = await pool.query(
-            `SELECT id, COALESCE(nome, name) AS nome, COALESCE(imagem_url, image_url) AS imagem_url FROM produtos WHERE id IN (${placeholders})`,
-            productIds
-          );
-          pRows = rows;
-        }
-        const map = new Map((pRows || []).map(r => [String(r.id), r]));
-        normalizedItems = normalizedItems.map(i => {
-          const needsName = !i.name || i.name === 'Produto';
-          const needsImage = !i.image_url;
-          if (needsName || needsImage) {
-            const p = map.get(String(i.product_id));
-            if (p) {
-              if (needsName) i.name = p.nome || 'Produto';
-              if (needsImage) i.image_url = p.imagem_url ? getPublicUrl(req, p.imagem_url) : null;
-            }
-          }
-          return i;
-        });
-      }
-    } catch { }
-
-    // Mapear campos conforme schema atual
-    const paymentMethod = order.payment_method || order.metodo_pagamento || null;
-    const shippingAddress = order.shipping_address || order.endereco || null;
-    const rawStatus = order.status;
-    let friendlyStatus = rawStatus || 'pending';
-    try {
-      if (rawStatus === 0) {
-        friendlyStatus = 'pending';
-      }
-    } catch (_e) { }
-
-    res.json({
-      id: order.id,
-      status: friendlyStatus,
-      total: Number(order.total || 0),
-      created_at: order.created_at || null,
-      nome: order.nome || null,
-      email: order.email || null,
-      telefone: order.telefone || null,
-      endereco: shippingAddress,
-      metodo_pagamento: paymentMethod,
-      items: normalizedItems,
-    });
-  } catch (e) {
-    console.error('Order detail error', e);
-    res.status(500).json({ error: 'order_detail_failed' });
-  }
-});
-
-app.post('/api/orders/:id/reorder', async (req, res) => {
-  try {
-    const { id } = req.params;
-    const cartId = getOrCreateCartId(req, res);
-
-    // Buscar itens do pedido
-    let items;
-    try {
-      const [cols] = await pool.execute('DESCRIBE order_items');
-      const fields = Array.isArray(cols) ? cols.map((c) => c.Field) : [];
-      const nameCol = fields.includes('name') ? 'name' : (fields.includes('product_name') ? 'product_name' : null);
-      const imageCol = fields.includes('image_url') ? 'image_url' : (fields.includes('image') ? 'image' : null);
-      const sql = `SELECT product_id, ${nameCol || "'Produto' AS name"}, price, ${imageCol || "NULL AS image_url"}, quantity FROM order_items WHERE order_id = ?`;
-      const [rows] = await pool.execute(sql, [id]);
-      items = rows;
-    } catch {
-      const [rows] = await pool.execute('SELECT product_id, price, quantity FROM order_items WHERE order_id = ?', [id]);
-      items = rows.map((r) => ({ ...r, name: 'Produto', image_url: null }));
-    }
-
-    if (!Array.isArray(items) || items.length === 0) {
-      return res.status(404).json({ error: 'order_items_not_found' });
-    }
-
-    // Inserir/atualizar no carrinho: somar quantidades se j√° existir mesmo product_id
-    for (const it of items) {
-      // Verificar se j√° existe item igual no carrinho
-      const [existing] = await pool.execute(
-        'SELECT id, quantity FROM cart_items WHERE cart_id = ? AND product_id = ? LIMIT 1',
-        [cartId, it.product_id]
-      );
-
-      if (Array.isArray(existing) && existing.length > 0) {
-        const current = existing[0];
-        await pool.execute('UPDATE cart_items SET quantity = ? WHERE id = ?', [Number(current.quantity) + Number(it.quantity || 1), current.id]);
-      } else {
-        await pool.execute(
-          'INSERT INTO cart_items (cart_id, product_id, name, price, image_url, quantity) VALUES (?,?,?,?,?,?)',
-          [cartId, it.product_id, it.name, it.price, it.image_url, it.quantity || 1]
-        );
-      }
-    }
-
-    // Retornar carrinho atualizado
-    const [cart] = await pool.execute('SELECT * FROM cart_items WHERE cart_id = ?', [cartId]);
-    res.json({ items: cart });
-  } catch (e) {
-    console.error('Order reorder error', e);
-    res.status(500).json({ error: 'order_reorder_failed' });
-  }
-});
-
-app.post('/api/orders/:id/resend', async (req, res) => {
-  try {
-    const { id } = req.params;
-    // Buscar pedido completo e usar email se existir
-    const [orders] = await pool.execute('SELECT * FROM orders WHERE id = ? LIMIT 1', [id]);
-    if (!Array.isArray(orders) || orders.length === 0) {
-      return res.status(404).json({ error: 'order_not_found' });
-    }
-    const order = orders[0];
-
-    // Buscar itens e enriquecer nome/imagem
-    const [items] = await pool.execute('SELECT product_id, quantity, price FROM order_items WHERE order_id = ?', [id]);
-    const productIds = [...new Set((items || []).map(i => i.product_id))];
-    let productsMap = new Map();
-    if (productIds.length > 0) {
-      const placeholders = productIds.map(() => '?').join(',');
-      const [pCols] = await pool.execute('DESCRIBE products');
-      const pFields = Array.isArray(pCols) ? pCols.map(c => c.Field) : [];
-      const nameCol = pFields.includes('nome') ? 'nome' : (pFields.includes('name') ? 'name' : null);
-      const imgCol = pFields.includes('imagem_url') ? 'imagem_url'
-        : (pFields.includes('image_url') ? 'image_url'
-          : (pFields.includes('imagemUrl') ? 'imagemUrl'
-            : (pFields.includes('image') ? 'image' : null)));
-      const selectNome = nameCol ? nameCol : "NULL";
-      const selectImg = imgCol ? imgCol : "NULL";
-      const [pRows] = await pool.query(`SELECT id, ${selectNome} AS nome, ${selectImg} AS imagem_url FROM produtos WHERE id IN (${placeholders})`, productIds);
-      productsMap = new Map((pRows || []).map(r => [String(r.id), r]));
-    }
-
-    const normalizedItems = (items || []).map((it) => {
-      const p = productsMap.get(String(it.product_id));
-      return {
-        product_id: it.product_id,
-        name: p?.nome || 'Produto',
-        image_url: p?.imagem_url ? getPublicUrl(req, p.imagem_url) : null,
-        quantity: Number(it.quantity || 1),
-        price: Number(it.price || 0),
-        total: Number(it.price || 0) * Number(it.quantity || 1)
-      };
-    });
-
-    const total = normalizedItems.reduce((acc, i) => acc + i.total, 0);
-    const createdAt = order.created_at || new Date();
-    const paymentMethod = order.payment_method || order.metodo_pagamento || '‚Äî';
-    const html = `
-<!doctype html>
-<html><head><meta charset="utf-8"/><title>Comprovante do Pedido ${order.id}</title>
-<style>
-body{font-family:ui-sans-serif,system-ui,Arial,sans-serif;color:#111}
-.wrap{max-width:640px;margin:24px auto;padding:24px;border:1px solid #eee;border-radius:12px}
-.h{font-size:20px;font-weight:700;margin:0 0 8px}
-.muted{color:#666}
-.row{display:flex;align-items:center;gap:10px}
-.item{display:flex;gap:12px;border-top:1px solid #eee;padding:12px 0}
-.img{width:56px;height:56px;object-fit:cover;border-radius:8px;border:1px solid #ddd}
-.right{text-align:right;margin-left:auto}
-.total{font-weight:700}
-</style></head>
-<body>
-  <div class="wrap">
-    <div class="h">Comprovante do Pedido ${order.id}</div>
-    <div class="muted">Realizado em ${new Date(createdAt).toLocaleString('pt-BR')}</div>
-    <div class="muted">Pagamento: ${paymentMethod.toUpperCase()}</div>
-    <div style="margin:16px 0"></div>
-    ${normalizedItems.map(i => `
-      <div class="item">
-        ${i.image_url ? `<img class="img" src="${i.image_url}" alt="${i.name}"/>` : '<div class="img" style="background:#f6f6f6"></div>'}
-        <div>
-          <div>${i.name}</div>
-          <div class="muted">Qtd: ${i.quantity} ‚Ä¢ Unit: R$ ${i.price.toFixed(2)}</div>
-        </div>
-        <div class="right">R$ ${i.total.toFixed(2)}</div>
-      </div>
-    `).join('')}
-    <div class="item" style="border-top:2px solid #ddd"></div>
-    <div class="row">
-      <div class="muted">Total</div>
-      <div class="right total">R$ ${total.toFixed(2)}</div>
-    </div>
-  </div>
-</body></html>`;
-
-    // Envio real por SMTP, se configurado
-    let sent = false;
-    try {
-      const h = process.env.SMTP_HOST;
-      const u = process.env.SMTP_USER;
-      const p = process.env.SMTP_PASS;
-      const from = process.env.SMTP_FROM || 'no-reply@localhost';
-      const to = (order.email && String(order.email)) || process.env.SMTP_TO || '';
-      if (h && u && p && from && to) {
-        const nodemailer = require('nodemailer');
-        const transporter = nodemailer.createTransport({
-          host: h,
-          port: Number(process.env.SMTP_PORT || 587),
-          secure: Boolean(process.env.SMTP_SECURE === 'true'),
-          auth: { user: u, pass: p }
-        });
-        await transporter.sendMail({
-          from,
-          to,
-          subject: `Comprovante do Pedido ${order.id}`,
-          html
-        });
-        sent = true;
-        console.log(`‚úâÔ∏è  Comprovante enviado para ${to} (pedido ${order.id})`);
-      } else {
-        console.log('‚ÑπÔ∏è SMTP n√£o configurado ou e-mail do pedido ausente. Pulando envio.');
-      }
-    } catch (err) {
-      console.error('Falha ao enviar e-mail SMTP', err);
-    }
-
-    // Retornar resultado e preview (√∫til para debug/UI)
-    console.log(`‚úâÔ∏è  Comprovante gerado para pedido ${order.id} (${normalizedItems.length} itens)`);
-    res.setHeader('Content-Type', 'application/json');
-    res.json({ ok: true, emailed: sent, preview_html: html });
-  } catch (e) {
-    console.error('Order resend error', e);
-    res.status(500).json({ error: 'order_resend_failed' });
-  }
-});
-
-app.get('/api/orders/:id/timeline', async (req, res) => {
-  try {
-    const { id } = req.params;
-    const [orders] = await pool.execute('SELECT id, status, created_at FROM orders WHERE id = ? LIMIT 1', [id]);
-    if (!Array.isArray(orders) || orders.length === 0) {
-      return res.status(404).json({ error: 'order_not_found' });
-    }
-    const order = orders[0];
-
-    // Timeline simples baseada no status atual
-    const createdAt = order.created_at || new Date();
-    const base = [{ status: 'criado', at: createdAt }];
-    const status = (order.status || 'criado').toLowerCase();
-    if (status === 'processando') base.push({ status: 'processando', at: createdAt });
-    if (status === 'em_transito' || status === 'em tr√¢nsito') base.push({ status: 'em_transito', at: createdAt });
-    if (status === 'entregue') base.push({ status: 'em_transito', at: createdAt }, { status: 'entregue', at: createdAt });
-
-    res.json(base);
-  } catch (e) {
-    console.error('Order timeline error', e);
-    res.status(500).json({ error: 'order_timeline_failed' });
-  }
-});
-
-// ==========================
-// Frete: cota√ß√£o simples por CEP e subtotal
-// ==========================
-app.post('/api/shipping/quote', async (req, res) => {
-  try {
-    const { cep, subtotal } = req.body || {};
-    const sub = Number(subtotal || 0);
-    // Regra simples: frete gr√°tis acima de 200; caso contr√°rio, base por regi√£o
-    if (sub >= 200) {
-      return res.json({ price: 0, estimated_days: 3, rule: 'free_over_200' });
-    }
-    // Heur√≠stica por prefixo de CEP
-    const cepStr = String(cep || '').replace(/\D/g, '');
-    const prefix = cepStr.slice(0, 2);
-    let base = 19.9; // padr√£o
-    let days = 5;
-    if (["01", "02", "03", "04", "05", "06", "07", "08", "09", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49"].includes(prefix)) { // Sudeste/Sul aproximado
-      base = 15.0; days = 4;
-    }
-    if (["50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69"].includes(prefix)) { // Centro-Oeste/Norte
-      base = 24.9; days = 7;
-    }
-    if (["70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99"].includes(prefix)) { // Nordeste/Norte
-      base = 29.9; days = 8;
-    }
-    res.json({ price: Number(base.toFixed(2)), estimated_days: days, rule: 'region_base' });
-  } catch (e) {
-    console.error('Shipping quote error', e);
-    res.status(500).json({ error: 'shipping_quote_failed' });
-  }
-});
-
-// ==========================
-// Cupons: valida√ß√£o simples
-// ==========================
-app.post('/api/coupons/validate', async (req, res) => {
-  try {
-    const { code, subtotal } = req.body || {};
-    const normalized = String(code || '').trim().toUpperCase();
-    const sub = Number(subtotal || 0);
-    if (!normalized) return res.status(400).json({ valid: false, reason: 'empty' });
-
-    if (normalized === 'FRETEGRATIS') {
-      if (sub >= 50) {
-        return res.json({ valid: true, type: 'shipping_free', min_subtotal: 50 });
-      }
-      return res.json({ valid: false, reason: 'min_subtotal', min_subtotal: 50 });
-    }
-
-    // Percentual: PERCENT10 => 10% de desconto sobre o subtotal
-    const percentMatch = normalized.match(/^PERCENT(\d{1,2})$/);
-    if (percentMatch) {
-      const pct = Math.max(0, Math.min(90, Number(percentMatch[1])));
-      if (pct > 0) {
-        return res.json({ valid: true, type: 'percent', percent: pct });
-      }
-    }
-
-    // Valor fixo: OFF50 => R$ 50,00 de desconto (limitado ao subtotal)
-    const amountMatch = normalized.match(/^OFF(\d{1,4})$/);
-    if (amountMatch) {
-      const amount = Math.max(1, Math.min(1000, Number(amountMatch[1])));
-      if (amount > 0) {
-        return res.json({ valid: true, type: 'amount', amount });
-      }
-    }
-
-    // Placeholder para mais cupons
-    return res.json({ valid: false, reason: 'not_found' });
-  } catch (e) {
-    console.error('Coupon validate error', e);
-    res.status(500).json({ error: 'coupon_validate_failed' });
-  }
-});
-
-// ==========================
-// Conta: altera√ß√£o de senha (simulado)
-// ==========================
-app.post('/api/account/password', async (req, res) => {
-  try {
-    const { senhaAtual, novaSenha } = req.body || {};
-    if (!novaSenha || String(novaSenha).length < 6) {
-      return res.status(400).json({ ok: false, error: 'weak_password' });
-    }
-    // Em um cen√°rio real: validar senhaAtual contra hash do usu√°rio autenticado e persistir hash da nova senha.
-    console.log('üîê Altera√ß√£o de senha solicitada');
-    return res.json({ ok: true });
-  } catch (e) {
-    console.error('Change password error', e);
-    res.status(500).json({ ok: false, error: 'change_password_failed' });
-  }
-});
-
-// ========== ENDPOINTS WHATSAPP ==========
-
-// Endpoint para obter configura√ß√µes WhatsApp
-app.get('/api/whatsapp/config', async (req, res) => {
-  try {
-    const [settingsRows] = await pool.execute(`
-      SELECT key_name, value_text 
-      FROM settings 
-      WHERE key_name IN ('whatsapp_webhook_url', 'whatsapp_token', 'whatsapp_phone_id', 'whatsapp_webhook_secret', 'whatsapp_auto_reply', 'whatsapp_welcome_message')
-    `);
-
-    const settings = {};
-    settingsRows.forEach(row => {
-      settings[row.key_name] = row.value_text;
-    });
-
-    res.json({
-      success: true,
-      config: {
-        webhook_url: settings.whatsapp_webhook_url || '',
-        token: settings.whatsapp_token ? '***' + settings.whatsapp_token.slice(-4) : '',
-        phone_id: settings.whatsapp_phone_id || '',
-        webhook_secret: settings.whatsapp_webhook_secret ? '***' + settings.whatsapp_webhook_secret.slice(-4) : '',
-        auto_reply: settings.whatsapp_auto_reply === 'true',
-        welcome_message: settings.whatsapp_welcome_message || 'Ol√°! Como posso ajud√°-lo hoje?'
-      }
-    });
-  } catch (e) {
-    console.error('WhatsApp config error', e);
-    res.status(500).json({ error: 'config_fetch_failed' });
-  }
-});
-
-// Endpoint para salvar configura√ß√µes WhatsApp
-app.put('/api/whatsapp/config', async (req, res) => {
-  try {
-    const { webhook_url, token, phone_id, webhook_secret, auto_reply, welcome_message } = req.body;
-
-    const settings = [
-      ['whatsapp_webhook_url', webhook_url],
-      ['whatsapp_token', token],
-      ['whatsapp_phone_id', phone_id],
-      ['whatsapp_webhook_secret', webhook_secret],
-      ['whatsapp_auto_reply', auto_reply ? 'true' : 'false'],
-      ['whatsapp_welcome_message', welcome_message]
-    ];
-
-    for (const [key, value] of settings) {
-      if (value !== undefined) {
-        await pool.execute(`
-          INSERT INTO settings (key_name, value_text, updated_at) 
-          VALUES (?, ?, NOW()) 
-          ON DUPLICATE KEY UPDATE value_text = VALUES(value_text), updated_at = NOW()
-        `, [key, value]);
-      }
-    }
-
-    res.json({ success: true, message: 'Configura√ß√µes WhatsApp salvas com sucesso!' });
-  } catch (e) {
-    console.error('WhatsApp config save error', e);
-    res.status(500).json({ error: 'config_save_failed' });
-  }
-});
-
-// Endpoint para testar webhook WhatsApp
-app.post('/api/whatsapp/test-webhook', async (req, res) => {
-  try {
-    const { webhook_url } = req.body;
-
-    if (!webhook_url) {
-      return res.status(400).json({ error: 'URL do webhook √© obrigat√≥ria' });
-    }
-
-    // Simular teste do webhook
-    const testData = {
-      test: true,
-      message: 'Teste de webhook realizado com sucesso!',
-      timestamp: new Date().toISOString()
-    };
-
-    // Aqui voc√™ faria uma requisi√ß√£o real para testar o webhook
-    // const response = await fetch(webhook_url, { method: 'POST', body: JSON.stringify(testData) });
-
-    res.json({
-      success: true,
-      message: 'Webhook testado com sucesso!',
-      test_data: testData
-    });
-  } catch (e) {
-    console.error('WhatsApp webhook test error', e);
-    res.status(500).json({ error: 'webhook_test_failed' });
-  }
-});
-
-// Endpoint para obter estat√≠sticas WhatsApp
-app.get('/api/whatsapp/stats', async (req, res) => {
-  try {
-    // Verificar se a tabela existe
-    const [tableExists] = await pool.execute(`
-      SELECT COUNT(*) as count 
-      FROM information_schema.tables 
-      WHERE table_schema = DATABASE() AND table_name = 'whatsapp_messages'
-    `);
-
-    if (tableExists[0].count === 0) {
-      return res.json({
-        success: true,
-        stats: {
-          total_messages: 0,
-          incoming_messages: 0,
-          outgoing_messages: 0,
-          unique_contacts: 0,
-          messages_today: 0
-        }
-      });
-    }
-
-    const [stats] = await pool.execute(`
-      SELECT 
-        COUNT(*) as total_messages,
-        COUNT(CASE WHEN direction = 'incoming' THEN 1 END) as incoming_messages,
-        COUNT(CASE WHEN direction = 'outgoing' THEN 1 END) as outgoing_messages,
-        COUNT(DISTINCT from_phone) as unique_contacts,
-        COUNT(CASE WHEN DATE(timestamp) = CURDATE() THEN 1 END) as messages_today
-      FROM whatsapp_messages
-    `);
-
-    res.json({ success: true, stats: stats[0] });
-  } catch (e) {
-    console.error('WhatsApp stats error', e);
-    res.status(500).json({ error: 'stats_fetch_failed' });
-  }
-});
-
-// Endpoint para enviar mensagem WhatsApp
-app.post('/api/whatsapp/send-message', async (req, res) => {
-  try {
-    const { to, message } = req.body;
-
-    if (!to || !message) {
-      return res.status(400).json({ error: 'N√∫mero e mensagem s√£o obrigat√≥rios' });
-    }
-
-    // Buscar token WhatsApp
-    const [tokenRows] = await pool.execute('SELECT value_text FROM settings WHERE key_name = ?', ['whatsapp_token']);
-    const [phoneIdRows] = await pool.execute('SELECT value_text FROM settings WHERE key_name = ?', ['whatsapp_phone_id']);
-
-    if (tokenRows.length === 0 || phoneIdRows.length === 0) {
-      return res.status(400).json({ error: 'Token ou Phone ID do WhatsApp n√£o configurados' });
-    }
-
-    const token = tokenRows[0].value_text;
-    const phoneId = phoneIdRows[0].value_text;
-
-    // Enviar mensagem via WhatsApp API
-    const response = await fetch(`https://graph.facebook.com/v18.0/${phoneId}/messages`, {
-      method: 'POST',
-      headers: {
-        'Authorization': `Bearer ${token}`,
-        'Content-Type': 'application/json'
-      },
-      body: JSON.stringify({
-        messaging_product: 'whatsapp',
-        to: to,
-        type: 'text',
-        text: { body: message }
-      })
-    });
-
-    if (!response.ok) {
-      throw new Error('Falha ao enviar mensagem via WhatsApp API');
-    }
-
-    const result = await response.json();
-
-    res.json({
-      success: true,
-      message: 'Mensagem enviada com sucesso!',
-      whatsapp_response: result
-    });
-  } catch (e) {
-    console.error('WhatsApp send message error', e);
-    res.status(500).json({ error: 'message_send_failed' });
-  }
-});
-
-// Endpoint para obter mensagens WhatsApp
-app.get('/api/whatsapp/messages', async (req, res) => {
-  try {
-    const { page = 1, limit = 50 } = req.query;
-    const offset = (page - 1) * limit;
-
-    // Verificar se a tabela existe
-    const [tableExists] = await pool.execute(`
-      SELECT COUNT(*) as count 
-      FROM information_schema.tables 
-      WHERE table_schema = DATABASE() AND table_name = 'whatsapp_messages'
-    `);
-
-    if (tableExists[0].count === 0) {
-      return res.json({
-        success: true,
-        messages: [],
-        pagination: { page: 1, limit, total: 0, pages: 0 }
-      });
-    }
-
-    const [messages] = await pool.execute(`
-      SELECT * FROM whatsapp_messages 
-      ORDER BY timestamp DESC 
-      LIMIT ? OFFSET ?
-    `, [parseInt(limit), parseInt(offset)]);
-
-    const [totalRows] = await pool.execute('SELECT COUNT(*) as total FROM whatsapp_messages');
-    const total = totalRows[0].total;
-
-    res.json({
-      success: true,
-      messages,
-      pagination: {
-        page: parseInt(page),
-        limit: parseInt(limit),
-        total,
-        pages: Math.ceil(total / limit)
-      }
-    });
-  } catch (e) {
-    console.error('WhatsApp messages error', e);
-    res.status(500).json({ error: 'messages_fetch_failed' });
-  }
-});
-
-// ==========================
-// Conta: atualiza√ß√£o de perfil (simulado)
-// ==========================
-app.post('/api/account/profile', async (req, res) => {
-  try {
-    const { nome, email, telefone, avatar_url, endereco, cidade, estado, cep } = req.body || {};
-    // Em um cen√°rio real: atualizar tabela users vinculada ao auth
-    console.log('üë§ Atualiza√ß√£o de perfil:', { nome, email, telefone });
-    // Devolver os dados normalizados para o frontend atualizar contexto
-    res.json({ ok: true, user: { nome, email, telefone, avatar_url, endereco, cidade, estado, cep } });
-  } catch (e) {
-    console.error('Profile update error', e);
-    res.status(500).json({ ok: false, error: 'profile_update_failed' });
-  }
-});
-
-// ==========================
-// Auth simulado: me/logout para persistir sess√£o com cookie
-// ==========================
-// Endpoint /api/auth/me removido - usando o principal acima
-
-// NOTA: Endpoint de login mock removido - usando apenas o sistema de sess√£o principal
-
-// Rota de logout removida (consolidada na primeira ocorr√™ncia)
-
-// ==================== NOVOS ENDPOINTS MINHA CONTA ====================
-
-// Notifica√ß√µes
-app.get('/api/customers/:userId/notifications', async (req, res) => {
-  try {
-    let { userId } = req.params;
-    if (userId.includes('@')) {
-      const [user] = await pool.execute('SELECT id FROM users WHERE email = ?', [userId]);
-      if (user && user[0]) userId = user[0].id;
-      else return res.status(404).json({ error: 'Usu√°rio n√£o encontrado' });
-    }
-    const [notifications] = await pool.execute('SELECT * FROM customer_notifications WHERE customer_id = ? ORDER BY created_at DESC', [userId]);
-    res.json({ notifications });
-  } catch (error) {
-    res.status(500).json({ error: 'Erro ao buscar notifica√ß√µes', notifications: [] });
-  }
-});
-
-// Cupons
-app.get('/api/customers/:userId/coupons', async (req, res) => {
-  try {
-    let { userId } = req.params;
-    if (userId.includes('@')) {
-      const [user] = await pool.execute('SELECT id FROM users WHERE email = ?', [userId]);
-      if (user && user[0]) userId = user[0].id;
-    }
-    const [coupons] = await pool.execute('SELECT * FROM customer_coupons WHERE customer_id = ? ORDER BY created_at DESC', [userId]);
-    res.json({ coupons });
-  } catch (error) {
-    res.status(500).json({ error: 'Erro ao buscar cupons', coupons: [] });
-  }
-});
-
-// Fidelidade
-app.get('/api/customers/:userId/loyalty', async (req, res) => {
-  try {
-    let { userId } = req.params;
-    if (userId.includes('@')) {
-      const [user] = await pool.execute('SELECT id FROM users WHERE email = ?', [userId]);
-      if (user && user[0]) userId = user[0].id;
-    }
-    const [orders] = await pool.execute('SELECT COALESCE(SUM(total), 0) as totalSpent FROM orders WHERE user_id = ? AND status != "cancelled"', [userId]);
-    const totalSpent = Number(orders[0]?.totalSpent || 0);
-    const points = Math.floor(totalSpent / 10);
-    let level = 'Bronze', nextLevelPoints = 100;
-    if (points >= 500) { level = 'Platinum'; nextLevelPoints = 1000; }
-    else if (points >= 250) { level = 'Gold'; nextLevelPoints = 500; }
-    else if (points >= 100) { level = 'Silver'; nextLevelPoints = 250; }
-    res.json({ points, totalPoints: points, level, nextLevelPoints, couponsRedeemed: 0, totalSavings: totalSpent * 0.05 });
-  } catch (error) {
-    res.status(500).json({ error: 'Erro ao buscar fidelidade' });
-  }
-});
-
-// Reviews do cliente
-app.get('/api/customers/:userId/reviews', async (req, res) => {
-  try {
-    let { userId } = req.params;
-    if (userId.includes('@')) {
-      const [user] = await pool.execute('SELECT id FROM users WHERE email = ?', [userId]);
-      if (user && user[0]) userId = user[0].id;
-    }
-    const [reviews] = await pool.execute('SELECT r.*, p.nome as product_name, p.imagem_url as product_image FROM product_reviews r LEFT JOIN products p ON r.product_id = p.id WHERE r.user_id = ? ORDER BY r.created_at DESC', [userId]);
-    res.json({ reviews: reviews.map(r => ({ ...r, product: { id: r.product_id, nome: r.product_name, imagem_url: r.product_image } })) });
-  } catch (error) {
-    res.status(500).json({ error: 'Erro ao buscar avalia√ß√µes', reviews: [] });
-  }
-});
-
-// Stats de reviews
-app.get('/api/customers/:userId/review-stats', async (req, res) => {
-  try {
-    let { userId } = req.params;
-    if (userId.includes('@')) {
-      const [user] = await pool.execute('SELECT id FROM users WHERE email = ?', [userId]);
-      if (user && user[0]) userId = user[0].id;
-    }
-    const [stats] = await pool.execute('SELECT COUNT(*) as totalReviews, AVG(rating) as averageRating, SUM(helpful_count) as helpfulVotes, SUM(CASE WHEN featured = 1 THEN 1 ELSE 0 END) as featured FROM product_reviews WHERE user_id = ?', [userId]);
-    res.json(stats[0] || { totalReviews: 0, averageRating: 0, helpfulVotes: 0, featured: 0 });
-  } catch (error) {
-    res.status(500).json({ error: 'Erro', totalReviews: 0, averageRating: 0, helpfulVotes: 0, featured: 0 });
-  }
-});
-
-// NOTA: Endpoints de configura√ß√µes movidos para linha ~11682 (vers√£o atualizada)
-
-// Atualizar configura√ß√µes de privacidade
-app.put('/api/customers/:userId/settings/privacy', async (req, res) => {
-  try {
-    let { userId } = req.params;
-    console.log(`üìù PUT /api/customers/${userId}/settings/privacy`);
-
-    if (userId.includes('@')) {
-      const [user] = await pool.execute('SELECT id FROM users WHERE email = ?', [userId]);
-      if (user && user[0]) userId = user[0].id;
-    }
-
-    const privacySettings = req.body;
-
-    // Verificar se j√° existe configura√ß√£o
-    const [existing] = await pool.execute('SELECT id FROM customer_settings WHERE customer_id = ?', [userId]);
-
-    if (existing.length > 0) {
-      // Atualizar
-      await pool.execute(
-        'UPDATE customer_settings SET privacy = ? WHERE customer_id = ?',
-        [JSON.stringify(privacySettings), userId]
-      );
-    } else {
-      // Criar
-      await pool.execute(
-        'INSERT INTO customer_settings (id, customer_id, privacy) VALUES (?, ?, ?)',
-        [require('crypto').randomUUID(), userId, JSON.stringify(privacySettings)]
-      );
-    }
-
-    console.log(`‚úÖ Configura√ß√µes de privacidade atualizadas para ${userId}`);
-    res.json({ success: true, privacy: privacySettings });
-  } catch (error) {
-    console.error('‚ùå Erro ao atualizar configura√ß√µes de privacidade:', error);
-    res.status(500).json({ error: 'Erro ao atualizar configura√ß√µes' });
-  }
-});
-
-// Recomenda√ß√µes
-app.get('/api/customers/:userId/recommendations', async (req, res) => {
-  try {
-    let { userId } = req.params;
-    if (userId.includes('@')) {
-      const [user] = await pool.execute('SELECT id FROM users WHERE email = ?', [userId]);
-      if (user && user[0]) userId = user[0].id;
-    }
-    // Buscar email do usu√°rio para recommendations
-    const [userEmail] = await pool.execute('SELECT email FROM users WHERE id = ?', [userId]);
-    const email = userEmail[0]?.email || null;
-
-    if (!email) {
-      return res.json({ recommendations: [] });
-    }
-
-    const [products] = await pool.execute('SELECT p.* FROM products p LEFT JOIN favorites f ON p.id = f.product_id AND f.user_email = ? WHERE f.id IS NULL AND p.status = "ativo" ORDER BY p.created_at DESC LIMIT 10', [email]);
-    res.json({ recommendations: products });
-  } catch (error) {
-    res.status(500).json({ error: 'Erro', recommendations: [] });
-  }
-});
-
-// Insights de pedidos
-app.get('/api/customers/:userId/order-insights', async (req, res) => {
-  try {
-    let { userId } = req.params;
-    if (userId.includes('@')) {
-      const [user] = await pool.execute('SELECT id FROM users WHERE email = ?', [userId]);
-      if (user && user[0]) userId = user[0].id;
-    }
-    const [orders] = await pool.execute('SELECT AVG(total) as averageOrderValue, COUNT(*) as totalOrders, SUM(CASE WHEN status != "cancelled" THEN total ELSE 0 END) as totalSpent FROM orders WHERE user_id = ?', [userId]);
-    const stats = orders[0];
-    res.json({ averageOrderValue: Number(stats.averageOrderValue || 0), mostOrderedCategory: 'Brinquedos', favoritePaymentMethod: 'PIX', orderFrequency: 30, totalSavings: Number(stats.totalSpent || 0) * 0.05 });
-  } catch (error) {
-    res.status(500).json({ error: 'Erro', averageOrderValue: 0, mostOrderedCategory: 'N/A', favoritePaymentMethod: 'PIX', orderFrequency: 0, totalSavings: 0 });
-  }
-});
-
-// Pendentes de avalia√ß√£o
-app.get('/api/customers/:userId/pending-reviews', async (req, res) => {
-  try {
-    let { userId } = req.params;
-    if (userId.includes('@')) {
-      const [user] = await pool.execute('SELECT id FROM users WHERE email = ?', [userId]);
-      if (user && user[0]) userId = user[0].id;
-    }
-    const [products] = await pool.execute('SELECT DISTINCT p.id, p.nome, p.imagem_url, o.created_at as purchaseDate FROM orders o JOIN order_items oi ON o.id = oi.order_id JOIN products p ON oi.product_id = p.id LEFT JOIN product_reviews r ON r.product_id COLLATE utf8mb4_unicode_ci = p.id COLLATE utf8mb4_unicode_ci AND r.user_id COLLATE utf8mb4_unicode_ci = o.user_id COLLATE utf8mb4_unicode_ci WHERE o.user_id COLLATE utf8mb4_unicode_ci = ? COLLATE utf8mb4_unicode_ci AND o.status = "delivered" AND r.id IS NULL ORDER BY o.created_at DESC LIMIT 10', [userId]);
-    res.json({ products });
-  } catch (error) {
-    res.status(500).json({ error: 'Erro', products: [] });
-  }
-});
-
-// Estimativa de entrega
-app.post('/api/delivery-estimate', async (req, res) => {
-  const { estado } = req.body;
-  const regions = {
-    'SP': { days: '1-2', freight: '8.90', region: 'Sudeste' },
-    'RJ': { days: '1-3', freight: '9.90', region: 'Sudeste' },
-    'MG': { days: '2-4', freight: '12.90', region: 'Sudeste' },
-    'RS': { days: '3-5', freight: '15.90', region: 'Sul' },
-    'SC': { days: '3-5', freight: '14.90', region: 'Sul' },
-    'PR': { days: '2-4', freight: '13.90', region: 'Sul' },
-  };
-  res.json(regions[estado] || { days: '5-7', freight: '19.90', region: 'Outras' });
-});
-
-// ============================================
-// ROTAS DE LOGIN ADMINISTRATIVO
-// ============================================
-
-async function ensureAdminUsersTable() {
-  try {
-    await pool.execute(`
-      CREATE TABLE IF NOT EXISTS admin_users (
-        id INT AUTO_INCREMENT PRIMARY KEY,
-        nome VARCHAR(191) NULL,
-        email VARCHAR(191) UNIQUE NOT NULL,
-        telefone VARCHAR(50) NULL,
-        senha_hash VARCHAR(191) NOT NULL,
-        role VARCHAR(50) DEFAULT 'admin',
-        status VARCHAR(50) DEFAULT 'ativo',
-        permissoes TEXT NULL,
-        avatar VARCHAR(255) NULL,
-        must_change_password TINYINT(1) DEFAULT 0,
-        reset_token VARCHAR(255) NULL,
-        reset_expires DATETIME NULL,
-        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
-        updated_at DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
-        last_access DATETIME NULL
-      ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
-    `);
-    // Garantir colunas novas em instala√ß√µes antigas
-    try { await pool.execute("ALTER TABLE admin_users ADD COLUMN must_change_password TINYINT(1) DEFAULT 0"); } catch (_) { }
-    try { await pool.execute("ALTER TABLE admin_users ADD COLUMN reset_token VARCHAR(255) NULL"); } catch (_) { }
-    try { await pool.execute("ALTER TABLE admin_users ADD COLUMN reset_expires DATETIME NULL"); } catch (_) { }
-    // Garantir ao menos um admin
-    const [countRows] = await pool.execute('SELECT COUNT(*) AS total FROM admin_users');
-    const total = countRows && countRows[0] ? (countRows[0].total ?? countRows[0]['COUNT(*)'] ?? 0) : 0;
-    if (total === 0) {
-      const crypto = require('crypto');
-      const email = process.env.ADMIN_EMAIL || 'admin@muhlstore.com';
-      const nome = process.env.ADMIN_NAME || 'Administrador Principal';
-      const plain = process.env.ADMIN_PASSWORD || 'admin123';
-      const hash = crypto.createHash('sha256').update(plain).digest('hex');
-      await pool.execute(
-        'INSERT INTO admin_users (nome, email, senha_hash, role, status, permissoes, must_change_password, created_at) VALUES (?,?,?,?,?, ?, 1, NOW())',
-        [nome, email, hash, 'admin', 'ativo', '[]']
-      );
-      console.log('‚úÖ admin_users inicializado com usu√°rio padr√£o:', email);
-    }
-  } catch (e) {
-    console.error('‚ùå Falha ao garantir tabela admin_users:', e?.message || e);
-  }
-}
-
-// POST /api/admin/login - Login administrativo
-app.post('/api/admin/login', async (req, res) => {
-  try {
-    const { email, senha, password } = req.body || {};
-    const mail = String(email || '').trim().toLowerCase();
-    const pass = String(password || senha || '');
-
-    if (!mail || !pass) {
-      return res.status(400).json({
-        ok: false,
-        error: 'missing_credentials',
-        message: 'Email e senha s√£o obrigat√≥rios'
-      });
-    }
-
-    console.log(`üîê Tentativa de login admin: ${mail}`);
-
-    // Importar utilit√°rios de seguran√ßa
-    const { verifyPassword, generateAdminToken, generateRefreshToken, getSecureCookieOptions } = require('./utils/security.cjs');
-
-    // Garantir estrutura e buscar usu√°rio admin
-    await ensureAdminUsersTable();
-    let rows;
-    try {
-      [rows] = await pool.execute(
-        'SELECT id, nome, email, senha_hash, role, status, permissoes FROM admin_users WHERE email = ? LIMIT 1',
-        [mail]
-      );
-      console.log(`üîç Busca no banco: ${rows.length} usu√°rio(s) encontrado(s) para ${mail}`);
-    } catch (e) {
-      console.error(`‚ùå Erro ao buscar usu√°rio admin:`, e.message);
-      // Se a tabela n√£o existir por algum motivo, tenta criar e seguir
-      if (e && (e.code === 'ER_NO_SUCH_TABLE' || /doesn\'t exist/i.test(String(e.message)))) {
-        console.log(`‚ö†Ô∏è Tabela n√£o existe, criando...`);
-        await ensureAdminUsersTable();
-        [rows] = await pool.execute(
-          'SELECT id, nome, email, senha_hash, role, status, permissoes FROM admin_users WHERE email = ? LIMIT 1',
-          [mail]
-        );
-      } else {
-        throw e;
-      }
-    }
-
-    if (!Array.isArray(rows) || rows.length === 0) {
-      console.log(`‚ùå Usu√°rio admin n√£o encontrado: ${mail}`);
-      // Listar todos os emails de admin dispon√≠veis para debug (apenas em desenvolvimento)
-      try {
-        const [allAdmins] = await pool.execute('SELECT email, status FROM admin_users LIMIT 10');
-        console.log(`üìã Admins dispon√≠veis:`, allAdmins.map(a => `${a.email} (${a.status})`).join(', '));
-      } catch (e) {
-        console.log(`‚ö†Ô∏è N√£o foi poss√≠vel listar admins:`, e.message);
-      }
-      return res.status(401).json({
-        ok: false,
-        error: 'invalid_credentials',
-        message: 'Email ou senha incorretos'
-      });
-    }
-
-    const user = rows[0];
-
-    // Verificar se usu√°rio est√° ativo
-    if (user.status !== 'ativo') {
-      console.log(`‚ùå Usu√°rio admin inativo: ${mail}`);
-      return res.status(401).json({
-        ok: false,
-        error: 'account_inactive',
-        message: 'Conta inativa. Entre em contato com o administrador.'
-      });
-    }
-
-    // Verificar senha usando bcrypt (com compatibilidade SHA256)
-    const senhaCorreta = await verifyPassword(pass, user.senha_hash);
-
-    if (!senhaCorreta) {
-      console.log(`‚ùå Senha incorreta para: ${mail}`);
-      return res.status(401).json({
-        ok: false,
-        error: 'invalid_credentials',
-        message: 'Email ou senha incorretos'
-      });
-    }
-
-    // Se a senha estava em SHA256, migrar para bcrypt na pr√≥xima vez
-    // (n√£o bloqueamos o login, apenas sinalizamos que precisa migrar)
-    const needsMigration = !user.senha_hash.startsWith('$2');
-    if (needsMigration) {
-      console.log(`‚ö†Ô∏è Senha em SHA256 detectada para ${mail} - migra√ß√£o recomendada`);
-    }
-
-    // Gerar tokens JWT
-    const adminToken = generateAdminToken({
-      id: user.id,
-      email: user.email,
-      role: user.role
-    });
-
-    const refreshToken = generateRefreshToken({
-      id: user.id,
-      email: user.email
-    });
-
-    // Salvar tokens em cookies seguros
-    const cookieOptions = getSecureCookieOptions({
-      maxAge: 1000 * 60 * 60 * 24 * 7 // 7 dias
-    });
-
-    res.cookie('admin_token', adminToken, cookieOptions);
-    res.cookie('admin_refresh_token', refreshToken, getSecureCookieOptions({
-      maxAge: 1000 * 60 * 60 * 24 * 7 // 7 dias
-    }));
-
-    // Atualizar √∫ltimo acesso
-    await pool.execute('UPDATE admin_users SET last_access = NOW() WHERE id = ?', [user.id]);
-
-    // Registrar auditoria de login
-    const { logAudit } = require('./utils/audit.cjs');
-    await logAudit({
-      userId: user.id,
-      userEmail: user.email,
-      action: 'login',
-      resourceType: 'auth',
-      resourceId: String(user.id),
-      req,
-      metadata: {
-        role: user.role,
-        success: true
-      }
-    });
-
-    console.log(`‚úÖ Login admin bem-sucedido: ${mail} (${user.role}) - JWT gerado`);
-
-    res.json({
-      ok: true,
-      user: {
-        id: user.id,
-        nome: user.nome,
-        email: user.email,
-        role: user.role,
-        permissoes: user.permissoes ? JSON.parse(user.permissoes) : [],
-        change_required: user.must_change_password === 1
-      },
-      token: adminToken,
-      refreshToken: refreshToken,
-      needsPasswordMigration: needsMigration
-    });
-
-  } catch (error) {
-    console.error('‚ùå Erro no login admin:', { message: error?.message, code: error?.code });
-    res.status(500).json({
-      ok: false,
-      error: 'auth_error',
-      message: 'Erro interno do servidor'
-    });
-  }
-});
-
-// Compatibilidade: algumas instala√ß√µes antigas ainda chamam POST /login.
-// Redirecionamos para a mesma l√≥gica do login administrativo acima.
-app.post('/login', async (req, res) => {
-  // Redirecionar para o endpoint principal
-  req.url = '/api/admin/login';
-  req.baseUrl = '/api/admin';
-  return app._router.handle(req, res);
-});
-
-// Troca de senha (admin logado)
-app.post('/api/admin/change-password', async (req, res) => {
-  try {
-    const { verifyAdminToken } = require('./utils/security.cjs');
-    const { hashPassword } = require('./utils/security.cjs');
-
-    const token = req.cookies?.admin_token || req.headers['x-admin-token'] || req.headers.authorization?.replace('Bearer ', '');
-    if (!token) return res.status(401).json({ ok: false, error: 'unauthorized' });
-
-    // Verificar token (JWT ou legado)
-    const tokenData = verifyAdminToken(token);
-    if (!tokenData || tokenData.expired) {
-      return res.status(401).json({ ok: false, error: 'unauthorized' });
-    }
-
-    const userId = tokenData.legacy ? String(token).split('_').pop() : tokenData.id;
-    const { new_password } = req.body || {};
-
-    if (!new_password || String(new_password).length < 6) {
-      return res.status(400).json({ ok: false, error: 'weak_password', message: 'Senha deve ter no m√≠nimo 6 caracteres' });
-    }
-
-    // Gerar hash bcrypt
-    const hash = await hashPassword(String(new_password));
-    await pool.execute('UPDATE admin_users SET senha_hash = ?, must_change_password = 0, updated_at = NOW() WHERE id = ?', [hash, userId]);
-
-    console.log(`‚úÖ Senha alterada para usu√°rio ID: ${userId}`);
-    return res.json({ ok: true, message: 'Senha alterada com sucesso' });
-  } catch (e) {
-    console.error('‚ùå change-password error:', e?.message || e);
-    res.status(500).json({ ok: false, error: 'change_failed' });
-  }
-});
-
-// Esqueci minha senha (gera token)
-app.post('/api/admin/forgot-password', async (req, res) => {
-  try {
-    const { email } = req.body || {};
-    const mail = String(email || '').trim().toLowerCase();
-    if (!mail) return res.status(400).json({ ok: false, error: 'missing_email' });
-    const [rows] = await pool.execute('SELECT id FROM admin_users WHERE email = ? LIMIT 1', [mail]);
-    if (!Array.isArray(rows) || rows.length === 0) return res.json({ ok: true }); // n√£o revelar
-    const id = rows[0].id;
-    const token = require('crypto').randomUUID();
-    const expires = new Date(Date.now() + 1000 * 60 * 30); // 30 min
-    await pool.execute('UPDATE admin_users SET reset_token = ?, reset_expires = ? WHERE id = ?', [token, expires, id]);
-    const resetUrl = `${req.protocol}://${req.get('host')}/admin/reset?token=${token}`;
-    console.log('üîê Link de reset admin:', resetUrl);
-    res.json({ ok: true });
-  } catch (e) {
-    console.error('‚ùå forgot-password error:', e?.message || e);
-    res.status(500).json({ ok: false, error: 'forgot_failed' });
-  }
-});
-
-// Resetar senha via token
-app.post('/api/admin/reset-password', async (req, res) => {
-  try {
-    const { hashPassword } = require('./utils/security.cjs');
-
-    const { token, new_password } = req.body || {};
-    if (!token || !new_password) {
-      return res.status(400).json({ ok: false, error: 'missing_params', message: 'Token e nova senha s√£o obrigat√≥rios' });
-    }
-
-    if (String(new_password).length < 6) {
-      return res.status(400).json({ ok: false, error: 'weak_password', message: 'Senha deve ter no m√≠nimo 6 caracteres' });
-    }
-
-    const [rows] = await pool.execute('SELECT id, reset_expires FROM admin_users WHERE reset_token = ? LIMIT 1', [token]);
-    if (!Array.isArray(rows) || rows.length === 0) {
-      return res.status(400).json({ ok: false, error: 'invalid_token', message: 'Token inv√°lido' });
-    }
-
-    const expires = rows[0].reset_expires ? new Date(rows[0].reset_expires) : null;
-    if (!expires || expires.getTime() < Date.now()) {
-      return res.status(400).json({ ok: false, error: 'expired_token', message: 'Token expirado' });
-    }
-
-    // Gerar hash bcrypt
-    const hash = await hashPassword(String(new_password));
-    await pool.execute(
-      'UPDATE admin_users SET senha_hash = ?, must_change_password = 0, reset_token = NULL, reset_expires = NULL, updated_at = NOW() WHERE id = ?',
-      [hash, rows[0].id]
-    );
-
-    console.log(`‚úÖ Senha resetada para usu√°rio ID: ${rows[0].id}`);
-    res.json({ ok: true, message: 'Senha resetada com sucesso' });
-  } catch (e) {
-    console.error('‚ùå reset-password error:', e?.message || e);
-    res.status(500).json({ ok: false, error: 'reset_failed' });
-  }
-});
-
-// Seed protegido para criar admins iniciais
-app.post('/api/admin/seed', async (req, res) => {
-  try {
-    const setupToken = req.headers['x-setup-token'] || req.query.token;
-    const expected = process.env.ADMIN_SETUP_TOKEN || null;
-    if (!expected || setupToken !== expected) return res.status(401).json({ ok: false, error: 'invalid_setup_token' });
-    await ensureAdminUsersTable();
-    const users = Array.isArray(req.body?.users) ? req.body.users : [];
-    const crypto = require('crypto');
-    let created = 0;
-    for (const u of users) {
-      const email = String(u.email || '').trim().toLowerCase();
-      if (!email) continue;
-      const [exists] = await pool.execute('SELECT id FROM admin_users WHERE email = ? LIMIT 1', [email]);
-      if (Array.isArray(exists) && exists.length > 0) continue;
-      const hash = crypto.createHash('sha256').update(String(u.password || 'admin123')).digest('hex');
-      await pool.execute('INSERT INTO admin_users (nome, email, senha_hash, role, status, permissoes, must_change_password, created_at) VALUES (?,?,?,?,?, ?, ?, NOW())', [u.nome || 'Administrador', email, hash, u.role || 'admin', u.status || 'ativo', JSON.stringify(u.permissoes || []), u.must_change_password ? 1 : 0]);
-      created++;
-    }
-    res.json({ ok: true, created });
-  } catch (e) {
-    console.error('‚ùå admin seed error:', e?.message || e);
-    res.status(500).json({ ok: false, error: 'seed_failed' });
-  }
-});
-
-// GET /api/admin/me - Verificar sess√£o admin
-app.get('/api/admin/me', async (req, res) => {
-  try {
-    const adminToken = req.cookies?.admin_token || req.headers['x-admin-token'];
-
-    if (!adminToken || !adminToken.startsWith('admin_token_')) {
-      return res.status(401).json({
-        authenticated: false,
-        message: 'Token de admin n√£o encontrado'
-      });
-    }
-
-    // Extrair ID do usu√°rio do token
-    const userId = adminToken.split('_')[2];
-
-    if (!userId) {
-      return res.status(401).json({
-        authenticated: false,
-        message: 'Token inv√°lido'
-      });
-    }
-
-    // Buscar usu√°rio
-    const [rows] = await pool.execute(
-      'SELECT id, nome, email, role, status, permissoes FROM admin_users WHERE id = ? AND status = "ativo"',
-      [userId]
-    );
-
-    if (!Array.isArray(rows) || rows.length === 0) {
-      return res.status(401).json({
-        authenticated: false,
-        message: 'Usu√°rio n√£o encontrado ou inativo'
-      });
-    }
-
-    const user = rows[0];
-
-    res.json({
-      authenticated: true,
-      user: {
-        id: user.id,
-        nome: user.nome,
-        email: user.email,
-        role: user.role,
-        permissoes: user.permissoes ? JSON.parse(user.permissoes) : []
-      }
-    });
-
-  } catch (error) {
-    console.error('‚ùå Erro ao verificar sess√£o admin:', error);
-    res.status(500).json({
-      authenticated: false,
-      message: 'Erro interno do servidor'
-    });
-  }
-});
-
-// POST /api/admin/logout - Logout administrativo
-app.post('/api/admin/logout', async (req, res) => {
-  try {
-    res.clearCookie('admin_token');
-    res.json({ ok: true, message: 'Logout realizado com sucesso' });
-  } catch (error) {
-    console.error('‚ùå Erro no logout admin:', error);
-    res.status(500).json({
-      ok: false,
-      message: 'Erro interno do servidor'
-    });
-  }
-});
-
-// ============================================
-// ROTAS DE ANALYTICS E DASHBOARD ADMIN
-// ============================================
-
-// GET /api/admin/analytics/dashboard - M√©tricas principais do dashboard
-app.get('/api/admin/analytics/dashboard', authenticateAdmin, async (req, res) => {
-  try {
-    // Tentar cache primeiro
-    const cacheHelpers = require('./utils/cacheHelpers.cjs');
-    const period = req.query.period || '30';
-    const cached = await cacheHelpers.getCachedDashboardStats(period);
-
-    if (cached) {
-      console.log('‚úÖ Dashboard stats do cache');
-      return res.json(cached);
-    }
-
-    console.log('üìä Buscando m√©tricas do dashboard...');
-
-    // Data de hoje e ontem
-    const hoje = new Date().toISOString().split('T')[0];
-    const ontem = new Date(Date.now() - 24 * 60 * 60 * 1000).toISOString().split('T')[0];
-
-    // Vendas de hoje vs ontem
-    const [vendasHoje] = await pool.execute(`
-      SELECT COALESCE(SUM(total), 0) as total_hoje
-      FROM orders 
-      WHERE DATE(created_at) = ? AND status NOT IN ('cancelado', 'rejeitado')
-    `, [hoje]);
-
-    const [vendasOntem] = await pool.execute(`
-      SELECT COALESCE(SUM(total), 0) as total_ontem
-      FROM orders 
-      WHERE DATE(created_at) = ? AND status NOT IN ('cancelado', 'rejeitado')
-    `, [ontem]);
-
-    // Novos clientes hoje vs ontem
-    const [clientesHoje] = await pool.execute(`
-      SELECT COUNT(*) as total_hoje
-      FROM users 
-      WHERE DATE(created_at) = ?
-    `, [hoje]);
-
-    const [clientesOntem] = await pool.execute(`
-      SELECT COUNT(*) as total_ontem
-      FROM users 
-      WHERE DATE(created_at) = ?
-    `, [ontem]);
-
-    // Pedidos hoje vs ontem
-    const [pedidosHoje] = await pool.execute(`
-      SELECT COUNT(*) as total_hoje
-      FROM orders 
-      WHERE DATE(created_at) = ? AND status NOT IN ('cancelado', 'rejeitado')
-    `, [hoje]);
-
-    const [pedidosOntem] = await pool.execute(`
-      SELECT COUNT(*) as total_ontem
-      FROM orders 
-      WHERE DATE(created_at) = ? AND status NOT IN ('cancelado', 'rejeitado')
-    `, [ontem]);
-
-    // Produtos com baixo estoque
-    const [baixoEstoque] = await pool.execute(`
-      SELECT COUNT(*) as total
-      FROM produtos 
-      WHERE estoque <= 5 AND status = 'ativo'
-    `);
-
-    // Calcular varia√ß√µes percentuais
-    const vendasHojeVal = parseFloat(vendasHoje[0]?.total_hoje || 0);
-    const vendasOntemVal = parseFloat(vendasOntem[0]?.total_ontem || 0);
-    const variacaoVendas = vendasOntemVal > 0 ? ((vendasHojeVal - vendasOntemVal) / vendasOntemVal * 100) : 0;
-
-    const clientesHojeVal = parseInt(clientesHoje[0]?.total_hoje || 0);
-    const clientesOntemVal = parseInt(clientesOntem[0]?.total_ontem || 0);
-    const variacaoClientes = clientesOntemVal > 0 ? ((clientesHojeVal - clientesOntemVal) / clientesOntemVal * 100) : 0;
-
-    const pedidosHojeVal = parseInt(pedidosHoje[0]?.total_hoje || 0);
-    const pedidosOntemVal = parseInt(pedidosOntem[0]?.total_ontem || 0);
-    const variacaoPedidos = pedidosOntemVal > 0 ? ((pedidosHojeVal - pedidosOntemVal) / pedidosOntemVal * 100) : 0;
-
-    // Buscar totais gerais
-    const [totalStats] = await pool.execute(`
-      SELECT 
-        COUNT(DISTINCT o.id) as total_pedidos,
-        COALESCE(SUM(CASE WHEN o.status NOT IN ('cancelado', 'rejeitado') THEN o.total ELSE 0 END), 0) as receita_total,
-        COALESCE(AVG(CASE WHEN o.status NOT IN ('cancelado', 'rejeitado') THEN o.total ELSE NULL END), 0) as ticket_medio,
-        COUNT(DISTINCT o.user_id) as total_clientes
-      FROM orders o
-    `);
-
-    const [produtosStats] = await pool.execute(`
-      SELECT COUNT(*) as total FROM produtos WHERE status = 'ativo'
-    `);
-
-    const stats = totalStats[0] || {};
-    const totalProdutos = parseInt(produtosStats[0]?.total || 0);
-    const receitaTotal = parseFloat(stats.receita_total || 0);
-    const ticketMedio = parseFloat(stats.ticket_medio || 0);
-    const totalClientes = parseInt(stats.total_clientes || 0);
-    const totalPedidos = parseInt(stats.total_pedidos || 0);
-
-    const dashboard = {
-      vendas: {
-        hoje: vendasHojeVal,
-        ontem: vendasOntemVal,
-        variacao: variacaoVendas,
-        formato: 'currency'
-      },
-      clientes: {
-        hoje: clientesHojeVal,
-        ontem: clientesOntemVal,
-        variacao: variacaoClientes,
-        formato: 'number'
-      },
-      pedidos: {
-        hoje: pedidosHojeVal,
-        ontem: pedidosOntemVal,
-        variacao: variacaoPedidos,
-        formato: 'number'
-      },
-      estoque: {
-        baixo: parseInt(baixoEstoque[0]?.total || 0),
-        formato: 'number'
-      },
-      // Totais gerais
-      totalRevenue: receitaTotal,
-      totalOrders: totalPedidos,
-      totalCustomers: totalClientes,
-      totalProducts: totalProdutos,
-      averageOrderValue: ticketMedio,
-      conversionRate: 0, // Ser√° calculado se necess√°rio
-      // Varia√ß√µes
-      revenueChange: variacaoVendas,
-      ordersChange: variacaoPedidos,
-      customersChange: variacaoClientes,
-      productsChange: 0,
-      aovChange: 0,
-      conversionChange: 0
-    };
-
-    // Cachear resultado
-    await cacheHelpers.setCachedDashboardStats(period, dashboard);
-
-    console.log('‚úÖ M√©tricas do dashboard carregadas');
-    res.json(dashboard);
-
-  } catch (error) {
-    console.error('‚ùå Erro ao buscar m√©tricas do dashboard:', error);
-    res.status(500).json({ error: 'Erro interno do servidor', message: error?.message });
-  }
-});
-
-// GET /api/admin/analytics/vendas - Gr√°fico de vendas dos √∫ltimos 30 dias
-app.get('/api/admin/analytics/vendas', authenticateAdmin, async (req, res) => {
-  try {
-    console.log('üìà Buscando dados de vendas...');
-
-    const [vendasData] = await pool.execute(`
-      SELECT 
-        DATE(created_at) as data,
-        COUNT(*) as pedidos,
-        COALESCE(SUM(total), 0) as total
-      FROM orders 
-      WHERE created_at >= DATE_SUB(CURDATE(), INTERVAL 30 DAY)
-        AND status NOT IN ('cancelado', 'rejeitado')
-      GROUP BY DATE(created_at)
-      ORDER BY data ASC
-    `);
-
-    console.log(`‚úÖ ${vendasData.length} dias de vendas carregados`);
-    res.json(vendasData);
-
-  } catch (error) {
-    console.error('‚ùå Erro ao buscar dados de vendas:', error);
-    res.status(500).json({ error: 'Erro interno do servidor', message: error?.message });
-  }
-});
-
-// GET /api/admin/analytics/produtos-populares - Top 10 produtos mais vendidos
-app.get('/api/admin/analytics/produtos-populares', authenticateAdmin, async (req, res) => {
-  try {
-    console.log('üèÜ Buscando produtos populares...');
-
-    // Query corrigida para evitar problemas de collation
-    const [produtosData] = await pool.execute(`
-      SELECT 
-        p.id,
-        p.nome,
-        p.preco,
-        p.imagem_url,
-        COUNT(oi.product_id) as vendas,
-        SUM(oi.quantity) as quantidade_vendida,
-        COALESCE(SUM(oi.quantity * oi.price), 0) as receita_total
-      FROM produtos p
-      LEFT JOIN order_items oi ON p.id = oi.product_id COLLATE utf8mb4_unicode_ci
-      LEFT JOIN orders o ON oi.order_id = o.id COLLATE utf8mb4_unicode_ci
-      WHERE (o.status NOT IN ('cancelado', 'rejeitado') OR o.status IS NULL)
-      GROUP BY p.id, p.nome, p.preco, p.imagem_url
-      ORDER BY vendas DESC, quantidade_vendida DESC
-      LIMIT 10
-    `);
-
-    console.log(`‚úÖ ${produtosData.length} produtos populares carregados`);
-    res.json(produtosData);
-
-  } catch (error) {
-    console.error('‚ùå Erro ao buscar produtos populares:', error);
-    console.error('Detalhes:', error.message);
-
-    // Fallback: retornar produtos sem dados de vendas se houver erro
-    try {
-      console.log('üîÑ Tentando fallback sem JOIN...');
-      const [produtosFallback] = await pool.execute(`
-        SELECT 
-          id,
-          nome,
-          preco,
-          imagem_url,
-          0 as vendas,
-          0 as quantidade_vendida,
-          0 as receita_total
-        FROM produtos
-        ORDER BY nome
-        LIMIT 10
-      `);
-
-      console.log(`‚úÖ ${produtosFallback.length} produtos carregados (fallback)`);
-      res.json(produtosFallback);
-    } catch (fallbackError) {
-      console.error('‚ùå Erro no fallback:', fallbackError);
-      res.status(500).json({ error: 'Erro interno do servidor', message: 'N√£o foi poss√≠vel carregar produtos' });
-    }
-  }
-});
-
-// GET /api/admin/analytics/vendas-por-periodo - Vendas por per√≠odo
-app.get('/api/admin/analytics/vendas-por-periodo', authenticateAdmin, async (req, res) => {
-  try {
-    console.log('üìà Buscando vendas por per√≠odo...');
-
-    // Query simplificada para evitar problemas de colunas
-    const [vendasData] = await pool.execute(`
-      SELECT 
-        DATE(created_at) as data,
-        COUNT(*) as total_pedidos,
-        SUM(total) as total_vendas
-      FROM orders
-      WHERE created_at >= DATE_SUB(NOW(), INTERVAL 7 DAY)
-        AND status NOT IN ('cancelado', 'rejeitado')
-      GROUP BY DATE(created_at)
-      ORDER BY data DESC
-    `);
-
-    console.log(`‚úÖ Vendas por per√≠odo carregadas: ${vendasData.length} dias`);
-    res.json({
-      success: true,
-      vendas_7_dias: vendasData,
-      vendas_30_dias: [] // Simplificado por enquanto
-    });
-
-  } catch (error) {
-    console.error('‚ùå Erro ao buscar vendas por per√≠odo:', error);
-
-    // Fallback: retornar dados b√°sicos
-    try {
-      const [fallbackData] = await pool.execute(`
-        SELECT 
-          '2025-10-18' as data,
-          0 as total_pedidos,
-          0 as total_vendas
-      `);
-
-      res.json({
-        success: true,
-        vendas_7_dias: fallbackData,
-        vendas_30_dias: []
-      });
-    } catch (fallbackError) {
-      res.status(500).json({ error: 'Erro interno do servidor', message: 'N√£o foi poss√≠vel carregar vendas por per√≠odo' });
-    }
-  }
-});
-
-// GET /api/admin/analytics/pedidos-recentes - √öltimos 10 pedidos
-app.get('/api/admin/analytics/pedidos-recentes', authenticateAdmin, async (req, res) => {
-  try {
-    console.log('üì¶ Buscando pedidos recentes...');
-
-    const [pedidosData] = await pool.execute(`
-      SELECT 
-        o.id,
-        COALESCE(u.email, 'Cliente n√£o registrado') as user_email,
-        o.total,
-        o.status,
-        o.created_at,
-        COALESCE(o.metodo_pagamento, 'N√£o informado') as payment_method,
-        (SELECT COUNT(*) FROM order_items WHERE order_id = o.id) as itens_count
-      FROM orders o
-      LEFT JOIN users u ON o.user_id = u.id
-      WHERE o.status NOT IN ('cancelled', 'canceled', 'cancelado')
-      ORDER BY o.created_at DESC
-      LIMIT 10
-    `);
-
-    console.log(`‚úÖ ${pedidosData.length} pedidos recentes carregados`);
-    res.json(pedidosData);
-
-  } catch (error) {
-    console.error('‚ùå Erro ao buscar pedidos recentes:', error);
-    console.error('Detalhes:', error.message);
-    console.error('Stack:', error.stack);
-    res.status(500).json({ error: 'Erro interno do servidor', message: error?.message });
-  }
-});
-
-// GET /api/admin/analytics/estatisticas-gerais - Estat√≠sticas gerais do sistema
-app.get('/api/admin/analytics/estatisticas-gerais', authenticateAdmin, async (req, res) => {
-  try {
-    console.log('üìä Buscando estat√≠sticas gerais...');
-
-    // Total de produtos
-    const [totalProdutos] = await pool.execute('SELECT COUNT(*) as total FROM products WHERE status = "ativo"');
-
-    // Total de pedidos
-    const [totalPedidos] = await pool.execute('SELECT COUNT(*) as total FROM orders WHERE status NOT IN ("cancelado", "rejeitado")');
-
-    // Total de clientes
-    const [totalClientes] = await pool.execute('SELECT COUNT(*) as total FROM users');
-
-    // Receita total
-    const [receitaTotal] = await pool.execute('SELECT COALESCE(SUM(total), 0) as total FROM orders WHERE status NOT IN ("cancelado", "rejeitado")');
-
-    // Ticket m√©dio
-    const [ticketMedio] = await pool.execute(`
-      SELECT COALESCE(AVG(total), 0) as media 
-      FROM orders 
-      WHERE status NOT IN ("cancelado", "rejeitado")
-    `);
-
-    // Produtos mais vendidos (top 3)
-    const [topProdutos] = await pool.execute(`
-      SELECT 
-        p.nome,
-        SUM(oi.quantity) as quantidade
-      FROM products p
-      LEFT JOIN order_items oi ON p.id = oi.product_id
-      LEFT JOIN orders o ON oi.order_id = o.id
-      WHERE o.status NOT IN ('cancelado', 'rejeitado')
-      GROUP BY p.id, p.nome
-      ORDER BY quantidade DESC
-      LIMIT 3
-    `);
-
-    const estatisticas = {
-      produtos: {
-        total: parseInt(totalProdutos[0]?.total || 0),
-        ativos: parseInt(totalProdutos[0]?.total || 0)
-      },
-      pedidos: {
-        total: parseInt(totalPedidos[0]?.total || 0),
-        receita_total: parseFloat(receitaTotal[0]?.total || 0),
-        ticket_medio: parseFloat(ticketMedio[0]?.media || 0)
-      },
-      clientes: {
-        total: parseInt(totalClientes[0]?.total || 0)
-      },
-      top_produtos: topProdutos.map(p => ({
-        nome: p.nome,
-        quantidade: parseInt(p.quantidade || 0)
-      }))
-    };
-
-    console.log('‚úÖ Estat√≠sticas gerais carregadas');
-    res.json(estatisticas);
-
-  } catch (error) {
-    console.error('‚ùå Erro ao buscar estat√≠sticas gerais:', error);
-    res.status(500).json({ error: 'Erro interno do servidor', message: error?.message });
-  }
-});
-
-// ============================================
-// ROTAS DE BLOG E NOT√çCIAS
-// ============================================
-
-// GET /api/blog/posts - Listar posts do blog (p√∫blico)
-app.get('/api/blog/posts', async (req, res) => {
-  try {
-    const categoria = req.query.categoria;
-    const status = req.query.status || 'publicado';
-    const limit = parseInt(req.query.limit) || 10;
-    const offset = parseInt(req.query.offset) || 0;
-    const destaque = req.query.destaque;
-
-    let query = `
-      SELECT 
-        id, titulo, slug, resumo, categoria, imagem_url, imagem_destaque,
-        autor, autor_avatar, tempo_leitura, visualizacoes, destaque,
-        status, tags, publicado_em, created_at, updated_at
-      FROM blog_posts
-      WHERE status = ?
-    `;
-    const params = [status];
-
-    if (categoria) {
-      query += ' AND categoria = ?';
-      params.push(categoria);
-    }
-
-    if (destaque === 'true') {
-      query += ' AND destaque = 1';
-    }
-
-    query += ` ORDER BY publicado_em DESC, created_at DESC LIMIT ${limit} OFFSET ${offset}`;
-
-    const [posts] = await pool.execute(query, params);
-
-    // Parse tags JSON com tratamento de erro
-    const postsFormatted = posts.map(post => {
-      let tags = [];
-      try {
-        if (post.tags) {
-          tags = typeof post.tags === 'string' ? JSON.parse(post.tags) : post.tags;
-        }
-      } catch (e) {
-        console.error('Erro ao parsear tags:', e);
-        tags = [];
-      }
-
-      return {
-        ...post,
-        tags,
-        destaque: Boolean(post.destaque)
-      };
-    });
-
-    console.log(`‚úÖ ${postsFormatted.length} posts carregados`);
-    res.json(postsFormatted);
-
-  } catch (error) {
-    console.error('‚ùå Erro ao buscar posts:', error);
-    res.status(500).json({ error: 'Erro interno do servidor', message: error?.message });
-  }
-});
-
-// GET /api/blog/posts/:slug - Obter post espec√≠fico por slug
-app.get('/api/blog/posts/:slug', async (req, res) => {
-  try {
-    const { slug } = req.params;
-
-    console.log(`üì∞ Buscando post com slug: ${slug}`);
-
-    const [posts] = await pool.execute(
-      `SELECT 
-        id, titulo, slug, resumo, conteudo, categoria, imagem_url, imagem_destaque,
-        autor, autor_avatar, tempo_leitura, visualizacoes, destaque,
-        status, tags, meta_title, meta_description, meta_keywords,
-        publicado_em, created_at, updated_at
-      FROM blog_posts
-      WHERE slug = ? AND status = 'publicado'`,
-      [slug]
-    );
-
-    if (!posts || posts.length === 0) {
-      console.log(`‚ùå Post n√£o encontrado: ${slug}`);
-      return res.status(404).json({ error: 'Post n√£o encontrado' });
-    }
-
-    let tags = [];
-    try {
-      if (posts[0].tags) {
-        tags = typeof posts[0].tags === 'string' ? JSON.parse(posts[0].tags) : posts[0].tags;
-      }
-    } catch (e) {
-      console.error('Erro ao parsear tags:', e);
-    }
-
-    const post = {
-      ...posts[0],
-      tags,
-      destaque: Boolean(posts[0].destaque)
-    };
-
-    // Incrementar visualiza√ß√µes
-    await pool.execute(
-      'UPDATE blog_posts SET visualizacoes = visualizacoes + 1 WHERE id = ?',
-      [post.id]
-    );
-
-    console.log(`‚úÖ Post "${post.titulo}" carregado (${post.visualizacoes + 1} visualiza√ß√µes)`);
-    res.json(post);
-
-  } catch (error) {
-    console.error('‚ùå Erro ao buscar post:', error);
-    res.status(500).json({ error: 'Erro interno do servidor', message: error?.message });
-  }
-});
-
-// GET /api/blog/categorias - Listar categorias dispon√≠veis
-app.get('/api/blog/categorias', async (req, res) => {
-  try {
-    const [categorias] = await pool.execute(`
-      SELECT 
-        categoria,
-        COUNT(*) as total
-      FROM blog_posts
-      WHERE status = 'publicado'
-      GROUP BY categoria
-      ORDER BY total DESC
-    `);
-
-    res.json(categorias);
-
-  } catch (error) {
-    console.error('‚ùå Erro ao buscar categorias:', error);
-    res.status(500).json({ error: 'Erro interno do servidor', message: error?.message });
-  }
-});
-
-// ============================================
-// ROTAS ADMIN - BLOG E NOT√çCIAS
-// ============================================
-
-// GET /api/admin/blog/posts - Listar todos os posts (admin)
-app.get('/api/admin/blog/posts', async (req, res) => {
-  try {
-    const { status, categoria, busca } = req.query;
-
-    let query = `
-      SELECT 
-        id, titulo, slug, resumo, categoria, imagem_url,
-        autor, tempo_leitura, visualizacoes, destaque,
-        status, publicado_em, created_at, updated_at
-      FROM blog_posts
-      WHERE 1=1
-    `;
-    const params = [];
-
-    if (status) {
-      query += ' AND status = ?';
-      params.push(status);
-    }
-
-    if (categoria) {
-      query += ' AND categoria = ?';
-      params.push(categoria);
-    }
-
-    if (busca) {
-      query += ' AND (titulo LIKE ? OR resumo LIKE ? OR conteudo LIKE ?)';
-      const searchTerm = `%${busca}%`;
-      params.push(searchTerm, searchTerm, searchTerm);
-    }
-
-    query += ' ORDER BY created_at DESC';
-
-    const [posts] = await pool.execute(query, params);
-
-    const postsFormatted = posts.map(post => ({
-      ...post,
-      destaque: Boolean(post.destaque)
-    }));
-
-    console.log(`‚úÖ ${postsFormatted.length} posts admin carregados`);
-    res.json(postsFormatted);
-
-  } catch (error) {
-    console.error('‚ùå Erro ao buscar posts admin:', error);
-    res.status(500).json({ error: 'Erro interno do servidor', message: error?.message });
-  }
-});
-
-// GET /api/admin/blog/posts/:id - Obter post espec√≠fico (admin)
-app.get('/api/admin/blog/posts/:id', async (req, res) => {
-  try {
-    const { id } = req.params;
-
-    const [posts] = await pool.execute(
-      `SELECT * FROM blog_posts WHERE id = ?`,
-      [id]
-    );
-
-    if (posts.length === 0) {
-      return res.status(404).json({ error: 'Post n√£o encontrado' });
-    }
-
-    let tags = [];
-    try {
-      if (posts[0].tags) {
-        tags = typeof posts[0].tags === 'string' ? JSON.parse(posts[0].tags) : posts[0].tags;
-      }
-    } catch (e) {
-      console.error('Erro ao parsear tags:', e);
-    }
-
-    const post = {
-      ...posts[0],
-      tags,
-      destaque: Boolean(posts[0].destaque)
-    };
-
-    res.json(post);
-
-  } catch (error) {
-    console.error('‚ùå Erro ao buscar post admin:', error);
-    res.status(500).json({ error: 'Erro interno do servidor', message: error?.message });
-  }
-});
-
-// POST /api/admin/blog/posts - Criar novo post
-app.post('/api/admin/blog/posts', async (req, res) => {
-  try {
-    const {
-      titulo,
-      slug,
-      resumo,
-      conteudo,
-      categoria = 'Not√≠cias',
-      imagem_url,
-      imagem_destaque,
-      autor = 'Equipe MuhlStore',
-      autor_avatar,
-      tempo_leitura = 5,
-      destaque = false,
-      status = 'rascunho',
-      tags = [],
-      publicado_em
-    } = req.body;
-
-    if (!titulo || !resumo || !conteudo) {
-      return res.status(400).json({ error: 'T√≠tulo, resumo e conte√∫do s√£o obrigat√≥rios' });
-    }
-
-    // Validar URLs de imagens antes de salvar
-    let validImagemUrl = null;
-    let validImagemDestaque = null;
-
-    if (imagem_url) {
-      if (imageExists(imagem_url)) {
-        validImagemUrl = imagem_url;
-      } else {
-        console.warn(`‚ö†Ô∏è Imagem URL n√£o encontrada: ${imagem_url} - ser√° ignorada`);
-      }
-    }
-
-    if (imagem_destaque) {
-      if (imageExists(imagem_destaque)) {
-        validImagemDestaque = imagem_destaque;
-      } else {
-        console.warn(`‚ö†Ô∏è Imagem destaque n√£o encontrada: ${imagem_destaque} - ser√° ignorada`);
-      }
-    }
-
-    // Gerar slug se n√£o fornecido
-    const finalSlug = slug || titulo.toLowerCase()
-      .normalize('NFD').replace(/[\u0300-\u036f]/g, '') // Remove acentos
-      .replace(/[^a-z0-9\s-]/g, '') // Remove caracteres especiais
-      .replace(/\s+/g, '-') // Substitui espa√ßos por h√≠fens
-      .replace(/-+/g, '-') // Remove h√≠fens duplicados
-      .trim();
-
-    const newId = require('crypto').randomUUID();
-
-    const [result] = await pool.execute(
-      `INSERT INTO blog_posts (
-        id, titulo, slug, resumo, conteudo, categoria,
-        imagem_url, imagem_destaque, autor, autor_avatar,
-        tempo_leitura, destaque, status, tags, publicado_em
-      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
-      [
-        newId, titulo, finalSlug, resumo, conteudo, categoria,
-        validImagemUrl, validImagemDestaque, autor, autor_avatar,
-        tempo_leitura, destaque, status, JSON.stringify(tags),
-        publicado_em || (status === 'publicado' ? new Date() : null)
-      ]
-    );
-
-    console.log(`‚úÖ Post criado: ${titulo}`);
-    res.status(201).json({
-      id: newId,
-      titulo,
-      slug: finalSlug,
-      message: 'Post criado com sucesso'
-    });
-
-  } catch (error) {
-    console.error('‚ùå Erro ao criar post:', error);
-    if (error.code === 'ER_DUP_ENTRY') {
-      return res.status(400).json({ error: 'J√° existe um post com este slug' });
-    }
-    res.status(500).json({ error: 'Erro interno do servidor', message: error?.message });
-  }
-});
-
-// POST /api/admin/blog/clean-broken-images - Limpar imagens quebradas
-app.post('/api/admin/blog/clean-broken-images', async (req, res) => {
-  try {
-    // Buscar todos os posts com imagens
-    const [posts] = await pool.execute(
-      'SELECT id, titulo, imagem_url, imagem_destaque FROM blog_posts WHERE imagem_url IS NOT NULL OR imagem_destaque IS NOT NULL'
-    );
-
-    let cleaned = 0;
-    let errors = [];
-
-    for (const post of posts) {
-      let needsUpdate = false;
-      let newImagemUrl = post.imagem_url;
-      let newImagemDestaque = post.imagem_destaque;
-
-      // Verificar imagem_url
-      if (post.imagem_url && !imageExists(post.imagem_url)) {
-        console.warn(`‚ö†Ô∏è Limpando imagem quebrada: ${post.imagem_url} (post: ${post.titulo})`);
-        newImagemUrl = null;
-        needsUpdate = true;
-      }
-
-      // Verificar imagem_destaque
-      if (post.imagem_destaque && !imageExists(post.imagem_destaque)) {
-        console.warn(`‚ö†Ô∏è Limpando imagem destaque quebrada: ${post.imagem_destaque} (post: ${post.titulo})`);
-        newImagemDestaque = null;
-        needsUpdate = true;
-      }
-
-      if (needsUpdate) {
-        try {
-          await pool.execute(
-            'UPDATE blog_posts SET imagem_url = ?, imagem_destaque = ?, updated_at = NOW() WHERE id = ?',
-            [newImagemUrl, newImagemDestaque, post.id]
-          );
-          cleaned++;
-        } catch (error) {
-          errors.push(`Erro ao limpar post ${post.id}: ${error.message}`);
-        }
-      }
-    }
-
-    res.json({
-      success: true,
-      total: posts.length,
-      cleaned,
-      errors: errors.length > 0 ? errors : undefined,
-      message: `${cleaned} post(s) limpo(s) com sucesso`
-    });
-
-  } catch (error) {
-    console.error('‚ùå Erro ao limpar imagens quebradas:', error);
-    res.status(500).json({ error: 'Erro interno do servidor', message: error?.message });
-  }
-});
-
-// PUT /api/admin/blog/posts/:id - Atualizar post
-app.put('/api/admin/blog/posts/:id', async (req, res) => {
-  try {
-    const { id } = req.params;
-
-    // Validar URLs de imagens antes de atualizar
-    let validImagemUrl = undefined; // undefined = n√£o alterar, null = limpar, string = atualizar
-    let validImagemDestaque = undefined;
-
-    if (req.body.imagem_url !== undefined) {
-      if (req.body.imagem_url && imageExists(req.body.imagem_url)) {
-        validImagemUrl = req.body.imagem_url;
-      } else if (req.body.imagem_url) {
-        console.warn(`‚ö†Ô∏è Imagem URL n√£o encontrada: ${req.body.imagem_url} - ser√° ignorada`);
-        validImagemUrl = undefined; // N√£o alterar se n√£o existe
-      } else {
-        validImagemUrl = null; // Permite limpar a imagem (string vazia)
-      }
-    }
-
-    if (req.body.imagem_destaque !== undefined) {
-      if (req.body.imagem_destaque && imageExists(req.body.imagem_destaque)) {
-        validImagemDestaque = req.body.imagem_destaque;
-      } else if (req.body.imagem_destaque) {
-        console.warn(`‚ö†Ô∏è Imagem destaque n√£o encontrada: ${req.body.imagem_destaque} - ser√° ignorada`);
-        validImagemDestaque = undefined; // N√£o alterar se n√£o existe
-      } else {
-        validImagemDestaque = null; // Permite limpar a imagem
-      }
-    }
-    const {
-      titulo,
-      slug,
-      resumo,
-      conteudo,
-      categoria,
-      imagem_url,
-      imagem_destaque,
-      autor,
-      autor_avatar,
-      tempo_leitura,
-      destaque,
-      status,
-      tags,
-      publicado_em
-    } = req.body;
-
-    // Converter undefined para null
-    const tagsValue = tags !== undefined ? (Array.isArray(tags) ? JSON.stringify(tags) : tags) : null;
-
-    // Construir query UPDATE dinamicamente
-    const updateFields = [];
-    const updateValues = [];
-
-    if (titulo !== undefined) { updateFields.push('titulo = ?'); updateValues.push(titulo); }
-    if (slug !== undefined) { updateFields.push('slug = ?'); updateValues.push(slug); }
-    if (resumo !== undefined) { updateFields.push('resumo = ?'); updateValues.push(resumo); }
-    if (conteudo !== undefined) { updateFields.push('conteudo = ?'); updateValues.push(conteudo); }
-    if (categoria !== undefined) { updateFields.push('categoria = ?'); updateValues.push(categoria); }
-    if (validImagemUrl !== undefined) { updateFields.push('imagem_url = ?'); updateValues.push(validImagemUrl); }
-    if (validImagemDestaque !== undefined) { updateFields.push('imagem_destaque = ?'); updateValues.push(validImagemDestaque); }
-    if (autor !== undefined) { updateFields.push('autor = ?'); updateValues.push(autor); }
-    if (autor_avatar !== undefined) { updateFields.push('autor_avatar = ?'); updateValues.push(autor_avatar); }
-    if (tempo_leitura !== undefined) { updateFields.push('tempo_leitura = ?'); updateValues.push(tempo_leitura); }
-    if (destaque !== undefined) { updateFields.push('destaque = ?'); updateValues.push(destaque); }
-    if (status !== undefined) { updateFields.push('status = ?'); updateValues.push(status); }
-    if (tags !== undefined) { updateFields.push('tags = ?'); updateValues.push(tagsValue); }
-    if (publicado_em !== undefined) { updateFields.push('publicado_em = ?'); updateValues.push(publicado_em); }
-
-    updateFields.push('updated_at = NOW()');
-    updateValues.push(id);
-
-    const [result] = await pool.execute(
-      `UPDATE blog_posts SET ${updateFields.join(', ')} WHERE id = ?`,
-      updateValues
-    );
-
-    if (result.affectedRows === 0) {
-      return res.status(404).json({ error: 'Post n√£o encontrado' });
-    }
-
-    console.log(`‚úÖ Post atualizado: ${id}`);
-    res.json({ message: 'Post atualizado com sucesso' });
-
-  } catch (error) {
-    console.error('‚ùå Erro ao atualizar post:', error);
-    if (error.code === 'ER_DUP_ENTRY') {
-      return res.status(400).json({ error: 'J√° existe um post com este slug' });
-    }
-    res.status(500).json({ error: 'Erro interno do servidor', message: error?.message });
-  }
-});
-
-// DELETE /api/admin/blog/posts/:id - Deletar post
-app.delete('/api/admin/blog/posts/:id', async (req, res) => {
-  try {
-    const { id } = req.params;
-
-    const [result] = await pool.execute(
-      'DELETE FROM blog_posts WHERE id = ?',
-      [id]
-    );
-
-    if (result.affectedRows === 0) {
-      return res.status(404).json({ error: 'Post n√£o encontrado' });
-    }
-
-    console.log(`‚úÖ Post deletado: ${id}`);
-    res.json({ message: 'Post deletado com sucesso' });
-
-  } catch (error) {
-    console.error('‚ùå Erro ao deletar post:', error);
-    res.status(500).json({ error: 'Erro interno do servidor', message: error?.message });
-  }
-});
-
-// PATCH /api/admin/blog/posts/:id/status - Alterar status do post
-app.patch('/api/admin/blog/posts/:id/status', async (req, res) => {
-  try {
-    const { id } = req.params;
-    const { status } = req.body;
-
-    if (!['publicado', 'rascunho', 'arquivado'].includes(status)) {
-      return res.status(400).json({ error: 'Status inv√°lido' });
-    }
-
-    const publicado_em = status === 'publicado' ? new Date() : null;
-
-    const [result] = await pool.execute(
-      'UPDATE blog_posts SET status = ?, publicado_em = COALESCE(publicado_em, ?), updated_at = NOW() WHERE id = ?',
-      [status, publicado_em, id]
-    );
-
-    if (result.affectedRows === 0) {
-      return res.status(404).json({ error: 'Post n√£o encontrado' });
-    }
-
-    console.log(`‚úÖ Status do post alterado para: ${status}`);
-    res.json({ message: 'Status atualizado com sucesso', status });
-
-  } catch (error) {
-    console.error('‚ùå Erro ao alterar status:', error);
-    res.status(500).json({ error: 'Erro interno do servidor', message: error?.message });
-  }
-});
-
-// ============================================
-// ROTAS DE MARKETPLACE
-// ============================================
-
-// GET /api/marketplace/sellers - Listar vendedores (p√∫blico)
-app.get('/api/marketplace/sellers', async (req, res) => {
-  try {
-    const categoria = req.query.categoria;
-    const destaque = req.query.destaque;
-    const limit = parseInt(req.query.limit) || 20;
-    const offset = parseInt(req.query.offset) || 0;
-
-    let query = `
-      SELECT 
-        id, nome, slug, descricao, especialidade, categoria,
-        imagem_perfil, imagem_capa, avaliacao, total_avaliacoes,
-        total_vendas, total_produtos, localizacao, cidade, estado,
-        tempo_resposta, destaque, verificado, tags, certificacoes,
-        created_at, updated_at
-      FROM marketplace_sellers
-      WHERE ativo = 1
-    `;
-    const params = [];
-
-    if (categoria && categoria !== 'todos') {
-      query += ' AND categoria = ?';
-      params.push(categoria);
-    }
-
-    if (destaque === 'true') {
-      query += ' AND destaque = 1';
-    }
-
-    query += ` ORDER BY destaque DESC, avaliacao DESC, total_vendas DESC LIMIT ${limit} OFFSET ${offset}`;
-
-    const [sellers] = await pool.execute(query, params);
-
-    // Parse JSON fields
-    const sellersFormatted = sellers.map(seller => {
-      let tags = [];
-      let certificacoes = [];
-
+    // Se ainda n√£o tem userId, buscar endere√ßos da tabela addresses (para usu√°rios n√£o logados)
+    if (!userId) {
+      console.log('üîç Buscando endere√ßos da tabela addresses (usu√°rio n√£o logado)');
+      const cartId = getOrCreateCartId(req, res);
       try {
-        if (seller.tags) tags = typeof seller.tags === 'string' ? JSON.parse(seller.tags) : seller.tags;
-        if (seller.certificacoes) certificacoes = typeof seller.certificacoes === 'string' ? JSON.parse(seller.certificacoes) : seller.certificacoes;
-      } catch (e) {
-        console.error('Erro ao parsear JSON:', e);
-      }
-
-      return {
-        ...seller,
-        tags,
-        certificacoes,
-        destaque: Boolean(seller.destaque),
-        verificado: Boolean(seller.verificado),
-        avaliacao: parseFloat(seller.avaliacao || 0)
-      };
-    });
-
-    console.log(`‚úÖ ${sellersFormatted.length} vendedores carregados`);
-    res.json(sellersFormatted);
-
-  } catch (error) {
-    console.error('‚ùå Erro ao buscar vendedores:', error);
-    res.status(500).json({ error: 'Erro interno do servidor', message: error?.message });
-  }
-});
-
-// GET /api/marketplace/sellers/:slug - Obter vendedor espec√≠fico
-app.get('/api/marketplace/sellers/:slug', async (req, res) => {
-  try {
-    const { slug } = req.params;
-
-    const [sellers] = await pool.execute(
-      `SELECT * FROM marketplace_sellers WHERE slug = ? AND ativo = 1`,
-      [slug]
-    );
-
-    if (!sellers || sellers.length === 0) {
-      return res.status(404).json({ error: 'Vendedor n√£o encontrado' });
-    }
-
-    let tags = [];
-    let certificacoes = [];
-
-    try {
-      if (sellers[0].tags) tags = typeof sellers[0].tags === 'string' ? JSON.parse(sellers[0].tags) : sellers[0].tags;
-      if (sellers[0].certificacoes) certificacoes = typeof sellers[0].certificacoes === 'string' ? JSON.parse(sellers[0].certificacoes) : sellers[0].certificacoes;
-    } catch (e) {
-      console.error('Erro ao parsear JSON:', e);
-    }
-
-    const seller = {
-      ...sellers[0],
-      tags,
-      certificacoes,
-      destaque: Boolean(sellers[0].destaque),
-      verificado: Boolean(sellers[0].verificado),
-      ativo: Boolean(sellers[0].ativo),
-      avaliacao: parseFloat(sellers[0].avaliacao || 0)
-    };
-
-    console.log(`‚úÖ Vendedor "${seller.nome}" carregado`);
-    res.json(seller);
-
-  } catch (error) {
-    console.error('‚ùå Erro ao buscar vendedor:', error);
-    res.status(500).json({ error: 'Erro interno do servidor', message: error?.message });
-  }
-});
-
-// GET /api/marketplace/categorias - Listar categorias
-app.get('/api/marketplace/categorias', async (req, res) => {
-  try {
-    const [categorias] = await pool.execute(`
-      SELECT 
-        categoria,
-        COUNT(*) as total
-      FROM marketplace_sellers
-      WHERE ativo = 1
-      GROUP BY categoria
-      ORDER BY total DESC
-    `);
-
-    res.json(categorias);
-
-  } catch (error) {
-    console.error('‚ùå Erro ao buscar categorias:', error);
-    res.status(500).json({ error: 'Erro interno do servidor', message: error?.message });
-  }
-});
-
-// ============================================
-// ROTAS GOOGLE CALENDAR
-// ============================================
-const googleCalendarRoutes = require('./routes/google-calendar.cjs');
-app.use('/api/google', googleCalendarRoutes);
-
-// ============================================
-// ROTAS CONFIGURA√á√ÉO DA API
-// ============================================
-const apiConfigRoutes = require('./routes/api-config.cjs');
-app.use('/api/admin/config', apiConfigRoutes);
-
-// ============================================
-// ROTAS ADMIN - MARKETPLACE
-// ============================================
-
-// GET /api/admin/marketplace/sellers - Listar todos os vendedores (admin)
-app.get('/api/admin/marketplace/sellers', async (req, res) => {
-  // Verificar autentica√ß√£o admin
-  if (!isAdminRequest(req)) {
-    return res.status(401).json({ error: 'Unauthorized', message: 'Acesso negado. Fa√ßa login como administrador.' });
-  }
-
-  try {
-    const { categoria, busca, ativo } = req.query;
-
-    let query = `
-      SELECT 
-        id, nome, slug, descricao, especialidade, categoria,
-        imagem_perfil, avaliacao, total_vendas, total_produtos,
-        localizacao, destaque, verificado, ativo, created_at
-      FROM marketplace_sellers
-      WHERE 1=1
-    `;
-    const params = [];
-
-    if (categoria && categoria !== 'todos') {
-      query += ' AND categoria = ?';
-      params.push(categoria);
-    }
-
-    if (ativo !== undefined) {
-      query += ' AND ativo = ?';
-      params.push(ativo === 'true' ? 1 : 0);
-    }
-
-    if (busca) {
-      query += ' AND (nome LIKE ? OR descricao LIKE ? OR especialidade LIKE ?)';
-      const searchTerm = `%${busca}%`;
-      params.push(searchTerm, searchTerm, searchTerm);
-    }
-
-    query += ' ORDER BY created_at DESC';
-
-    const [sellers] = await pool.execute(query, params);
-
-    const sellersFormatted = sellers.map(seller => ({
-      ...seller,
-      destaque: Boolean(seller.destaque),
-      verificado: Boolean(seller.verificado),
-      ativo: Boolean(seller.ativo),
-      avaliacao: parseFloat(seller.avaliacao || 0)
-    }));
-
-    console.log(`‚úÖ ${sellersFormatted.length} vendedores admin carregados`);
-    res.json(sellersFormatted);
-
-  } catch (error) {
-    console.error('‚ùå Erro ao buscar vendedores admin:', error);
-    res.status(500).json({ error: 'Erro interno do servidor', message: error?.message });
-  }
-});
-
-// GET /api/admin/marketplace/sellers/:id - Obter vendedor espec√≠fico (admin)
-app.get('/api/admin/marketplace/sellers/:id', async (req, res) => {
-  // Verificar autentica√ß√£o admin
-  if (!isAdminRequest(req)) {
-    return res.status(401).json({ error: 'Unauthorized', message: 'Acesso negado. Fa√ßa login como administrador.' });
-  }
-
-  try {
-    const { id } = req.params;
-
-    const [sellers] = await pool.execute(
-      `SELECT * FROM marketplace_sellers WHERE id = ?`,
-      [id]
-    );
-
-    if (sellers.length === 0) {
-      return res.status(404).json({ error: 'Vendedor n√£o encontrado' });
-    }
-
-    let tags = [];
-    let certificacoes = [];
-
-    try {
-      if (sellers[0].tags) tags = typeof sellers[0].tags === 'string' ? JSON.parse(sellers[0].tags) : sellers[0].tags;
-      if (sellers[0].certificacoes) certificacoes = typeof sellers[0].certificacoes === 'string' ? JSON.parse(sellers[0].certificacoes) : sellers[0].certificacoes;
-    } catch (e) {
-      console.error('Erro ao parsear JSON:', e);
-    }
-
-    const seller = {
-      ...sellers[0],
-      tags,
-      certificacoes,
-      destaque: Boolean(sellers[0].destaque),
-      verificado: Boolean(sellers[0].verificado),
-      ativo: Boolean(sellers[0].ativo),
-      avaliacao: parseFloat(sellers[0].avaliacao || 0)
-    };
-
-    res.json(seller);
-
-  } catch (error) {
-    console.error('‚ùå Erro ao buscar vendedor admin:', error);
-    res.status(500).json({ error: 'Erro interno do servidor', message: error?.message });
-  }
-});
-
-// GET /api/admin/marketplace/sellers/structure - Verificar estrutura da tabela (tempor√°rio para debug)
-app.get('/api/admin/marketplace/sellers/structure', async (req, res) => {
-  if (!isAdminRequest(req)) {
-    return res.status(401).json({ error: 'Unauthorized' });
-  }
-
-  try {
-    const [columns] = await pool.execute('DESCRIBE marketplace_sellers');
-    res.json({ columns, count: columns.length });
-  } catch (error) {
-    res.status(500).json({
-      error: error.message,
-      code: error.code,
-      sqlMessage: error.sqlMessage
-    });
-  }
-});
-
-// POST /api/admin/marketplace/sellers - Criar novo vendedor
-app.post('/api/admin/marketplace/sellers', async (req, res) => {
-  // Verificar autentica√ß√£o admin
-  if (!isAdminRequest(req)) {
-    return res.status(401).json({ error: 'Unauthorized', message: 'Acesso negado. Fa√ßa login como administrador.' });
-  }
-
-  try {
-    const {
-      nome,
-      slug,
-      descricao,
-      especialidade,
-      categoria,
-      imagem_perfil,
-      imagem_capa,
-      avaliacao = 0,
-      localizacao,
-      cidade,
-      estado,
-      tempo_resposta = '24h',
-      destaque = false,
-      verificado = false,
-      ativo = true,
-      email,
-      telefone,
-      whatsapp,
-      instagram,
-      website,
-      politica_troca,
-      politica_envio,
-      horario_atendimento,
-      tags = [],
-      certificacoes = []
-    } = req.body;
-
-    if (!nome || !descricao || !categoria) {
-      return res.status(400).json({ error: 'Nome, descri√ß√£o e categoria s√£o obrigat√≥rios' });
-    }
-
-    // Gerar slug se n√£o fornecido
-    const finalSlug = slug || nome.toLowerCase()
-      .normalize('NFD').replace(/[\u0300-\u036f]/g, '')
-      .replace(/[^a-z0-9\s-]/g, '')
-      .replace(/\s+/g, '-')
-      .replace(/-+/g, '-')
-      .trim();
-
-    const newId = require('crypto').randomUUID();
-
-    // Campos que realmente existem na tabela (baseado no SELECT)
-    // Removendo: email, telefone, whatsapp, instagram, website, politica_troca, politica_envio, horario_atendimento
-    const [result] = await pool.execute(
-      `INSERT INTO marketplace_sellers (
-        id, nome, slug, descricao, especialidade, categoria,
-        imagem_perfil, imagem_capa, avaliacao, localizacao, cidade, estado,
-        tempo_resposta, destaque, verificado, ativo,
-        tags, certificacoes
-      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
-      [
-        newId, nome, finalSlug, descricao || null, especialidade || null, categoria,
-        imagem_perfil || null, imagem_capa || null, avaliacao || 0, localizacao || null, cidade || null, estado || null,
-        tempo_resposta || '24h', destaque ? 1 : 0, verificado ? 1 : 0, ativo ? 1 : 0,
-        JSON.stringify(tags || []), JSON.stringify(certificacoes || [])
-      ]
-    );
-
-    console.log(`‚úÖ Vendedor criado: ${nome}`);
-    res.status(201).json({
-      id: newId,
-      nome,
-      slug: finalSlug,
-      message: 'Vendedor criado com sucesso'
-    });
-
-  } catch (error) {
-    console.error('‚ùå Erro ao criar vendedor:', error);
-    console.error('‚ùå Stack trace:', error.stack);
-    console.error('‚ùå Request body:', JSON.stringify(req.body, null, 2));
-    console.error('‚ùå SQL Message:', error.sqlMessage);
-    console.error('‚ùå Error Code:', error.code);
-    console.error('‚ùå SQL State:', error.sqlState);
+        const [addresses] = await pool.execute(`
+          SELECT 
+            id,
+            nome,
+            cep,
+            endereco,
+            numero,
+            complemento,
+            bairro,
+            cidade,
+            estado,
+            shipping_default as principal,
+            created_at,
+            updated_at
+          FROM addresses 
+          WHERE cart_id = ?
+          ORDER BY shipping_default DESC, created_at DESC
+        `, [cartId]);
 
-    if (error.code === 'ER_DUP_ENTRY') {
-      return res.status(400).json({ error: 'J√° existe um vendedor com este slug' });
+        console.log(`‚úÖ Encontrados ${addresses.length} endere√ßos na tabela addresses`);
+        res.json(addresses);
+        return;
+      } catch (e) {
+        console.log('‚ö†Ô∏è Erro ao buscar endere√ßos da tabela addresses:', e.message);
+      }
     }
 
-    if (error.code === 'ER_NO_SUCH_TABLE') {
-      return res.status(500).json({
-        error: 'Tabela n√£o encontrada',
-        message: 'A tabela marketplace_sellers n√£o existe. Execute a migra√ß√£o do banco de dados.'
-      });
-    }
+    // Buscar endere√ßos do usu√°rio logado na tabela enderecos
+    console.log('üîç Buscando endere√ßos do usu√°rio logado na tabela enderecos');
+    try {
+      const [addresses] = await pool.execute(`
+        SELECT 
+          id,
+          tipo,
+          cep,
+          logradouro as endereco,
+          numero,
+          complemento,
+          bairro,
+          cidade,
+          estado,
+          principal,
+          data_criacao as created_at
+        FROM enderecos 
+        WHERE cliente_id = ?
+        ORDER BY principal DESC, data_criacao DESC
+      `, [userId]);
 
-    if (error.code === 'ER_BAD_FIELD_ERROR') {
-      const fieldMatch = error.sqlMessage?.match(/Unknown column ['"]([^'"]+)['"]/i);
-      const fieldName = fieldMatch ? fieldMatch[1] : 'desconhecido';
-      console.error(`‚ùå Campo inv√°lido identificado: ${fieldName}`);
-      console.error(`‚ùå SQL completo: ${error.sql}`);
-      return res.status(500).json({
-        error: 'Campo inv√°lido',
-        message: `Campo n√£o encontrado na tabela: ${fieldName}`,
-        field: fieldName,
-        sqlMessage: error.sqlMessage
-      });
+      console.log(`‚úÖ Encontrados ${addresses.length} endere√ßos para o usu√°rio ${userId}`);
+      res.json(addresses);
+
+    } catch (e) {
+      console.error('‚ùå Erro ao buscar endere√ßos do usu√°rio:', e);
+      res.status(500).json({ error: 'addresses_list_failed', details: e.message });
     }
 
-    res.status(500).json({
-      error: 'Erro interno do servidor',
-      message: error?.message || 'Erro desconhecido',
-      code: error?.code,
-      sqlState: error?.sqlState,
-      sqlMessage: error?.sqlMessage
-    });
+  } catch (e) {
+    console.error('Addresses list error', e);
+    res.status(500).json({ error: 'addresses_list_failed' });
   }
 });
 
-// PUT /api/admin/marketplace/sellers/:id - Atualizar vendedor
-app.put('/api/admin/marketplace/sellers/:id', async (req, res) => {
-  // Verificar autentica√ß√£o admin
-  if (!isAdminRequest(req)) {
-    return res.status(401).json({ error: 'Unauthorized', message: 'Acesso negado. Fa√ßa login como administrador.' });
-  }
-
+app.post('/api/addresses', async (req, res) => {
+  console.log('üö® ENDPOINT /api/addresses CHAMADO!');
   try {
-    const { id } = req.params;
-    const {
-      nome, slug, descricao, especialidade, categoria,
-      imagem_perfil, imagem_capa, avaliacao, localizacao, cidade, estado,
-      tempo_resposta, destaque, verificado, ativo,
-      email, telefone, whatsapp, instagram, website,
-      politica_troca, politica_envio, horario_atendimento,
-      tags, certificacoes
-    } = req.body;
-
-    // Gerar slug se n√£o fornecido
-    const finalSlug = slug || nome.toLowerCase()
-      .normalize('NFD').replace(/[\u0300-\u036f]/g, '')
-      .replace(/[^a-z0-9\s-]/g, '')
-      .replace(/\s+/g, '-')
-      .replace(/-+/g, '-')
-      .trim();
+    console.log('üìç POST /api/addresses - Criando novo endere√ßo');
+    console.log('üìç Headers:', req.headers);
+    console.log('üìç Cookies:', req.cookies);
+    console.log('üìç Body:', req.body);
 
-    // Campos que realmente existem na tabela (mesmos do INSERT)
-    // Removendo: email, telefone, whatsapp, instagram, website, politica_troca, politica_envio, horario_atendimento
-    const [result] = await pool.execute(
-      `UPDATE marketplace_sellers SET
-        nome = ?, slug = ?, descricao = ?, especialidade = ?, categoria = ?,
-        imagem_perfil = ?, imagem_capa = ?, avaliacao = ?, localizacao = ?, cidade = ?, estado = ?,
-        tempo_resposta = ?, destaque = ?, verificado = ?, ativo = ?,
-        tags = ?, certificacoes = ?, updated_at = NOW()
-      WHERE id = ?`,
-      [
-        nome, finalSlug, descricao || null, especialidade || null, categoria,
-        imagem_perfil || null, imagem_capa || null, avaliacao || 0, localizacao || null, cidade || null, estado || null,
-        tempo_resposta || '24h', destaque ? 1 : 0, verificado ? 1 : 0, ativo ? 1 : 0,
-        JSON.stringify(tags || []), JSON.stringify(certificacoes || []),
-        id
-      ]
-    );
+    // Tentar obter o usu√°rio da sess√£o
+    let userId = null;
 
-    if (result.affectedRows === 0) {
-      return res.status(404).json({ error: 'Vendedor n√£o encontrado' });
+    // Verificar se h√° session_id no cookie
+    const sessionId = req.cookies?.session_id;
+    if (sessionId) {
+      console.log('üîç Verificando sess√£o:', sessionId);
+      try {
+        const [sessions] = await pool.execute('SELECT * FROM sessions WHERE id = ?', [sessionId]);
+        if (sessions && sessions[0]) {
+          userId = sessions[0].user_id;
+          console.log('‚úÖ Usu√°rio encontrado na sess√£o:', userId);
+        }
+      } catch (e) {
+        console.log('‚ö†Ô∏è Erro ao verificar sess√£o:', e.message);
+      }
     }
 
-    console.log(`‚úÖ Vendedor atualizado: ${id}`);
-    res.json({ message: 'Vendedor atualizado com sucesso' });
-
-  } catch (error) {
-    console.error('‚ùå Erro ao atualizar vendedor:', error);
-    console.error('‚ùå Stack trace:', error.stack);
-    console.error('‚ùå Request body:', JSON.stringify(req.body, null, 2));
-    console.error('‚ùå SQL Message:', error.sqlMessage);
-    console.error('‚ùå Error Code:', error.code);
-    console.error('‚ùå SQL State:', error.sqlState);
+    // Se n√£o encontrou usu√°rio na sess√£o, tentar obter do cart_id existente
+    if (!userId) {
+      // Primeiro, tentar obter cart_id do cookie sem criar um novo
+      const existingCartId = req.cookies?.cart_id;
+      if (existingCartId) {
+        console.log('üîç Tentando encontrar usu√°rio pelo cart_id existente:', existingCartId);
+        try {
+          const [carts] = await pool.execute('SELECT * FROM carts WHERE id = ?', [existingCartId]);
+          if (carts && carts[0] && carts[0].user_id) {
+            userId = carts[0].user_id;
+            console.log('‚úÖ Usu√°rio encontrado pelo cart_id existente:', userId);
+          }
+        } catch (e) {
+          console.log('‚ö†Ô∏è Erro ao buscar usu√°rio pelo cart_id existente:', e.message);
+        }
+      }
 
-    if (error.code === 'ER_DUP_ENTRY') {
-      return res.status(400).json({ error: 'J√° existe um vendedor com este slug' });
-    }
-
-    if (error.code === 'ER_BAD_FIELD_ERROR') {
-      const fieldMatch = error.sqlMessage?.match(/Unknown column ['"]([^'"]+)['"]/i);
-      const fieldName = fieldMatch ? fieldMatch[1] : 'desconhecido';
-      console.error(`‚ùå Campo inv√°lido identificado: ${fieldName}`);
-      console.error(`‚ùå SQL completo: ${error.sql}`);
-      return res.status(500).json({
-        error: 'Campo inv√°lido',
-        message: `Campo n√£o encontrado na tabela: ${fieldName}`,
-        field: fieldName,
-        sqlMessage: error.sqlMessage
-      });
+      // Se ainda n√£o encontrou, criar novo cart_id
+      if (!userId) {
+        const cartId = getOrCreateCartId(req, res);
+        console.log('üîç Tentando encontrar usu√°rio pelo novo cart_id:', cartId);
+        try {
+          const [carts] = await pool.execute('SELECT * FROM carts WHERE id = ?', [cartId]);
+          if (carts && carts[0] && carts[0].user_id) {
+            userId = carts[0].user_id;
+            console.log('‚úÖ Usu√°rio encontrado pelo novo cart_id:', userId);
+          }
+        } catch (e) {
+          console.log('‚ö†Ô∏è Erro ao buscar usu√°rio pelo novo cart_id:', e.message);
+        }
+      }
     }
 
-    res.status(500).json({
-      error: 'Erro interno do servidor',
-      message: error?.message || 'Erro desconhecido',
-      code: error?.code,
-      sqlState: error?.sqlState,
-      sqlMessage: error?.sqlMessage
-    });
-  }
-});
+    const { nome, telefone, cep, endereco, numero, complemento, bairro, cidade, estado, shipping_default, billing_default } = req.body || {};
+    const id = uuidv4();
 
-// DELETE /api/admin/marketplace/sellers/:id - Deletar vendedor
-app.delete('/api/admin/marketplace/sellers/:id', async (req, res) => {
-  // Verificar autentica√ß√£o admin
-  if (!isAdminRequest(req)) {
-    return res.status(401).json({ error: 'Unauthorized', message: 'Acesso negado. Fa√ßa login como administrador.' });
-  }
+    console.log('üìù Dados do endere√ßo:', { nome, cep, endereco, numero, cidade, estado, shipping_default });
 
-  try {
-    const { id } = req.params;
+    // Se tem usu√°rio logado, salvar na tabela enderecos
+    if (userId) {
+      console.log('üíæ Salvando endere√ßo na tabela enderecos para usu√°rio:', userId);
 
-    const [result] = await pool.execute(
-      'DELETE FROM marketplace_sellers WHERE id = ?',
-      [id]
-    );
+      // Se for padr√£o, remover padr√£o dos outros endere√ßos
+      if (shipping_default) {
+        await pool.execute('UPDATE enderecos SET principal = 0 WHERE cliente_id = ?', [userId]);
+      }
 
-    if (result.affectedRows === 0) {
-      return res.status(404).json({ error: 'Vendedor n√£o encontrado' });
-    }
+      await pool.execute(
+        `INSERT INTO enderecos (cliente_id, tipo, cep, logradouro, numero, complemento, bairro, cidade, estado, principal)
+         VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
+        [userId, 'casa', cep, endereco, numero || '', complemento || '', bairro || '', cidade, estado, shipping_default ? 1 : 0]
+      );
 
-    console.log(`‚úÖ Vendedor deletado: ${id}`);
-    res.json({ message: 'Vendedor deletado com sucesso' });
+      console.log('‚úÖ Endere√ßo salvo na tabela enderecos');
 
-  } catch (error) {
-    console.error('‚ùå Erro ao deletar vendedor:', error);
-    res.status(500).json({ error: 'Erro interno do servidor', message: error?.message });
-  }
-});
+    } else {
+      // Se n√£o tem usu√°rio logado, salvar na tabela addresses
+      console.log('üíæ Salvando endere√ßo na tabela addresses (usu√°rio n√£o logado)');
 
-// PATCH /api/admin/marketplace/sellers/:id/toggle - Alternar status ativo/verificado
-app.patch('/api/admin/marketplace/sellers/:id/toggle', async (req, res) => {
-  try {
-    const { id } = req.params;
-    const { field, value } = req.body;
+      const cartId = getOrCreateCartId(req, res);
 
-    if (!['ativo', 'destaque', 'verificado'].includes(field)) {
-      return res.status(400).json({ error: 'Campo inv√°lido' });
-    }
+      if (shipping_default) {
+        await pool.execute('UPDATE addresses SET shipping_default = 0 WHERE cart_id = ?', [cartId]);
+      }
+      if (billing_default) {
+        await pool.execute('UPDATE addresses SET billing_default = 0 WHERE cart_id = ?', [cartId]);
+      }
 
-    const [result] = await pool.execute(
-      `UPDATE marketplace_sellers SET ${field} = ?, updated_at = NOW() WHERE id = ?`,
-      [value ? 1 : 0, id]
-    );
+      await pool.execute(
+        `INSERT INTO addresses (id, cart_id, nome, telefone, cep, endereco, numero, complemento, bairro, cidade, estado, shipping_default, billing_default)
+         VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?)`,
+        [id, cartId, nome || null, telefone || null, cep || null, endereco || null, numero || null, complemento || null, bairro || null, cidade || null, estado || null, shipping_default ? 1 : 0, billing_default ? 1 : 0]
+      );
 
-    if (result.affectedRows === 0) {
-      return res.status(404).json({ error: 'Vendedor n√£o encontrado' });
+      console.log('‚úÖ Endere√ßo salvo na tabela addresses');
     }
 
-    console.log(`‚úÖ ${field} do vendedor alterado para: ${value}`);
-    res.json({ message: `${field} atualizado com sucesso`, [field]: value });
-
-  } catch (error) {
-    console.error('‚ùå Erro ao alternar status:', error);
-    res.status(500).json({ error: 'Erro interno do servidor', message: error?.message });
-  }
-});
+    // Retornar o endere√ßo criado
+    const responseData = {
+      id,
+      nome: nome || 'Endere√ßo',
+      cep,
+      endereco,
+      numero,
+      complemento,
+      bairro,
+      cidade,
+      estado,
+      principal: shipping_default ? 1 : 0,
+      created_at: new Date().toISOString(),
+      updated_at: new Date().toISOString()
+    };
 
-// ============================================
-// ROTAS DE GERENCIAMENTO DE USU√ÅRIOS ADMIN
-// ============================================
+    console.log('‚úÖ Endere√ßo criado com sucesso:', id);
+    res.status(201).json(responseData);
 
-// GET /api/admin/usuarios - Listar todos os usu√°rios
-app.get('/api/admin/usuarios', async (req, res) => {
-  try {
-    const [usuarios] = await pool.execute(
-      `SELECT id, nome, email, telefone, role, status, permissoes, 
-       avatar, created_at, last_access 
-       FROM admin_users 
-       ORDER BY created_at DESC`
-    );
-    res.json(usuarios);
-  } catch (error) {
-    console.error('‚ùå Erro ao listar usu√°rios:', error);
-    res.status(500).json({ error: 'Erro ao listar usu√°rios', message: error?.message });
+  } catch (e) {
+    console.error('‚ùå Addresses create error:', e);
+    res.status(500).json({ error: 'addresses_create_failed', details: e.message });
   }
 });
 
-// GET /api/admin/usuarios/:id - Buscar usu√°rio espec√≠fico
-app.get('/api/admin/usuarios/:id', async (req, res) => {
+app.put('/api/addresses/:id', async (req, res) => {
   try {
-    const { id } = req.params;
-    const [usuarios] = await pool.execute(
-      `SELECT id, nome, email, telefone, role, status, permissoes, 
-       avatar, created_at, last_access 
-       FROM admin_users 
-       WHERE id = ?`,
-      [id]
-    );
-
-    if (usuarios.length === 0) {
-      return res.status(404).json({ error: 'Usu√°rio n√£o encontrado' });
-    }
-
-    res.json(usuarios[0]);
-  } catch (error) {
-    console.error('‚ùå Erro ao buscar usu√°rio:', error);
-    res.status(500).json({ error: 'Erro ao buscar usu√°rio', message: error?.message });
-  }
-});
+    console.log('üìç PUT /api/addresses/:id - Atualizando endere√ßo');
 
-// POST /api/admin/usuarios - Criar novo usu√°rio
-app.post('/api/admin/usuarios', async (req, res) => {
-  try {
-    const { nome, email, telefone, senha, role, status, permissoes } = req.body;
+    // Tentar obter o usu√°rio da sess√£o
+    let userId = null;
 
-    // Valida√ß√µes
-    if (!nome || !email || !senha) {
-      return res.status(400).json({ error: 'Nome, email e senha s√£o obrigat√≥rios' });
+    // Verificar se h√° session_id no cookie
+    const sessionId = req.cookies?.session_id;
+    if (sessionId) {
+      console.log('üîç Verificando sess√£o:', sessionId);
+      try {
+        const [sessions] = await pool.execute('SELECT * FROM sessions WHERE id = ?', [sessionId]);
+        if (sessions && sessions[0]) {
+          userId = sessions[0].user_id;
+          console.log('‚úÖ Usu√°rio encontrado na sess√£o:', userId);
+        }
+      } catch (e) {
+        console.log('‚ö†Ô∏è Erro ao verificar sess√£o:', e.message);
+      }
     }
 
-    // Verificar se email j√° existe
-    const [existing] = await pool.execute(
-      'SELECT id FROM admin_users WHERE email = ?',
-      [email]
-    );
-
-    if (existing.length > 0) {
-      return res.status(400).json({ error: 'Email j√° cadastrado' });
+    // Se n√£o encontrou usu√°rio na sess√£o, tentar obter do cart_id
+    if (!userId) {
+      const cartId = getOrCreateCartId(req, res);
+      console.log('üîç Tentando encontrar usu√°rio pelo cart_id:', cartId);
+      try {
+        const [carts] = await pool.execute('SELECT * FROM carts WHERE id = ?', [cartId]);
+        if (carts && carts[0] && carts[0].user_id) {
+          userId = carts[0].user_id;
+          console.log('‚úÖ Usu√°rio encontrado pelo cart_id:', userId);
+        }
+      } catch (e) {
+        console.log('‚ö†Ô∏è Erro ao buscar usu√°rio pelo cart_id:', e.message);
+      }
     }
 
-    // Hash da senha (se bcrypt n√£o estiver dispon√≠vel, use sha256 simples)
-    const crypto = require('crypto');
-    const senhaHash = crypto.createHash('sha256').update(senha).digest('hex');
-
-    // Inserir novo usu√°rio
-    const [result] = await pool.execute(
-      `INSERT INTO admin_users 
-       (nome, email, telefone, senha_hash, role, status, permissoes, created_at) 
-       VALUES (?, ?, ?, ?, ?, ?, ?, NOW())`,
-      [
-        nome,
-        email,
-        telefone || null,
-        senhaHash,
-        role || 'viewer',
-        status || 'ativo',
-        permissoes || '[]'
-      ]
-    );
-
-    res.json({
-      success: true,
-      id: result.insertId,
-      message: 'Usu√°rio criado com sucesso'
-    });
-  } catch (error) {
-    console.error('‚ùå Erro ao criar usu√°rio:', error);
-    res.status(500).json({ error: 'Erro ao criar usu√°rio', message: error?.message });
-  }
-});
-
-// PUT /api/admin/usuarios/:id - Atualizar usu√°rio
-app.put('/api/admin/usuarios/:id', async (req, res) => {
-  try {
     const { id } = req.params;
-    const { nome, email, telefone, senha, role, status, permissoes } = req.body;
-
-    // Valida√ß√µes
-    if (!nome || !email) {
-      return res.status(400).json({ error: 'Nome e email s√£o obrigat√≥rios' });
-    }
-
-    // Verificar se email j√° existe em outro usu√°rio
-    const [existing] = await pool.execute(
-      'SELECT id FROM admin_users WHERE email = ? AND id != ?',
-      [email, id]
-    );
+    const { nome, telefone, cep, endereco, numero, complemento, bairro, cidade, estado, shipping_default, billing_default } = req.body || {};
 
-    if (existing.length > 0) {
-      return res.status(400).json({ error: 'Email j√° cadastrado para outro usu√°rio' });
-    }
+    console.log('üìù Dados do endere√ßo para atualizar:', { nome, cep, endereco, numero, cidade, estado, shipping_default });
 
-    // Preparar update
-    let query = `UPDATE admin_users SET 
-                 nome = ?, email = ?, telefone = ?, 
-                 role = ?, status = ?, permissoes = ?, 
-                 updated_at = NOW()`;
-    let params = [nome, email, telefone || null, role, status, permissoes || '[]'];
+    // Se tem usu√°rio logado, atualizar na tabela customer_addresses
+    if (userId) {
+      console.log('üíæ Atualizando endere√ßo na tabela customer_addresses para usu√°rio:', userId);
 
-    // Se senha foi fornecida, atualizar tamb√©m
-    if (senha) {
-      // Validar comprimento m√≠nimo
-      if (senha.length < 6) {
-        return res.status(400).json({ error: 'Senha muito curta. M√≠nimo 6 caracteres.' });
+      // Se for padr√£o, remover padr√£o dos outros endere√ßos
+      if (shipping_default) {
+        await pool.execute('UPDATE enderecos SET principal = 0 WHERE cliente_id = ? AND id != ?', [userId, id]);
       }
 
-      // Usar hash seguro (bcrypt) ao inv√©s de SHA256
-      const { hashPassword } = require('./utils/security.cjs');
-      const senhaHash = await hashPassword(senha);
-      query += ', senha_hash = ?';
-      params.push(senhaHash);
-      console.log(`üîê Senha atualizada para usu√°rio ID: ${id}`);
-    }
-
-    query += ' WHERE id = ?';
-    params.push(id);
+      await pool.execute(
+        `UPDATE enderecos SET nome = ?, logradouro = ?, numero = ?, complemento = ?, bairro = ?, cidade = ?, estado = ?, cep = ?, principal = ?, updated_at = NOW() WHERE id = ? AND cliente_id = ?`,
+        [nome || 'Endere√ßo', endereco, numero || '', complemento || '', bairro || '', cidade, estado, cep, shipping_default ? 1 : 0, id, userId]
+      );
 
-    await pool.execute(query, params);
+      console.log('‚úÖ Endere√ßo atualizado na tabela customer_addresses');
 
-    res.json({
-      success: true,
-      message: 'Usu√°rio atualizado com sucesso'
-    });
-  } catch (error) {
-    console.error('‚ùå Erro ao atualizar usu√°rio:', error);
-    res.status(500).json({ error: 'Erro ao atualizar usu√°rio', message: error?.message });
-  }
-});
+    } else {
+      // Se n√£o tem usu√°rio logado, atualizar na tabela addresses
+      console.log('üíæ Atualizando endere√ßo na tabela addresses (usu√°rio n√£o logado)');
 
-// DELETE /api/admin/usuarios/:id - Excluir usu√°rio
-app.delete('/api/admin/usuarios/:id', async (req, res) => {
-  try {
-    const { id } = req.params;
+      const cartId = getOrCreateCartId(req, res);
 
-    // N√£o permitir excluir o √∫ltimo admin
-    const [admins] = await pool.execute(
-      'SELECT COUNT(*) as total FROM admin_users WHERE role = "admin" AND status = "ativo"'
-    );
+      if (shipping_default) {
+        await pool.execute('UPDATE addresses SET shipping_default = 0 WHERE cart_id = ?', [cartId]);
+      }
+      if (billing_default) {
+        await pool.execute('UPDATE addresses SET billing_default = 0 WHERE cart_id = ?', [cartId]);
+      }
 
-    const [usuario] = await pool.execute(
-      'SELECT role FROM admin_users WHERE id = ?',
-      [id]
-    );
+      await pool.execute(
+        `UPDATE addresses SET nome=?, telefone=?, cep=?, endereco=?, numero=?, complemento=?, bairro=?, cidade=?, estado=?, shipping_default=?, billing_default=? WHERE id = ? AND cart_id = ?`,
+        [nome || null, telefone || null, cep || null, endereco || null, numero || null, complemento || null, bairro || null, cidade || null, estado || null, shipping_default ? 1 : 0, billing_default ? 1 : 0, id, cartId]
+      );
 
-    if (usuario.length > 0 && usuario[0].role === 'admin' && admins[0].total <= 1) {
-      return res.status(400).json({
-        error: 'N√£o √© poss√≠vel excluir o √∫ltimo administrador ativo'
-      });
+      console.log('‚úÖ Endere√ßo atualizado na tabela addresses');
     }
 
-    // Excluir usu√°rio
-    await pool.execute('DELETE FROM admin_users WHERE id = ?', [id]);
+    // Retornar o endere√ßo atualizado
+    const responseData = {
+      id,
+      nome: nome || 'Endere√ßo',
+      cep,
+      endereco,
+      numero,
+      complemento,
+      bairro,
+      cidade,
+      estado,
+      principal: shipping_default ? 1 : 0,
+      updated_at: new Date().toISOString()
+    };
 
-    res.json({
-      success: true,
-      message: 'Usu√°rio exclu√≠do com sucesso'
-    });
-  } catch (error) {
-    console.error('‚ùå Erro ao excluir usu√°rio:', error);
-    res.status(500).json({ error: 'Erro ao excluir usu√°rio', message: error?.message });
+    console.log('‚úÖ Endere√ßo atualizado com sucesso:', id);
+    res.json(responseData);
+  } catch (e) {
+    console.error('Addresses update error', e);
+    res.status(500).json({ error: 'addresses_update_failed' });
   }
 });
 
-// POST /api/admin/usuarios/:id/reset-password - Resetar senha
-app.post('/api/admin/usuarios/:id/reset-password', async (req, res) => {
+app.delete('/api/addresses/:id', async (req, res) => {
   try {
+    const cartId = getOrCreateCartId(req, res);
     const { id } = req.params;
-    const { novaSenha } = req.body;
-
-    if (!novaSenha) {
-      return res.status(400).json({ error: 'Nova senha √© obrigat√≥ria' });
-    }
-
-    const crypto = require('crypto');
-    const senhaHash = crypto.createHash('sha256').update(novaSenha).digest('hex');
-
-    await pool.execute(
-      'UPDATE admin_users SET senha_hash = ?, updated_at = NOW() WHERE id = ?',
-      [senhaHash, id]
-    );
-
-    res.json({
-      success: true,
-      message: 'Senha resetada com sucesso'
-    });
-  } catch (error) {
-    console.error('‚ùå Erro ao resetar senha:', error);
-    res.status(500).json({ error: 'Erro ao resetar senha', message: error?.message });
+    await pool.execute('DELETE FROM addresses WHERE id = ? AND cart_id = ?', [id, cartId]);
+    res.json({ ok: true });
+  } catch (e) {
+    console.error('Addresses delete error', e);
+    res.status(500).json({ error: 'addresses_delete_failed' });
   }
 });
 
-// PUT /api/admin/usuarios/:id/toggle-status - Ativar/Desativar usu√°rio
-app.put('/api/admin/usuarios/:id/toggle-status', async (req, res) => {
+
+// POST /api/collections/:id/products - Vincular produto √† cole√ß√£o
+app.post('/api/collections/:id/products', async (req, res) => {
   try {
     const { id } = req.params;
-    const { status } = req.body;
-
-    if (!['ativo', 'inativo', 'bloqueado'].includes(status)) {
-      return res.status(400).json({ error: 'Status inv√°lido' });
+    const { product_id, order_index } = req.body || {};
+    if (!product_id) {
+      return res.status(400).json({ error: 'product_id √© obrigat√≥rio' });
     }
 
-    await pool.execute(
-      'UPDATE admin_users SET status = ?, updated_at = NOW() WHERE id = ?',
-      [status, id]
-    );
-
-    res.json({
-      success: true,
-      message: 'Status atualizado com sucesso'
-    });
-  } catch (error) {
-    console.error('‚ùå Erro ao atualizar status:', error);
-    res.status(500).json({ error: 'Erro ao atualizar status', message: error?.message });
-  }
-});
-
-// ==================== FINANCIAL TRANSACTIONS API ====================
-
-// Normalizar uma linha de financial_transactions para o formato da API (evita erros de serializa√ß√£o)
-function normalizeFinancialRow(r) {
-  if (!r || typeof r !== 'object') return null;
-  const tipoRaw = r.tipo != null ? String(r.tipo) : '';
-  const tipo = tipoRaw.toLowerCase().replace('sa√≠da', 'saida').replace('saida', 'saida').replace('entrada', 'entrada');
-  return {
-    id: r.id,
-    data: r.data,
-    hora: r.hora ?? null,
-    descricao: r.descricao ?? '',
-    categoria: r.categoria ?? '',
-    origem: r.origem ?? '',
-    tipo: tipo || r.tipo,
-    valor: r.valor != null ? Number(r.valor) : 0,
-    valor_bruto: r.valor_bruto != null ? Number(r.valor_bruto) : null,
-    status: r.status ?? 'Pago',
-    metodo_pagamento: r.metodo_pagamento ?? r.forma_pagamento ?? '',
-    observacoes: r.observacoes ?? '',
-    created_at: r.created_at,
-    updated_at: r.updated_at
-  };
-}
+    // Checar exist√™ncia de cole√ß√£o
+    const [cRows] = await pool.execute('SELECT id FROM collections WHERE id = ?', [id]);
+    if (!cRows || cRows.length === 0) return res.status(404).json({ error: 'Cole√ß√£o n√£o encontrada' });
 
-// Buscar todas as transa√ß√µes financeiras
-app.get('/api/financial/transactions', authenticateAdmin, async (req, res) => {
-  try {
-    let rows = [];
+    // Checar exist√™ncia de produto (tabela products ou produtos)
     try {
-      const [r] = await pool.execute(`
-        SELECT id, data, hora, descricao, categoria, origem, tipo, valor, valor_bruto,
-          status, metodo_pagamento, observacoes, created_at, updated_at
-        FROM financial_transactions
-        ORDER BY data DESC, hora DESC, created_at DESC
-      `);
-      rows = r || [];
-    } catch (schemaErr) {
-      const msg = (schemaErr.message || '').toLowerCase();
-      if (msg.includes('unknown column')) {
-        try {
-          const [r2] = await pool.execute(`
-            SELECT id, data, descricao, categoria, origem, tipo, valor, status,
-              metodo_pagamento, observacoes, created_at, updated_at
-            FROM financial_transactions
-            ORDER BY data DESC, created_at DESC
-          `);
-          rows = (r2 || []).map(r => ({ ...r, hora: null, valor_bruto: null }));
-        } catch (e2) {
-          try {
-            const [r3] = await pool.execute(`
-              SELECT id, data, descricao, categoria, origem, tipo, valor, status,
-                forma_pagamento AS metodo_pagamento, observacoes, created_at, updated_at
-              FROM financial_transactions
-              ORDER BY data DESC, created_at DESC
-            `);
-            rows = (r3 || []).map(r => ({ ...r, hora: null, valor_bruto: null }));
-          } catch (e3) {
-            const [r4] = await pool.execute(`
-              SELECT * FROM financial_transactions ORDER BY data DESC, created_at DESC
-            `);
-            rows = (r4 || []).map(r => ({
-              ...r,
-              metodo_pagamento: r.metodo_pagamento ?? r.forma_pagamento ?? null,
-              hora: r.hora ?? null,
-              valor_bruto: r.valor_bruto ?? null
-            }));
-          }
+      const [pRows] = await pool.execute('SELECT id FROM products WHERE id = ?', [product_id]);
+      if (!pRows || pRows.length === 0) {
+        // Tentar na tabela produtos se n√£o encontrou em products
+        const [pRows2] = await pool.execute('SELECT id FROM produtos WHERE id = ?', [product_id]);
+        if (!pRows2 || pRows2.length === 0) {
+          return res.status(404).json({ error: 'Produto n√£o encontrado' });
         }
-      } else {
-        throw schemaErr;
       }
+    } catch (e) {
+      console.error('‚ùå Erro ao validar produto:', e);
+      return res.status(500).json({ error: 'Erro ao validar produto', message: e?.message });
     }
 
-    const transacoesNormalizadas = rows.map(normalizeFinancialRow).filter(Boolean);
-    logger.info('Transa√ß√µes financeiras carregadas', { count: transacoesNormalizadas.length });
-    res.json({ transactions: transacoesNormalizadas, total: transacoesNormalizadas.length });
+    const ord = Number.isFinite(order_index) ? order_index : 0;
+    const [result] = await pool.execute(
+      'INSERT INTO collection_products (collection_id, product_id, order_index, created_at, updated_at) VALUES (?, ?, ?, NOW(), NOW())',
+      [id, product_id, ord]
+    );
+
+    res.status(201).json({ id: result.insertId, collection_id: id, product_id, order_index: ord });
   } catch (error) {
-    logger.logError(error, req);
-    console.error('GET /api/financial/transactions erro:', error.message);
-    res.status(500).json({ error: 'Erro ao buscar transa√ß√µes financeiras' });
+    console.error('‚ùå Erro ao adicionar produto na cole√ß√£o:', { message: error?.message, code: error?.code });
+    res.status(500).json({ error: 'Erro interno do servidor', message: error?.message, code: error?.code });
   }
 });
 
-
-// Atualizar transa√ß√£o financeira (com ID no body)
-app.put('/api/financial/transactions', authenticateAdmin, async (req, res) => {
+// DELETE /api/collections/:id/products/:productId - Remover v√≠nculo
+app.delete('/api/collections/:id/products/:productId', async (req, res) => {
   try {
-    const { id, descricao, categoria, tipo, valor, status, data, origem, observacoes } = req.body;
-
-    // Validar campos obrigat√≥rios
-    if (!id || !descricao || !categoria || !tipo || !valor) {
-      return res.status(400).json({ error: 'Campos obrigat√≥rios: id, descricao, categoria, tipo, valor' });
-    }
-
-    // Normalizar tipo para min√∫sculo
-    const tipoNormalizado = tipo.toLowerCase();
+    const { id, productId } = req.params;
 
-    // Validar tipo
-    if (!['entrada', 'saida'].includes(tipoNormalizado)) {
-      return res.status(400).json({ error: 'Tipo deve ser "entrada" ou "saida"' });
-    }
+    console.log(`üóëÔ∏è Removendo produto ${productId} da cole√ß√£o ${id}`);
 
-    // Verificar se a transa√ß√£o existe
-    const [existing] = await pool.execute(`
-      SELECT id FROM financial_transactions WHERE id = ?
-    `, [id]);
+    // Verificar se o v√≠nculo existe
+    const [existing] = await pool.execute(
+      'SELECT id FROM collection_products WHERE collection_id = ? AND product_id = ?',
+      [id, productId]
+    );
 
-    if (existing.length === 0) {
-      return res.status(404).json({ error: 'Transa√ß√£o n√£o encontrada' });
+    if (!existing || existing.length === 0) {
+      console.log(`‚ùå V√≠nculo n√£o encontrado: cole√ß√£o ${id}, produto ${productId}`);
+      return res.status(404).json({ error: 'Produto n√£o encontrado nesta cole√ß√£o' });
     }
 
-    const hora = req.body.hora || null;
-    const metodoPagamento = req.body.metodo_pagamento || req.body.forma_pagamento || null;
-
-    let result;
-    try {
-      [result] = await pool.execute(`
-        UPDATE financial_transactions
-        SET descricao = ?, categoria = ?, tipo = ?, valor = ?, status = ?,
-            data = ?, hora = ?, origem = ?, metodo_pagamento = ?, observacoes = ?, updated_at = NOW()
-        WHERE id = ?
-      `, [descricao, categoria, tipoNormalizado, valor, status || 'Pago',
-        data || new Date().toISOString().split('T')[0], hora, origem || '', metodoPagamento, observacoes || '', id]);
-    } catch (schemaErr) {
-      if ((schemaErr.message || '').toLowerCase().includes('unknown column') && (schemaErr.message || '').includes('hora')) {
-        [result] = await pool.execute(`
-          UPDATE financial_transactions
-          SET descricao = ?, categoria = ?, tipo = ?, valor = ?, status = ?,
-              data = ?, origem = ?, metodo_pagamento = ?, observacoes = ?, updated_at = NOW()
-          WHERE id = ?
-        `, [descricao, categoria, tipoNormalizado, valor, status || 'Pago',
-          data || new Date().toISOString().split('T')[0], origem || '', metodoPagamento, observacoes || '', id]);
-      } else {
-        throw schemaErr;
-      }
-    }
+    // Remover o v√≠nculo
+    const [result] = await pool.execute(
+      'DELETE FROM collection_products WHERE collection_id = ? AND product_id = ?',
+      [id, productId]
+    );
 
     if (result.affectedRows === 0) {
-      return res.status(404).json({ error: 'Transa√ß√£o n√£o encontrada' });
+      console.log(`‚ùå Nenhum v√≠nculo foi removido`);
+      return res.status(404).json({ error: 'Produto n√£o encontrado nesta cole√ß√£o' });
     }
 
-    console.log('‚úÖ Transa√ß√£o atualizada com ID:', id);
-
+    console.log(`‚úÖ Produto ${productId} removido da cole√ß√£o ${id} (${result.affectedRows} v√≠nculo(s) removido(s))`);
     res.json({
       success: true,
-      message: 'Transa√ß√£o atualizada com sucesso',
-      transaction: {
-        id,
-        descricao,
-        categoria,
-        tipo: tipoNormalizado,
-        valor,
-        status: status || 'Pago',
-        data: data || new Date().toISOString().split('T')[0],
-        origem: origem || '',
-        observacoes: observacoes || ''
-      }
+      message: 'Produto removido com sucesso',
+      removed_count: result.affectedRows
     });
-  } catch (error) {
-    console.error('‚ùå Erro ao atualizar transa√ß√£o:', error);
-    res.status(500).json({ error: 'Erro interno do servidor' });
-  }
-});
-
-// Atualizar transa√ß√£o financeira (com ID na URL)
-app.put('/api/financial/transactions/:id', authenticateAdmin, async (req, res) => {
-  try {
-    const { id } = req.params;
-    const {
-      data,
-      descricao,
-      categoria,
-      tipo,
-      valor,
-      status,
-      metodo_pagamento,
-      origem,
-      observacoes
-    } = req.body;
-
-    const hora = req.body.hora || null;
-    const metodoPagamento = req.body.metodo_pagamento || req.body.forma_pagamento || metodo_pagamento || null;
-
-    let result;
-    try {
-      [result] = await pool.execute(`
-        UPDATE financial_transactions
-        SET data = ?, hora = ?, descricao = ?, categoria = ?, tipo = ?, valor = ?,
-            status = ?, metodo_pagamento = ?, origem = ?, observacoes = ?, updated_at = NOW()
-        WHERE id = ?
-      `, [data, hora, descricao, categoria, tipo, valor, status, metodoPagamento, origem, observacoes, id]);
-    } catch (schemaErr) {
-      if ((schemaErr.message || '').toLowerCase().includes('unknown column') && (schemaErr.message || '').includes('hora')) {
-        [result] = await pool.execute(`
-          UPDATE financial_transactions
-          SET data = ?, descricao = ?, categoria = ?, tipo = ?, valor = ?,
-              status = ?, metodo_pagamento = ?, origem = ?, observacoes = ?, updated_at = NOW()
-          WHERE id = ?
-        `, [data, descricao, categoria, tipo, valor, status, metodoPagamento, origem, observacoes, id]);
-      } else {
-        throw schemaErr;
-      }
-    }
-
-    if (result.affectedRows === 0) {
-      return res.status(404).json({ error: 'Transa√ß√£o n√£o encontrada' });
-    }
 
-    logger.info('Transa√ß√£o financeira atualizada', { id });
-    res.json({ success: true, message: 'Transa√ß√£o atualizada com sucesso' });
   } catch (error) {
-    logger.logError(error, req);
-    res.status(500).json({ error: 'Erro ao atualizar transa√ß√£o financeira' });
+    console.error('‚ùå Erro ao remover produto da cole√ß√£o:', {
+      message: error?.message,
+      code: error?.code,
+      collectionId: req.params.id,
+      productId: req.params.productId
+    });
+    res.status(500).json({
+      error: 'Erro interno do servidor',
+      message: error?.message,
+      code: error?.code
+    });
   }
 });
 
-// Deletar transa√ß√£o financeira
-app.delete('/api/financial/transactions/:id', authenticateAdmin, async (req, res) => {
+// PATCH /api/collections/:id/products/reorder - Reordenar produtos vinculados
+app.patch('/api/collections/:id/products/reorder', async (req, res) => {
   try {
     const { id } = req.params;
-
-    const [result] = await pool.execute(
-      'DELETE FROM financial_transactions WHERE id = ?',
-      [id]
-    );
-
-    if (result.affectedRows === 0) {
-      return res.status(404).json({ error: 'Transa√ß√£o n√£o encontrada' });
+    const { product_ids } = req.body || {};
+    if (!Array.isArray(product_ids) || product_ids.length === 0) {
+      return res.status(400).json({ error: 'product_ids √© obrigat√≥rio (array)' });
     }
 
-    logger.info('Transa√ß√£o financeira deletada', { id });
-    res.json({ success: true, message: 'Transa√ß√£o deletada com sucesso' });
-  } catch (error) {
-    logger.logError(error, req);
-    res.status(500).json({ error: 'Erro ao deletar transa√ß√£o financeira' });
-  }
-});
-
-// Estornar transa√ß√£o financeira
-app.post('/api/financial/transactions/:id/reverse', authenticateAdmin, async (req, res) => {
-  try {
-    const { id } = req.params;
-    const { motivo } = req.body;
-
-    // Buscar transa√ß√£o original
-    const [rows] = await pool.execute(
-      'SELECT * FROM financial_transactions WHERE id = ?',
-      [id]
-    );
-
-    if (rows.length === 0) {
-      return res.status(404).json({ error: 'Transa√ß√£o n√£o encontrada' });
+    const connection = await pool.getConnection();
+    try {
+      await connection.beginTransaction();
+      for (let i = 0; i < product_ids.length; i++) {
+        await connection.execute(
+          'UPDATE collection_products SET order_index = ?, updated_at = NOW() WHERE collection_id = ? AND product_id = ?',
+          [i, id, product_ids[i]]
+        );
+      }
+      await connection.commit();
+    } catch (e) {
+      await connection.rollback();
+      throw e;
+    } finally {
+      connection.release();
     }
 
-    const originalTransaction = rows[0];
-
-    // Criar transa√ß√£o de estorno (tipo invertido)
-    const tipoEstorno = originalTransaction.tipo === 'entrada' ? 'saida' : 'entrada';
-    const descricaoEstorno = `ESTORNO: ${originalTransaction.descricao}`;
-    const observacoesEstorno = `Estorno da transa√ß√£o #${id}. Motivo: ${motivo || 'N√£o informado'}`;
-
-    const [result] = await pool.execute(`
-      INSERT INTO financial_transactions (
-        descricao, categoria, tipo, valor, status, 
-        metodo_pagamento, data, origem, observacoes
-      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
-    `, [
-      descricaoEstorno,
-      originalTransaction.categoria,
-      tipoEstorno,
-      originalTransaction.valor,
-      'Pago',
-      originalTransaction.metodo_pagamento,
-      new Date().toISOString().split('T')[0],
-      originalTransaction.origem,
-      observacoesEstorno
-    ]);
-
-    // Marcar transa√ß√£o original como estornada
-    await pool.execute(`
-      UPDATE financial_transactions 
-      SET observacoes = CONCAT(COALESCE(observacoes, ''), ' [ESTORNADA EM ${new Date().toISOString().split('T')[0]}]'),
-          updated_at = NOW()
-      WHERE id = ?
-    `, [id]);
-
-    logger.info('Transa√ß√£o estornada', { originalId: id, reversalId: result.insertId });
-    res.json({
-      success: true,
-      message: 'Transa√ß√£o estornada com sucesso',
-      reversalId: result.insertId
-    });
+    res.json({ success: true });
   } catch (error) {
-    logger.logError(error, req);
-    res.status(500).json({ error: 'Erro ao estornar transa√ß√£o', details: error.message });
+    console.error('‚ùå Erro ao reordenar produtos da cole√ß√£o:', { message: error?.message, code: error?.code });
+    res.status(500).json({ error: 'Erro interno do servidor', message: error?.message, code: error?.code });
   }
 });
 
-// Deletar m√∫ltiplas transa√ß√µes
-app.post('/api/financial/transactions/bulk-delete', authenticateAdmin, async (req, res) => {
+
+// PUT /api/collections/reorder - Reordenar cole√ß√µes
+app.put('/api/collections/reorder', async (req, res) => {
   try {
     const { ids } = req.body;
+    console.log('üîÑ Reordenando cole√ß√µes...');
 
     if (!Array.isArray(ids) || ids.length === 0) {
-      return res.status(400).json({ error: 'IDs inv√°lidos' });
+      return res.status(400).json({ error: 'Lista de IDs √© obrigat√≥ria' });
     }
 
-    const placeholders = ids.map(() => '?').join(',');
-    const [result] = await pool.execute(
-      `DELETE FROM financial_transactions WHERE id IN (${placeholders})`,
-      ids
-    );
+    // Atualizar ordem de cada cole√ß√£o (se a coluna ordem existir)
+    const [cols] = await pool.execute("SELECT COLUMN_NAME FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_SCHEMA = DATABASE() AND TABLE_NAME = 'collections'");
+    const hasOrdem = cols.some((c) => c.COLUMN_NAME === 'ordem');
+    for (let i = 0; i < ids.length; i++) {
+      if (hasOrdem) {
+        await pool.execute('UPDATE collections SET ordem = ?, updated_at = NOW() WHERE id = ?', [i, ids[i]]);
+      } else {
+        await pool.execute('UPDATE collections SET updated_at = NOW() WHERE id = ?', [ids[i]]);
+      }
+    }
 
-    logger.info('Transa√ß√µes deletadas em lote', { count: result.affectedRows });
-    res.json({
-      success: true,
-      message: `${result.affectedRows} transa√ß√µes deletadas com sucesso`,
-      deletedCount: result.affectedRows
-    });
+    console.log(`‚úÖ ${ids.length} cole√ß√µes reordenadas com sucesso`);
+    res.json({ message: 'Cole√ß√µes reordenadas com sucesso' });
   } catch (error) {
-    logger.logError(error, req);
-    res.status(500).json({ error: 'Erro ao deletar transa√ß√µes em lote' });
+    console.error('‚ùå Erro ao reordenar cole√ß√µes:', error);
+    res.status(500).json({ error: 'Erro interno do servidor' });
   }
 });
 
-// Atualizar status de m√∫ltiplas transa√ß√µes
-app.post('/api/financial/transactions/bulk-update-status', authenticateAdmin, async (req, res) => {
+// POST /api/collections/seed - Popular cole√ß√µes de exemplo
+app.post('/api/collections/seed', async (req, res) => {
   try {
-    const { ids, status } = req.body;
+    console.log('üîÑ Populando cole√ß√µes de exemplo...');
 
-    if (!Array.isArray(ids) || ids.length === 0) {
-      return res.status(400).json({ error: 'IDs inv√°lidos' });
-    }
+    const colecoesExemplo = [
+      {
+        nome: 'Action Figures Premium',
+        descricao: 'Bonecos de a√ß√£o de alta qualidade com detalhes incr√≠veis e articula√ß√µes avan√ßadas',
+        imagem_url: '/lovable-uploads/action-figures-collection.jpg',
+        destaque: true
+      },
+      {
+        nome: 'Colecion√°veis Vintage',
+        descricao: 'Itens raros e vintage para colecionadores apaixonados por pe√ßas √∫nicas',
+        imagem_url: '/lovable-uploads/vintage-collection.jpg',
+        destaque: true
+      },
+      {
+        nome: 'Brinquedos Educativos',
+        descricao: 'Jogos e brinquedos que estimulam o aprendizado e desenvolvimento infantil',
+        imagem_url: '/lovable-uploads/educational-toys.jpg',
+        destaque: false
+      },
+      {
+        nome: 'Pel√∫cias Premium',
+        descricao: 'Pel√∫cias macias e fofas, perfeitas para conforto e decora√ß√£o',
+        imagem_url: '/lovable-uploads/plush-toys.jpg',
+        destaque: false
+      },
+      {
+        nome: 'Jogos de Tabuleiro',
+        descricao: 'Cl√°ssicos e modernos jogos de tabuleiro para divers√£o em fam√≠lia',
+        imagem_url: '/lovable-uploads/board-games.jpg',
+        destaque: true
+      },
+      {
+        nome: 'Carrinhos e Ve√≠culos',
+        descricao: 'Carros, caminh√µes e ve√≠culos de todos os tipos para pequenos motoristas',
+        imagem_url: '/lovable-uploads/vehicles-collection.jpg',
+        destaque: false
+      }
+    ];
 
-    if (!['Pago', 'Pendente', 'Atrasado'].includes(status)) {
-      return res.status(400).json({ error: 'Status inv√°lido' });
+    for (const colecao of colecoesExemplo) {
+      await pool.execute(
+        'INSERT IGNORE INTO collections (nome, descricao, imagem_url, destaque, ativo, created_at, updated_at) VALUES (?, ?, ?, ?, 1, NOW(), NOW())',
+        [colecao.nome, colecao.descricao, colecao.imagem_url, colecao.destaque]
+      );
     }
 
-    const placeholders = ids.map(() => '?').join(',');
-    const [result] = await pool.execute(
-      `UPDATE financial_transactions SET status = ?, updated_at = NOW() WHERE id IN (${placeholders})`,
-      [status, ...ids]
-    );
-
-    logger.info('Status de transa√ß√µes atualizado em lote', { count: result.affectedRows, status });
-    res.json({
-      success: true,
-      message: `${result.affectedRows} transa√ß√µes atualizadas para ${status}`,
-      updatedCount: result.affectedRows
-    });
+    console.log(`‚úÖ ${colecoesExemplo.length} cole√ß√µes de exemplo criadas`);
+    res.json({ message: `${colecoesExemplo.length} cole√ß√µes de exemplo criadas com sucesso` });
   } catch (error) {
-    logger.logError(error, req);
-    res.status(500).json({ error: 'Erro ao atualizar status em lote' });
+    console.error('‚ùå Erro ao popular cole√ß√µes:', error);
+    res.status(500).json({ error: 'Erro interno do servidor' });
   }
 });
 
-// Criar transa√ß√£o financeira
-app.post('/api/financial/transactions', authenticateAdmin, async (req, res) => {
+// Upload de imagem para cole√ß√µes
+app.post('/api/collections/upload-image', upload.single('image'), async (req, res) => {
   try {
-    const { descricao, categoria, tipo, valor, status, metodo_pagamento, data, origem, observacoes } = req.body;
-
-    // Valida√ß√µes b√°sicas
-    if (!descricao || !categoria || !tipo || !valor) {
-      return res.status(400).json({
-        error: 'Campos obrigat√≥rios: descricao, categoria, tipo, valor'
-      });
-    }
-
-    if (valor <= 0) {
-      return res.status(400).json({ error: 'Valor deve ser maior que zero' });
-    }
-
-    // Normalizar tipo para min√∫sculo e mapear para ENUM do banco ('Entrada' / 'Sa√≠da')
-    const tipoLower = (tipo || '').toLowerCase();
-    if (!['entrada', 'saida'].includes(tipoLower)) {
-      return res.status(400).json({ error: 'Tipo deve ser "entrada" ou "saida"' });
+    if (!req.file) {
+      return res.status(400).json({ error: 'Nenhuma imagem foi enviada' });
     }
-    const tipoEnum = tipoLower === 'entrada' ? 'Entrada' : 'Sa√≠da';
 
-    // Tratar valores undefined como null
-    const safeStatus = status || 'Pendente';
-    const safeMetodoPagamento = metodo_pagamento || 'N√£o informado';
-    const safeData = data || new Date().toISOString().split('T')[0];
-    const safeOrigem = origem || null;
-    const safeObservacoes = observacoes || null;
-    const safeHora = req.body.hora || null;
-
-    let result;
-    try {
-      [result] = await pool.execute(`
-        INSERT INTO financial_transactions (
-          descricao, categoria, tipo, valor, status,
-          metodo_pagamento, data, hora, origem, observacoes
-        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
-      `, [
-        descricao, categoria, tipoEnum, valor, safeStatus,
-        safeMetodoPagamento, safeData, safeHora, safeOrigem, safeObservacoes
-      ]);
-    } catch (schemaErr) {
-      const msg = (schemaErr.message || '').toLowerCase();
-      if (msg.includes('unknown column') && msg.includes('hora')) {
-        [result] = await pool.execute(`
-          INSERT INTO financial_transactions (
-            descricao, categoria, tipo, valor, status,
-            metodo_pagamento, data, origem, observacoes
-          ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
-        `, [
-          descricao, categoria, tipoEnum, valor, safeStatus,
-          safeMetodoPagamento, safeData, safeOrigem, safeObservacoes
-        ]);
-      } else if (msg.includes('unknown column') && msg.includes('metodo_pagamento')) {
-        [result] = await pool.execute(`
-          INSERT INTO financial_transactions (
-            descricao, categoria, tipo, valor, status,
-            forma_pagamento, data, hora, origem, observacoes
-          ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
-        `, [
-          descricao, categoria, tipoEnum, valor, safeStatus,
-          safeMetodoPagamento, safeData, safeHora, safeOrigem, safeObservacoes
-        ]);
-      } else if (msg.includes('unknown column')) {
-        try {
-          [result] = await pool.execute(`
-            INSERT INTO financial_transactions (
-              descricao, categoria, tipo, valor, status,
-              forma_pagamento, data, origem, observacoes
-            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
-          `, [
-            descricao, categoria, tipoEnum, valor, safeStatus,
-            safeMetodoPagamento, safeData, safeOrigem, safeObservacoes
-          ]);
-        } catch (e2) {
-          throw schemaErr;
-        }
-      } else {
-        throw schemaErr;
-      }
-    }
+    const imageUrl = `/lovable-uploads/${req.file.filename}`;
+    const fullUrl = getPublicUrl(req, imageUrl);
 
-    const insertedId = result.insertId;
+    console.log(`‚úÖ Imagem de cole√ß√£o enviada: ${req.file.filename}`);
 
-    logger.info('Transa√ß√£o financeira criada', { id: insertedId });
     res.json({
       success: true,
-      message: 'Transa√ß√£o criada com sucesso',
-      transaction: {
-        id: insertedId,
-        descricao,
-        categoria,
-        tipo: tipoEnum,
-        valor,
-        status: safeStatus,
-        metodo_pagamento: safeMetodoPagamento,
-        data: safeData,
-        origem: safeOrigem,
-        observacoes: safeObservacoes
-      }
+      imageUrl: imageUrl,
+      fullUrl: fullUrl,
+      filename: req.file.filename
     });
   } catch (error) {
-    logger.logError(error, req);
-    res.status(500).json({ error: 'Erro ao criar transa√ß√£o financeira', ...(process.env.NODE_ENV !== 'production' && { details: error.message }) });
+    console.error('‚ùå Erro no upload de imagem:', error);
+    res.status(500).json({ error: 'Erro interno do servidor' });
   }
 });
 
-// Buscar transa√ß√£o por ID (resiliente a schema sem hora/valor_bruto)
-app.get('/api/financial/transactions/:id', authenticateAdmin, async (req, res) => {
+// Upload direto da imagem da cole√ß√£o (multipart) e atualizar registro
+app.post('/api/collections/:id/image', upload.single('image'), async (req, res) => {
   try {
     const { id } = req.params;
-    let rows;
-    try {
-      [rows] = await pool.execute(
-        `SELECT id, data, hora, descricao, categoria, origem, tipo, valor, valor_bruto,
-         status, metodo_pagamento, observacoes, created_at, updated_at
-         FROM financial_transactions WHERE id = ?`,
-        [id]
-      );
-    } catch (schemaErr) {
-      if (!(schemaErr.message || '').toLowerCase().includes('unknown column')) throw schemaErr;
-      try {
-        [rows] = await pool.execute(
-          `SELECT id, data, descricao, categoria, origem, tipo, valor, status,
-           metodo_pagamento, observacoes, created_at, updated_at
-           FROM financial_transactions WHERE id = ?`,
-          [id]
-        );
-      } catch (e2) {
-        [rows] = await pool.execute(
-          `SELECT id, data, descricao, categoria, origem, tipo, valor, status,
-           forma_pagamento AS metodo_pagamento, observacoes, created_at, updated_at
-           FROM financial_transactions WHERE id = ?`,
-          [id]
-        );
-      }
-      rows = (rows || []).map(r => ({ ...r, hora: r.hora || null, valor_bruto: r.valor_bruto ?? null }));
-    }
+    if (!req.file) return res.status(400).json({ error: 'Nenhuma imagem foi enviada' });
+    // garantir que a cole√ß√£o existe
+    const [rows] = await pool.execute('SELECT id FROM collections WHERE id = ?', [id]);
+    if (!rows || rows.length === 0) return res.status(404).json({ error: 'Cole√ß√£o n√£o encontrada' });
 
-    if (!rows || rows.length === 0) {
-      return res.status(404).json({ error: 'Transa√ß√£o n√£o encontrada' });
-    }
+    const imageUrl = `/lovable-uploads/${req.file.filename}`;
+    await pool.execute('UPDATE collections SET imagem_url = ?, updated_at = NOW() WHERE id = ?', [imageUrl, id]);
 
-    res.json({ transaction: rows[0] });
+    const host = req.get('host');
+    const proto = req.protocol || 'http';
+    const fullUrl = getPublicUrl(req, imageUrl);
+    res.json({ success: true, id, imagem_url: imageUrl, imagem: fullUrl, filename: req.file.filename });
   } catch (error) {
-    logger.logError(error, req);
-    res.status(500).json({ error: 'Erro ao buscar transa√ß√£o financeira' });
+    console.error('‚ùå Erro ao atualizar imagem da cole√ß√£o:', error);
+    res.status(500).json({ error: 'Erro interno do servidor' });
   }
 });
 
-// Importar extrato banc√°rio
-const bankStatementUpload = multer({ dest: 'uploads/' });
-app.post('/api/financial/bank-statements/import', authenticateAdmin, bankStatementUpload.single('file'), async (req, res) => {
+// ===== P√ÅGINA SOBRE API =====
+
+// GET /api/sobre/content - Buscar conte√∫do da p√°gina Sobre
+app.get('/api/sobre/content', async (req, res) => {
   try {
-    let transactions = [];
+    const [rows] = await pool.execute(`
+      SELECT * FROM sobre_content 
+      WHERE is_active = TRUE 
+      ORDER BY order_index ASC, created_at ASC
+    `);
+    res.json(rows);
+  } catch (error) {
+    console.error('‚ùå Erro ao buscar conte√∫do da p√°gina Sobre:', error);
+    res.status(500).json({ error: 'Erro interno do servidor' });
+  }
+});
 
-    if (req.body && req.body.transactions) {
-      try {
-        const raw = req.body.transactions;
-        transactions = typeof raw === 'string' ? JSON.parse(raw) : (Array.isArray(raw) ? raw : []);
-      } catch (e) {
-        console.error('Parse transactions:', e.message);
-        return res.status(400).json({ error: 'Erro ao processar dados das transa√ß√µes. Verifique o formato.' });
-      }
-    }
-    if (!Array.isArray(transactions) || transactions.length === 0) {
-      return res.status(400).json({
-        error: 'Nenhuma transa√ß√£o para importar. Envie o arquivo CSV e confirme no preview antes de importar.'
-      });
-    }
+// PUT /api/sobre/content/:section - Atualizar conte√∫do de uma se√ß√£o
+app.put('/api/sobre/content/:section', async (req, res) => {
+  try {
+    const { section } = req.params;
+    const { title, subtitle, description, image_url, metadata } = req.body;
 
-    const contaId = req.body.conta_id ? parseInt(req.body.conta_id) : null;
-    let imported = 0;
-    let skippedDuplicates = 0;
-    let errors = [];
-    let useMinimalSchema = false;
-    let useFormaPagamentoColumn = false;
-    let duplicateCheckQuery = null; // preenchido na primeira verifica√ß√£o (com ou sem hora)
+    const id = require('crypto').randomUUID();
 
-    // ENUM na tabela √© ('Entrada','Sa√≠da') ‚Äî usar valor exato
-    const toTipoEnum = (t) => (t === 'credito' || (typeof t === 'string' && t.toLowerCase() === 'entrada')) ? 'Entrada' : 'Sa√≠da';
+    // Garantir que os valores n√£o sejam undefined
+    const safeTitle = title || null;
+    const safeSubtitle = subtitle || null;
+    const safeDescription = description || null;
+    const safeImageUrl = image_url || null;
+    const safeMetadata = metadata ? JSON.stringify(metadata) : null;
 
-    const toDate = (d) => {
-      if (!d) return null;
-      if (typeof d === 'string' && /^\d{4}-\d{2}-\d{2}$/.test(d)) return d;
-      const parsed = new Date(d);
-      return isNaN(parsed.getTime()) ? null : parsed.toISOString().slice(0, 10);
-    };
 
-    // Verificar se transa√ß√£o j√° existe (mesma data, hora, valor e descri√ß√£o) para evitar duplicatas entre CSVs
-    const isDuplicate = async (data, hora, valor, descricao) => {
-      const desc = (descricao || '').substring(0, 255);
-      if (duplicateCheckQuery === 'with_hora') {
-        const [rows] = await pool.execute(
-          `SELECT id FROM financial_transactions WHERE data = ? AND (hora <=> ?) AND ABS(valor - ?) < 0.01 AND descricao = ? LIMIT 1`,
-          [data, hora || null, valor, desc]
-        );
-        return rows.length > 0;
-      }
-      if (duplicateCheckQuery === 'no_hora') {
-        const [rows] = await pool.execute(
-          `SELECT id FROM financial_transactions WHERE data = ? AND ABS(valor - ?) < 0.01 AND descricao = ? LIMIT 1`,
-          [data, valor, desc]
-        );
-        return rows.length > 0;
-      }
-      try {
-        const [rows] = await pool.execute(
-          `SELECT id FROM financial_transactions WHERE data = ? AND (hora <=> ?) AND ABS(valor - ?) < 0.01 AND descricao = ? LIMIT 1`,
-          [data, hora || null, valor, desc]
-        );
-        duplicateCheckQuery = 'with_hora';
-        return rows.length > 0;
-      } catch (e) {
-        if ((e.message || '').toLowerCase().includes('unknown column') && (e.message || '').includes('hora')) {
-          duplicateCheckQuery = 'no_hora';
-          const [rows] = await pool.execute(
-            `SELECT id FROM financial_transactions WHERE data = ? AND ABS(valor - ?) < 0.01 AND descricao = ? LIMIT 1`,
-            [data, valor, desc]
-          );
-          return rows.length > 0;
-        }
-        throw e;
-      }
-    };
+    await pool.execute(`
+      INSERT INTO sobre_content (id, section, title, subtitle, description, image_url, metadata, is_active)
+      VALUES (?, ?, ?, ?, ?, ?, ?, TRUE)
+      ON DUPLICATE KEY UPDATE
+        title = VALUES(title),
+        subtitle = VALUES(subtitle),
+        description = VALUES(description),
+        image_url = VALUES(image_url),
+        metadata = VALUES(metadata),
+        updated_at = CURRENT_TIMESTAMP
+    `, [id, section, safeTitle, safeSubtitle, safeDescription, safeImageUrl, safeMetadata]);
 
-    console.log(`üì• Importando ${transactions.length} transa√ß√µes...`);
-    for (const trans of transactions) {
-      try {
-        const tipo = toTipoEnum(trans.tipo);
-        const metodoPagamento = (trans.metodo_pagamento && trans.metodo_pagamento !== 'N/A')
-          ? String(trans.metodo_pagamento).substring(0, 50)
-          : (contaId ? `Conta: ${contaId}` : 'PIX');
-        const origem = (trans.origem && trans.origem !== 'N/A' && trans.origem !== 'Extrato Banc√°rio')
-          ? String(trans.origem).substring(0, 255)
-          : (trans.origem ? String(trans.origem).substring(0, 255) : 'Extrato Banc√°rio');
-        const observacoes = trans.observacoes
-          ? String(trans.observacoes).substring(0, 65535)
-          : `Importado automaticamente em ${new Date().toLocaleString('pt-BR')}`;
-        const data = toDate(trans.data) || new Date().toISOString().slice(0, 10);
-        const valor = Number(trans.valor);
-        if (isNaN(valor) || valor <= 0) {
-          errors.push(`Valor inv√°lido: ${trans.descricao || 'linha'}`);
-          continue;
-        }
+    res.json({ success: true, message: 'Conte√∫do atualizado com sucesso' });
+  } catch (error) {
+    console.error('‚ùå Erro ao atualizar conte√∫do da p√°gina Sobre:', error);
+    res.status(500).json({ error: 'Erro interno do servidor' });
+  }
+});
 
-        const descricaoNorm = (trans.descricao || 'Transa√ß√£o importada').substring(0, 255);
-        if (await isDuplicate(data, trans.hora || null, valor, descricaoNorm)) {
-          skippedDuplicates++;
-          continue;
-        }
+// PUT /api/sobre/content/:id - Atualizar conte√∫do espec√≠fico por ID
+app.put('/api/sobre/content/:id', async (req, res) => {
+  try {
+    const { id } = req.params;
+    const { title, subtitle, description, image_url, metadata } = req.body;
 
-        if (!useMinimalSchema) {
-          const valorBruto = trans.valor_bruto != null && trans.valor_bruto !== '' ? Number(trans.valor_bruto) : null;
-          try {
-            await pool.execute(`
-              INSERT INTO financial_transactions 
-              (descricao, categoria, tipo, valor, valor_bruto, status, data, hora, origem, metodo_pagamento, observacoes, created_at, updated_at)
-              VALUES (?, ?, ?, ?, ?, 'Pago', ?, ?, ?, ?, ?, NOW(), NOW())
-            `, [
-              descricaoNorm,
-              (trans.categoria || 'Outros').substring(0, 100),
-              tipo,
-              valor,
-              valorBruto,
-              data,
-              trans.hora || null,
-              origem,
-              metodoPagamento,
-              observacoes
-            ]);
-            imported++;
-            continue;
-          } catch (schemaErr) {
-            if ((schemaErr.message || '').toLowerCase().includes('unknown column')) {
-              useMinimalSchema = true;
-            } else {
-              throw schemaErr;
-            }
-          }
-        }
+    // Garantir que os valores n√£o sejam undefined
+    const safeTitle = title || null;
+    const safeSubtitle = subtitle || null;
+    const safeDescription = description || null;
+    const safeImageUrl = image_url || null;
+    const safeMetadata = metadata ? JSON.stringify(metadata) : null;
 
-        if (useMinimalSchema) {
-          const insertMinimal = (colPagamento) => pool.execute(`
-            INSERT INTO financial_transactions 
-            (descricao, categoria, tipo, valor, status, data, origem, ${colPagamento}, observacoes, created_at, updated_at)
-            VALUES (?, ?, ?, ?, 'Pago', ?, ?, ?, ?, NOW(), NOW())
-          `, [
-            descricaoNorm,
-            (trans.categoria || 'Outros').substring(0, 100),
-            tipo,
-            valor,
-            data,
-            origem,
-            metodoPagamento,
-            observacoes
-          ]);
-          try {
-            await insertMinimal(useFormaPagamentoColumn ? 'forma_pagamento' : 'metodo_pagamento');
-          } catch (colErr) {
-            if (!useFormaPagamentoColumn && (colErr.message || '').toLowerCase().includes('unknown column') && (colErr.message || '').includes('metodo_pagamento')) {
-              useFormaPagamentoColumn = true;
-              await insertMinimal('forma_pagamento');
-            } else {
-              throw colErr;
-            }
-          }
-          imported++;
-        }
-      } catch (error) {
-        console.error('Erro ao importar transa√ß√£o:', error);
-        errors.push(`Erro ao importar: ${(trans.descricao || 'linha').substring(0, 40)} - ${error.message}`);
-      }
-    }
+    await pool.execute(`
+      UPDATE sobre_content 
+      SET title = ?, subtitle = ?, description = ?, image_url = ?, metadata = ?, updated_at = CURRENT_TIMESTAMP
+      WHERE id = ?
+    `, [safeTitle, safeSubtitle, safeDescription, safeImageUrl, safeMetadata, id]);
 
-    // Limpar arquivo tempor√°rio se existir
-    if (req.file && fs.existsSync(req.file.path)) {
-      fs.unlinkSync(req.file.path);
-    }
+    res.json({ success: true, message: 'Conte√∫do atualizado com sucesso' });
+  } catch (error) {
+    console.error('‚ùå Erro ao atualizar conte√∫do da p√°gina Sobre:', error);
+    res.status(500).json({ error: 'Erro interno do servidor' });
+  }
+});
 
-    logger.info('Extrato banc√°rio importado', { imported, skippedDuplicates, total: transactions.length, errors: errors.length });
+// POST /api/sobre/upload-image - Upload de imagem para p√°gina Sobre
+app.post('/api/sobre/upload-image', upload.single('image'), async (req, res) => {
+  try {
+    if (!req.file) {
+      return res.status(400).json({ error: 'Nenhuma imagem enviada' });
+    }
 
-    const msgParts = [];
-    if (imported > 0) msgParts.push(`${imported} importada(s)`);
-    if (skippedDuplicates > 0) msgParts.push(`${skippedDuplicates} j√° existiam (n√£o duplicadas)`);
-    if (errors.length > 0) msgParts.push(`${errors.length} falha(s)`);
-    const message = msgParts.length ? msgParts.join(', ') + '.' : 'Nenhuma transa√ß√£o nova para importar.';
+    const imageUrl = `/lovable-uploads/${req.file.filename}`;
+    res.json({
+      success: true,
+      image_url: imageUrl,
+      message: 'Imagem enviada com sucesso'
+    });
+  } catch (error) {
+    console.error('‚ùå Erro no upload de imagem da p√°gina Sobre:', error);
+    res.status(500).json({ error: 'Erro interno do servidor' });
+  }
+});
 
-    res.json({
-      success: true,
-      imported,
-      skippedDuplicates,
-      total: transactions.length,
-      errors: errors.length > 0 ? errors.slice(0, 15) : [],
-      message
-    });
+// GET /api/sobre/values - Buscar valores da empresa
+app.get('/api/sobre/values', async (req, res) => {
+  try {
+    const [rows] = await pool.execute(`
+      SELECT * FROM company_values 
+      WHERE is_active = TRUE 
+      ORDER BY order_index ASC, created_at ASC
+    `);
+    res.json(rows);
   } catch (error) {
-    logger.logError(error, req);
-    console.error('Import extrato erro:', error.message);
-    res.status(500).json({ error: 'Erro ao importar extrato banc√°rio' });
+    console.error('‚ùå Erro ao buscar valores da empresa:', error);
+    res.status(500).json({ error: 'Erro interno do servidor' });
   }
 });
 
-// Importar extrato banc√°rio PDF (formato InfinitePay mensal)
-app.post('/api/financial/bank-statements/import-pdf', authenticateAdmin, bankStatementUpload.single('file'), async (req, res) => {
+// POST /api/sobre/values - Criar novo valor
+app.post('/api/sobre/values', async (req, res) => {
   try {
-    if (!req.file) {
-      return res.status(400).json({ error: 'Arquivo PDF √© obrigat√≥rio' });
-    }
-
-    // Verificar se √© PDF
-    if (!req.file.mimetype.includes('pdf') && !req.file.originalname.toLowerCase().endsWith('.pdf')) {
-      return res.status(400).json({ error: 'Apenas arquivos PDF s√£o aceitos' });
-    }
-
-    const pdfParse = require('pdf-parse');
-    const pdfBuffer = fs.readFileSync(req.file.path);
-
-    let pdfText;
-    try {
-      // pdf-parse v2+ exporta uma classe PDFParse
-      if (pdfParse.PDFParse && typeof pdfParse.PDFParse === 'function') {
-        // Usar a classe PDFParse com m√©todo getText()
-        const parser = new pdfParse.PDFParse({ data: pdfBuffer });
-        console.log('üìÑ Parser criado, chamando getText()...');
-
-        // Tentar getText() com diferentes op√ß√µes
-        let result = await parser.getText({
-          pageJoiner: '\n',  // Junta p√°ginas com quebra de linha
-          lineEnforce: true, // For√ßa quebras de linha
-          cellSeparator: ' ' // Separador de c√©lulas
-        });
-
-        console.log('üìÑ Result do getText():', typeof result, result ? Object.keys(result) : 'null');
-
-        // getText() retorna { text: string, pages: [...] }
-        pdfText = result?.text || (typeof result === 'string' ? result : '');
-
-        // Se ainda n√£o tem texto suficiente, tentar sem pageJoiner ou com outras op√ß√µes
-        if (!pdfText || pdfText.length < 500) {
-          console.log('‚ö†Ô∏è Texto muito curto, tentando sem pageJoiner...');
-          result = await parser.getText({
-            pageJoiner: '',  // Sem separador de p√°gina
-            lineEnforce: false
-          });
-          pdfText = result?.text || pdfText || '';
-        }
-
-        // Se o texto est√° muito curto, tentar extrair das p√°ginas individualmente
-        if ((!pdfText || pdfText.length < 500) && result && result.pages) {
-          console.log('üìÑ Tentando extrair texto das p√°ginas individuais...');
-          console.log('üìÑ Total de p√°ginas:', result.pages.length);
-
-          // Extrair texto de cada p√°gina
-          const pageTexts = [];
-          for (let i = 0; i < result.pages.length; i++) {
-            const page = result.pages[i];
-            console.log(`üìÑ P√°gina ${i + 1} estrutura:`, page ? Object.keys(page) : 'null');
-
-            if (page && page.text) {
-              pageTexts.push(page.text);
-              console.log(`üìÑ P√°gina ${i + 1} tem ${page.text.length} caracteres`);
-              if (i === 0) {
-                console.log(`üìÑ Primeiros 300 chars da p√°gina ${i + 1}:`, page.text.substring(0, 300));
-              }
-            } else if (page && typeof page === 'string') {
-              pageTexts.push(page);
-              console.log(`üìÑ P√°gina ${i + 1} √© string com ${page.length} caracteres`);
-            } else if (page && page.content) {
-              pageTexts.push(page.content);
-              console.log(`üìÑ P√°gina ${i + 1} tem content com ${page.content.length} caracteres`);
-            } else {
-              console.log(`‚ö†Ô∏è P√°gina ${i + 1} n√£o tem texto extra√≠vel (provavelmente √© imagem escaneada)`);
-            }
-          }
-
-          if (pageTexts.length > 0) {
-            pdfText = pageTexts.join('\n');
-            console.log('üìÑ Texto combinado das p√°ginas:', pdfText.length, 'caracteres');
-          }
-        }
-
-        // Se ainda n√£o tem texto, verificar outras propriedades
-        if (!pdfText && result) {
-          console.log('üìÑ Tentando propriedades alternativas...');
-          console.log('üìÑ result.text:', result.text ? result.text.substring(0, 200) : 'N/A');
-          console.log('üìÑ result.pages:', result.pages ? result.pages.length : 'N/A');
-          if (result.pages && result.pages.length > 0) {
-            console.log('üìÑ Primeira p√°gina:', result.pages[0] ? Object.keys(result.pages[0]) : 'N/A');
-            pdfText = result.text || result.content || (result.pages && result.pages.map(p => p.text || p.content || '').join('\n')) || '';
-          }
-        }
-
-        // Destruir o parser
-        await parser.destroy();
-      } else if (typeof pdfParse === 'function') {
-        // Vers√£o antiga - fun√ß√£o direta
-        const pdfData = await pdfParse(pdfBuffer);
-        pdfText = pdfData.text;
-      } else {
-        throw new Error('Formato de exporta√ß√£o do pdf-parse n√£o reconhecido');
-      }
-    } catch (parseError) {
-      console.error('‚ùå Erro ao fazer parse do PDF:', parseError);
-      console.error('‚ùå Stack:', parseError.stack);
-      return res.status(500).json({
-        error: 'Erro ao processar PDF',
-        details: parseError.message
-      });
-    }
-
-    console.log('üìÑ PDF processado, tamanho do texto:', pdfText ? pdfText.length : 0);
-    if (pdfText && pdfText.length > 0) {
-      console.log('üìÑ Primeiros 500 caracteres:', pdfText.substring(0, 500));
-    } else {
-      console.log('‚ö†Ô∏è AVISO: Nenhum texto extra√≠do do PDF!');
-    }
+    const { title, description, icon, order_index } = req.body;
+    const id = require('crypto').randomUUID();
 
-    // Parse do texto do PDF - formato InfinitePay
-    const transactions = [];
-    const lines = pdfText.split('\n').map(l => l.trim()).filter(l => l.length > 0);
+    await pool.execute(`
+      INSERT INTO company_values (id, title, description, icon, order_index, is_active)
+      VALUES (?, ?, ?, ?, ?, TRUE)
+    `, [id, title, description, icon, order_index || 0]);
 
-    console.log('üìÑ Total de linhas no PDF:', lines.length);
-    console.log('üìÑ Primeiras 10 linhas:', lines.slice(0, 10));
+    res.json({ success: true, id, message: 'Valor criado com sucesso' });
+  } catch (error) {
+    console.error('‚ùå Erro ao criar valor:', error);
+    res.status(500).json({ error: 'Erro interno do servidor' });
+  }
+});
 
-    // Procurar padr√£o de tabela: Data | Hora | Tipo | Nome | Detalhe | Valor
-    let currentDate = '';
+// PUT /api/sobre/values/:id - Atualizar valor
+app.put('/api/sobre/values/:id', async (req, res) => {
+  try {
+    const { id } = req.params;
+    const { title, description, icon, order_index, is_active } = req.body;
 
-    for (let i = 0; i < lines.length; i++) {
-      const line = lines[i];
+    await pool.execute(`
+      UPDATE company_values 
+      SET title = ?, description = ?, icon = ?, order_index = ?, is_active = ?
+      WHERE id = ?
+    `, [title, description, icon, order_index || 0, is_active !== false, id]);
 
-      // Ignorar cabe√ßalhos e linhas de saldo
-      if (line.includes('Saldo do dia') ||
-        line.includes('Central de Ajuda') ||
-        line.includes('Relat√≥rio de movimenta√ß√µes') ||
-        line.toLowerCase().includes('infinitepay') ||
-        line.includes('CNPJ:') ||
-        line.match(/^Saldo final/) ||
-        line.match(/^\d{2}\/\d{2}\/\d{4} - \d{2}\/\d{2}\/\d{4}$/) || // Per√≠odo
-        line.match(/^\|.*Data.*Hora.*Tipo.*Nome.*Detalhe.*Valor/i)) { // Cabe√ßalho de tabela
-        continue;
-      }
+    res.json({ success: true, message: 'Valor atualizado com sucesso' });
+  } catch (error) {
+    console.error('‚ùå Erro ao atualizar valor:', error);
+    res.status(500).json({ error: 'Erro interno do servidor' });
+  }
+});
 
-      // Detectar data no in√≠cio da linha (formato DD/MM/YYYY)
-      const dateMatch = line.match(/^(\d{2}\/\d{2}\/\d{4})/);
-      if (dateMatch) {
-        currentDate = dateMatch[1];
-        // Continuar para processar a transa√ß√£o na mesma linha se houver
-      }
+// DELETE /api/sobre/values/:id - Deletar valor
+app.delete('/api/sobre/values/:id', async (req, res) => {
+  try {
+    const { id } = req.params;
 
-      // Processar linha de transa√ß√£o - pode ter ou n√£o pipes
-      // Padr√£o 1: Linha com pipes (tabela estruturada)
-      if (line.includes('|')) {
-        const parts = line.split('|').map(p => p.trim()).filter(p => p.length > 0);
+    await pool.execute('DELETE FROM company_values WHERE id = ?', [id]);
 
-        if (parts.length >= 4) {
-          try {
-            // Formato: Data | Hora | Tipo | Nome | Detalhe | Valor
-            let data = currentDate || (parts[0].match(/\d{2}\/\d{2}\/\d{4}/) ? parts[0] : '');
-            let hora = '';
-            let tipo = '';
-            let nome = '';
-            let detalhe = '';
-            let valorStr = '';
-
-            // Encontrar hora (formato HH:MM)
-            let horaIndex = -1;
-            for (let j = 0; j < parts.length; j++) {
-              if (parts[j].match(/^\d{2}:\d{2}$/)) {
-                hora = parts[j];
-                horaIndex = j;
-                break;
-              }
-            }
+    res.json({ success: true, message: 'Valor deletado com sucesso' });
+  } catch (error) {
+    console.error('‚ùå Erro ao deletar valor:', error);
+    res.status(500).json({ error: 'Erro interno do servidor' });
+  }
+});
 
-            // Encontrar valor (√∫ltima coluna com +, -, R$ ou n√∫mero)
-            for (let j = parts.length - 1; j >= 0; j--) {
-              const part = parts[j];
-              if (part.match(/[+\-]/) || part.includes('R$') || part.match(/^\d+[,.]?\d*$/)) {
-                valorStr = part;
-                break;
-              }
-            }
+// GET /api/sobre/team - Buscar membros da equipe
+app.get('/api/sobre/team', async (req, res) => {
+  try {
+    const [rows] = await pool.execute(`
+      SELECT * FROM team_members 
+      WHERE is_active = 1 
+      ORDER BY order_index ASC, created_at ASC
+    `);
+    res.json(rows);
+  } catch (error) {
+    console.error('‚ùå Erro ao buscar membros da equipe:', error);
+    res.status(500).json({ error: 'Erro interno do servidor' });
+  }
+});
 
-            // Preencher tipo, nome, detalhe
-            if (horaIndex >= 0) {
-              tipo = parts.length > horaIndex + 1 ? parts[horaIndex + 1] : '';
-              nome = parts.length > horaIndex + 2 ? parts[horaIndex + 2] : '';
-              detalhe = parts.length > horaIndex + 3 ? parts[horaIndex + 3] : '';
-            } else {
-              // Sem hora, tentar inferir estrutura
-              if (parts.length >= 6) {
-                tipo = parts[1] || '';
-                nome = parts[2] || '';
-                detalhe = parts[3] || '';
-              }
-            }
+// POST /api/sobre/team - Criar novo membro da equipe
+app.post('/api/sobre/team', async (req, res) => {
+  try {
+    const { name, position, description, image_url, order_index } = req.body;
+    const id = require('crypto').randomUUID();
 
-            // Parse do valor
-            let valor = 0;
-            let isCredito = false;
-
-            if (valorStr) {
-              const cleaned = valorStr.replace(/R\$/g, '').replace(/\s/g, '').trim();
-              isCredito = cleaned.startsWith('+');
-              const signedCleaned = cleaned.replace(/^[+\-]/, '');
-
-              if (signedCleaned.includes('.') && signedCleaned.includes(',')) {
-                valor = parseFloat(signedCleaned.replace(/\./g, '').replace(',', '.'));
-              } else if (signedCleaned.includes(',')) {
-                valor = parseFloat(signedCleaned.replace(',', '.'));
-              } else {
-                valor = parseFloat(signedCleaned);
-              }
-            }
+    await pool.execute(`
+      INSERT INTO team_members (id, name, position, description, image_url, order_index, is_active)
+      VALUES (?, ?, ?, ?, ?, ?, TRUE)
+    `, [
+      id,
+      name ?? null,
+      position ?? null,
+      description ?? null,
+      image_url ?? null,
+      order_index ?? 0
+    ]);
 
-            if (valor > 0 && data && data.match(/\d{2}\/\d{2}\/\d{4}/)) {
-              const dateParts = data.split('/');
-              const formattedDate = `${dateParts[2]}-${dateParts[1].padStart(2, '0')}-${dateParts[0].padStart(2, '0')}`;
-
-              const descricao = nome
-                ? `${nome}${detalhe ? ` - ${detalhe}` : ''}${tipo ? ` (${tipo})` : ''}`
-                : `${detalhe || tipo || 'Transa√ß√£o importada'}`;
-
-              transactions.push({
-                data: formattedDate,
-                hora: hora || undefined,
-                descricao: descricao.substring(0, 255),
-                valor: Math.abs(valor),
-                tipo: isCredito ? 'credito' : 'debito'
-              });
-            }
-          } catch (err) {
-            console.warn(`Erro ao processar linha ${i}:`, err.message);
-          }
-        }
-      } else if (currentDate && line.match(/\d{2}:\d{2}/)) {
-        // Padr√£o 2: Linha sem pipes mas com hora (formato alternativo)
-        // Exemplo: "01:37 Dep√≥sito de vendas Vendas Dep√≥sito InfinitePay +12,60"
-        try {
-          const horaMatch = line.match(/(\d{2}:\d{2})/);
-          const valorMatch = line.match(/([+\-]?\s*R?\$?\s*\d+[.,]\d+)/);
+    res.json({ success: true, id, message: 'Membro da equipe criado com sucesso' });
+  } catch (error) {
+    console.error('‚ùå Erro ao criar membro da equipe:', error);
+    console.error('Detalhes do erro:', error.message);
+    console.error('SQL State:', error.sqlState);
+    console.error('Dados recebidos:', req.body);
+    res.status(500).json({
+      error: 'Erro interno do servidor',
+      message: error.message
+    });
+  }
+});
 
-          if (horaMatch && valorMatch) {
-            const hora = horaMatch[1];
-            let valorStr = valorMatch[1];
-            const partes = line.split(/\s+/);
+// PUT /api/sobre/team/:id - Atualizar membro da equipe
+app.put('/api/sobre/team/:id', async (req, res) => {
+  try {
+    const { id } = req.params;
+    const { name, position, description, image_url, order_index, is_active } = req.body;
 
-            // Remover hora e valor, o resto √© tipo/nome/detalhe
-            const resto = line.replace(/\d{2}:\d{2}/, '').replace(/([+\-]?\s*R?\$?\s*\d+[.,]\d+)/, '').trim();
+    await pool.execute(`
+      UPDATE team_members 
+      SET name = ?, position = ?, description = ?, image_url = ?, order_index = ?, is_active = ?
+      WHERE id = ?
+    `, [name, position, description, image_url, order_index || 0, is_active !== false, id]);
 
-            let valor = 0;
-            let isCredito = valorStr.includes('+');
-            const cleaned = valorStr.replace(/R\$/g, '').replace(/\s/g, '').replace(/[+\-]/, '').trim();
+    res.json({ success: true, message: 'Membro da equipe atualizado com sucesso' });
+  } catch (error) {
+    console.error('‚ùå Erro ao atualizar membro da equipe:', error);
+    res.status(500).json({ error: 'Erro interno do servidor' });
+  }
+});
 
-            if (cleaned.includes('.') && cleaned.includes(',')) {
-              valor = parseFloat(cleaned.replace(/\./g, '').replace(',', '.'));
-            } else if (cleaned.includes(',')) {
-              valor = parseFloat(cleaned.replace(',', '.'));
-            } else {
-              valor = parseFloat(cleaned);
-            }
+// DELETE /api/sobre/team/:id - Deletar membro da equipe
+app.delete('/api/sobre/team/:id', async (req, res) => {
+  try {
+    const { id } = req.params;
 
-            if (valor > 0 && currentDate) {
-              const dateParts = currentDate.split('/');
-              const formattedDate = `${dateParts[2]}-${dateParts[1].padStart(2, '0')}-${dateParts[0].padStart(2, '0')}`;
-
-              transactions.push({
-                data: formattedDate,
-                hora: hora,
-                descricao: resto.substring(0, 255) || 'Transa√ß√£o importada',
-                valor: Math.abs(valor),
-                tipo: isCredito ? 'credito' : 'debito'
-              });
-            }
-          }
-        } catch (err) {
-          console.warn(`Erro ao processar linha alternativa ${i}:`, err.message);
-        }
-      }
-    }
+    await pool.execute('DELETE FROM team_members WHERE id = ?', [id]);
 
-    console.log(`‚úÖ ${transactions.length} transa√ß√µes extra√≠das do PDF`);
+    res.json({ success: true, message: 'Membro da equipe deletado com sucesso' });
+  } catch (error) {
+    console.error('‚ùå Erro ao deletar membro da equipe:', error);
+    res.status(500).json({ error: 'Erro interno do servidor' });
+  }
+});
 
-    if (transactions.length === 0) {
-      // Limpar arquivo
-      if (fs.existsSync(req.file.path)) {
-        fs.unlinkSync(req.file.path);
-      }
+// GET /api/sobre/stats - Buscar estat√≠sticas da empresa
+app.get('/api/sobre/stats', async (req, res) => {
+  try {
+    const [rows] = await pool.execute(`
+      SELECT * FROM company_stats 
+      WHERE is_active = TRUE 
+      ORDER BY order_index ASC, created_at ASC
+    `);
+    res.json(rows);
+  } catch (error) {
+    console.error('‚ùå Erro ao buscar estat√≠sticas da empresa:', error);
+    res.status(500).json({ error: 'Erro interno do servidor' });
+  }
+});
 
-      // Verificar se o PDF √© escaneado (sem texto)
-      const isScanned = !pdfText || pdfText.trim().length < 100;
+// POST /api/sobre/stats - Criar nova estat√≠stica
+app.post('/api/sobre/stats', async (req, res) => {
+  try {
+    const { title, value, icon, order_index } = req.body;
+    const id = require('crypto').randomUUID();
 
-      if (isScanned) {
-        return res.status(400).json({
-          error: 'PDF escaneado detectado. Este PDF parece ser uma imagem e n√£o cont√©m texto extra√≠vel.',
-          suggestion: 'Por favor, exporte o relat√≥rio diretamente como CSV do InfinitePay ou use um PDF com texto selecion√°vel.'
-        });
-      } else {
-        return res.status(400).json({
-          error: 'Nenhuma transa√ß√£o encontrada no PDF. Verifique se √© um relat√≥rio v√°lido do InfinitePay.',
-          suggestion: 'Certifique-se de que o PDF cont√©m uma tabela com colunas: Data, Hora, Tipo, Nome, Detalhe, Valor'
-        });
-      }
-    }
+    await pool.execute(`
+      INSERT INTO company_stats (id, title, value, icon, order_index, is_active)
+      VALUES (?, ?, ?, ?, ?, TRUE)
+    `, [id, title, value, icon, order_index || 0]);
 
-    const contaId = req.body.conta_id ? parseInt(req.body.conta_id) : null;
-    let imported = 0;
-    let errors = [];
+    res.json({ success: true, id, message: 'Estat√≠stica criada com sucesso' });
+  } catch (error) {
+    console.error('‚ùå Erro ao criar estat√≠stica:', error);
+    res.status(500).json({ error: 'Erro interno do servidor' });
+  }
+});
 
-    // Inserir transa√ß√µes no banco
-    for (const trans of transactions) {
-      try {
-        // N√£o tratar como duplicata: vendas com mesmo valor/data/descri√ß√£o s√£o transa√ß√µes distintas.
-        // Todas as linhas do PDF s√£o importadas de forma fiel.
+// PUT /api/sobre/stats/:id - Atualizar estat√≠stica
+app.put('/api/sobre/stats/:id', async (req, res) => {
+  try {
+    const { id } = req.params;
+    const { title, value, icon, order_index, is_active } = req.body;
 
-        // Determinar tipo e status
-        const tipo = trans.tipo === 'credito' ? 'entrada' : 'saida';
-        const metodoPagamento = contaId
-          ? `Conta: ${contaId} (Importado do PDF InfinitePay)`
-          : 'Importado do PDF InfinitePay';
+    await pool.execute(`
+      UPDATE company_stats 
+      SET title = ?, value = ?, icon = ?, order_index = ?, is_active = ?
+      WHERE id = ?
+    `, [title, value, icon, order_index || 0, is_active !== false, id]);
 
-        // Inserir transa√ß√£o
-        await pool.execute(`
-          INSERT INTO financial_transactions 
-          (descricao, categoria, tipo, valor, status, data, origem, metodo_pagamento, observacoes, created_at, updated_at)
-          VALUES (?, ?, ?, ?, 'Pago', ?, 'Extrato Banc√°rio (PDF)', ?, ?, NOW(), NOW())
-        `, [
-          trans.descricao || 'Transa√ß√£o importada',
-          'Outros',
-          tipo,
-          trans.valor,
-          trans.data,
-          metodoPagamento,
-          `Importado automaticamente do PDF em ${new Date().toLocaleString('pt-BR')}`
-        ]);
-
-        imported++;
-      } catch (error) {
-        console.error('Erro ao importar transa√ß√£o:', error);
-        errors.push(`Erro ao importar: ${trans.descricao} - ${error.message}`);
-      }
-    }
+    res.json({ success: true, message: 'Estat√≠stica atualizada com sucesso' });
+  } catch (error) {
+    console.error('‚ùå Erro ao atualizar estat√≠stica:', error);
+    res.status(500).json({ error: 'Erro interno do servidor' });
+  }
+});
 
-    // Limpar arquivo tempor√°rio
-    if (fs.existsSync(req.file.path)) {
-      fs.unlinkSync(req.file.path);
-    }
+// DELETE /api/sobre/stats/:id - Deletar estat√≠stica
+app.delete('/api/sobre/stats/:id', async (req, res) => {
+  try {
+    const { id } = req.params;
 
-    logger.info('Extrato banc√°rio PDF importado', { imported, total: transactions.length, errors: errors.length });
+    await pool.execute('DELETE FROM company_stats WHERE id = ?', [id]);
 
-    res.json({
-      success: true,
-      imported,
-      total: transactions.length,
-      errors: errors.length > 0 ? errors.slice(0, 10) : [],
-      message: `${imported} transa√ß√µes importadas com sucesso do PDF${errors.length > 0 ? ` (${errors.length} erros)` : ''}`
-    });
+    res.json({ success: true, message: 'Estat√≠stica deletada com sucesso' });
   } catch (error) {
-    // Limpar arquivo em caso de erro
-    if (req.file && fs.existsSync(req.file.path)) {
-      fs.unlinkSync(req.file.path);
-    }
+    console.error('‚ùå Erro ao deletar estat√≠stica:', error);
+    res.status(500).json({ error: 'Erro interno do servidor' });
+  }
+});
 
-    logger.logError(error, req);
-    res.status(500).json({
-      error: 'Erro ao processar PDF',
-      details: error.message
-    });
+// GET /api/sobre/contact - Buscar informa√ß√µes de contato
+app.get('/api/sobre/contact', async (req, res) => {
+  try {
+    const [rows] = await pool.execute(`
+      SELECT * FROM contact_info 
+      WHERE is_active = TRUE 
+      ORDER BY order_index ASC, created_at ASC
+    `);
+    res.json(rows);
+  } catch (error) {
+    console.error('‚ùå Erro ao buscar informa√ß√µes de contato:', error);
+    res.status(500).json({ error: 'Erro interno do servidor' });
   }
 });
 
-// ==================== RECURRING TRANSACTIONS API ====================
-
-// Fun√ß√£o auxiliar para calcular pr√≥xima ocorr√™ncia
-function calculateNextOccurrence(lastDate, frequency, dayOfMonth = null, dayOfWeek = null) {
-  const date = new Date(lastDate);
-  const next = new Date(date);
-
-  switch (frequency) {
-    case 'daily':
-      next.setDate(next.getDate() + 1);
-      break;
-    case 'weekly':
-      next.setDate(next.getDate() + 7);
-      if (dayOfWeek !== null) {
-        const diff = dayOfWeek - next.getDay();
-        if (diff !== 0) {
-          next.setDate(next.getDate() + (diff > 0 ? diff : 7 + diff));
-        }
-      }
-      break;
-    case 'biweekly':
-      next.setDate(next.getDate() + 14);
-      break;
-    case 'monthly':
-      next.setMonth(next.getMonth() + 1);
-      if (dayOfMonth !== null) {
-        next.setDate(dayOfMonth);
-      }
-      break;
-    case 'quarterly':
-      next.setMonth(next.getMonth() + 3);
-      if (dayOfMonth !== null) {
-        next.setDate(dayOfMonth);
-      }
-      break;
-    case 'semiannual':
-      next.setMonth(next.getMonth() + 6);
-      if (dayOfMonth !== null) {
-        next.setDate(dayOfMonth);
-      }
-      break;
-    case 'yearly':
-      next.setFullYear(next.getFullYear() + 1);
-      if (dayOfMonth !== null) {
-        next.setDate(dayOfMonth);
-      }
-      break;
-  }
-
-  return next.toISOString().split('T')[0];
-}
-
-// Buscar todas as transa√ß√µes recorrentes
-app.get('/api/financial/recurring', authenticateAdmin, async (req, res) => {
-  // Obter conex√£o direta do pool (j√° configurada para rare_toy_companion)
-  const connection = await pool.getConnection();
-
+// POST /api/sobre/contact - Criar nova informa√ß√£o de contato
+app.post('/api/sobre/contact', async (req, res) => {
   try {
-    // Verificar qual banco est√° sendo usado
-    const [dbCheck] = await connection.query('SELECT DATABASE() as current_db');
-    logger.info('Banco atual da conex√£o:', dbCheck[0]);
-
-    // Verificar se a tabela existe e criar se n√£o existir
-    try {
-      const [tableCheck] = await connection.query(`
-        SELECT COUNT(*) as count 
-        FROM information_schema.tables 
-        WHERE table_schema = DATABASE() 
-        AND table_name = 'recurring_transactions'
-      `);
-
-      if (tableCheck[0].count === 0) {
-        logger.warn('Tabela recurring_transactions n√£o encontrada, criando...');
-        await connection.query(`
-          CREATE TABLE IF NOT EXISTS recurring_transactions (
-            id VARCHAR(36) PRIMARY KEY,
-            descricao VARCHAR(255) NOT NULL,
-            categoria VARCHAR(100) NOT NULL,
-            tipo ENUM('entrada', 'saida') NOT NULL,
-            valor DECIMAL(10,2) NOT NULL,
-            status ENUM('Pago', 'Pendente', 'Atrasado') DEFAULT 'Pendente',
-            metodo_pagamento VARCHAR(50) DEFAULT 'N√£o informado',
-            origem VARCHAR(255),
-            observacoes TEXT,
-            frequency ENUM('daily', 'weekly', 'biweekly', 'monthly', 'quarterly', 'semiannual', 'yearly') NOT NULL,
-            start_date DATE NOT NULL,
-            end_date DATE NULL,
-            next_occurrence DATE NOT NULL,
-            day_of_month INT NULL,
-            day_of_week INT NULL,
-            notify_days_before INT DEFAULT 0,
-            notify_email VARCHAR(255) NULL,
-            is_active BOOLEAN DEFAULT TRUE,
-            auto_create BOOLEAN DEFAULT TRUE,
-            occurrences_count INT DEFAULT 0,
-            max_occurrences INT NULL,
-            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
-            updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
-            created_by VARCHAR(255) NULL,
-            INDEX idx_tipo (tipo),
-            INDEX idx_status (status),
-            INDEX idx_frequency (frequency),
-            INDEX idx_next_occurrence (next_occurrence),
-            INDEX idx_is_active (is_active)
-          ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci
-        `);
-        logger.info('Tabela recurring_transactions criada com sucesso');
-      }
-    } catch (createError) {
-      logger.logError(createError, req);
-      // Continuar mesmo se houver erro na verifica√ß√£o
-    }
-
-    const { active_only } = req.query;
+    const { type, title, value, icon, order_index } = req.body;
+    const id = require('crypto').randomUUID();
 
-    let query = `
-      SELECT 
-        id, descricao, categoria, tipo, valor, status, metodo_pagamento,
-        origem, observacoes, frequency, start_date, end_date, next_occurrence,
-        day_of_month, day_of_week, notify_days_before, notify_email,
-        is_active, auto_create, occurrences_count, max_occurrences,
-        created_at, updated_at, created_by
-      FROM recurring_transactions
-    `;
+    await pool.execute(`
+      INSERT INTO contact_info (id, type, title, value, icon, order_index, is_active)
+      VALUES (?, ?, ?, ?, ?, ?, TRUE)
+    `, [id, type, title, value, icon, order_index || 0]);
 
-    const params = [];
-    if (active_only === 'true') {
-      query += ' WHERE is_active = TRUE';
-    }
+    res.json({ success: true, id, message: 'Informa√ß√£o de contato criada com sucesso' });
+  } catch (error) {
+    console.error('‚ùå Erro ao criar informa√ß√£o de contato:', error);
+    res.status(500).json({ error: 'Erro interno do servidor' });
+  }
+});
 
-    query += ' ORDER BY next_occurrence ASC, created_at DESC';
+// PUT /api/sobre/contact/:id - Atualizar informa√ß√£o de contato
+app.put('/api/sobre/contact/:id', async (req, res) => {
+  try {
+    const { id } = req.params;
+    const { type, title, value, icon, order_index, is_active } = req.body;
 
-    const [rows] = await connection.execute(query, params);
+    await pool.execute(`
+      UPDATE contact_info 
+      SET type = ?, title = ?, value = ?, icon = ?, order_index = ?, is_active = ?
+      WHERE id = ?
+    `, [type, title, value, icon, order_index || 0, is_active !== false, id]);
 
-    logger.info('Transa√ß√µes recorrentes carregadas', { count: rows.length });
-    res.json({ recurring_transactions: rows, total: rows.length });
+    res.json({ success: true, message: 'Informa√ß√£o de contato atualizada com sucesso' });
   } catch (error) {
-    logger.logError(error, req);
-    res.status(500).json({ error: 'Erro ao buscar transa√ß√µes recorrentes', details: error.message });
-  } finally {
-    connection.release();
+    console.error('‚ùå Erro ao atualizar informa√ß√£o de contato:', error);
+    res.status(500).json({ error: 'Erro interno do servidor' });
   }
 });
 
-// Buscar transa√ß√£o recorrente por ID
-app.get('/api/financial/recurring/:id', authenticateAdmin, async (req, res) => {
-  // Obter conex√£o direta do pool (j√° configurada para rare_toy_companion)
-  const connection = await pool.getConnection();
-
+// DELETE /api/sobre/contact/:id - Deletar informa√ß√£o de contato
+app.delete('/api/sobre/contact/:id', async (req, res) => {
   try {
-    // Garantir que estamos usando o banco correto (com query, n√£o execute)
-    await connection.query('USE `rare_toy_companion`');
-
     const { id } = req.params;
-    const [rows] = await connection.execute(
-      'SELECT * FROM recurring_transactions WHERE id = ?',
-      [id]
-    );
 
-    if (rows.length === 0) {
-      return res.status(404).json({ error: 'Transa√ß√£o recorrente n√£o encontrada' });
-    }
+    await pool.execute('DELETE FROM contact_info WHERE id = ?', [id]);
 
-    res.json({ recurring_transaction: rows[0] });
+    res.json({ success: true, message: 'Informa√ß√£o de contato deletada com sucesso' });
   } catch (error) {
-    logger.logError(error, req);
-    res.status(500).json({ error: 'Erro ao buscar transa√ß√£o recorrente' });
-  } finally {
-    connection.release();
+    console.error('‚ùå Erro ao deletar informa√ß√£o de contato:', error);
+    res.status(500).json({ error: 'Erro interno do servidor' });
   }
 });
 
-// Criar transa√ß√£o recorrente
-app.post('/api/financial/recurring', authenticateAdmin, async (req, res) => {
-  // Obter conex√£o direta do pool (j√° configurada para rare_toy_companion)
-  const connection = await pool.getConnection();
+// ===== UPLOAD DE IMAGENS PARA P√ÅGINA SOBRE =====
 
+// Upload de imagem geral para p√°gina sobre
+app.post('/api/sobre/upload-image', upload.single('image'), async (req, res) => {
   try {
-    // Verificar qual banco est√° sendo usado
-    const [dbCheck] = await connection.query('SELECT DATABASE() as current_db');
-    logger.info('Banco atual da conex√£o (POST):', dbCheck[0]);
-
-    // Verificar se a tabela existe e criar se n√£o existir
-    try {
-      const [tableCheck] = await connection.query(`
-        SELECT COUNT(*) as count 
-        FROM information_schema.tables 
-        WHERE table_schema = DATABASE() 
-        AND table_name = 'recurring_transactions'
-      `);
-
-      if (tableCheck[0].count === 0) {
-        logger.warn('Tabela recurring_transactions n√£o encontrada, criando...');
-        await connection.query(`
-          CREATE TABLE IF NOT EXISTS recurring_transactions (
-            id VARCHAR(36) PRIMARY KEY,
-            descricao VARCHAR(255) NOT NULL,
-            categoria VARCHAR(100) NOT NULL,
-            tipo ENUM('entrada', 'saida') NOT NULL,
-            valor DECIMAL(10,2) NOT NULL,
-            status ENUM('Pago', 'Pendente', 'Atrasado') DEFAULT 'Pendente',
-            metodo_pagamento VARCHAR(50) DEFAULT 'N√£o informado',
-            origem VARCHAR(255),
-            observacoes TEXT,
-            frequency ENUM('daily', 'weekly', 'biweekly', 'monthly', 'quarterly', 'semiannual', 'yearly') NOT NULL,
-            start_date DATE NOT NULL,
-            end_date DATE NULL,
-            next_occurrence DATE NOT NULL,
-            day_of_month INT NULL,
-            day_of_week INT NULL,
-            notify_days_before INT DEFAULT 0,
-            notify_email VARCHAR(255) NULL,
-            is_active BOOLEAN DEFAULT TRUE,
-            auto_create BOOLEAN DEFAULT TRUE,
-            occurrences_count INT DEFAULT 0,
-            max_occurrences INT NULL,
-            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
-            updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
-            created_by VARCHAR(255) NULL,
-            INDEX idx_tipo (tipo),
-            INDEX idx_status (status),
-            INDEX idx_frequency (frequency),
-            INDEX idx_next_occurrence (next_occurrence),
-            INDEX idx_is_active (is_active)
-          ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci
-        `);
-        logger.info('Tabela recurring_transactions criada com sucesso');
-      }
-    } catch (createError) {
-      logger.logError(createError, req);
-      // Continuar mesmo se houver erro na verifica√ß√£o
+    if (!req.file) {
+      return res.status(400).json({ error: 'Nenhuma imagem foi enviada' });
     }
 
-    const {
-      descricao, categoria, tipo, valor, status, metodo_pagamento,
-      origem, observacoes, frequency, start_date, end_date,
-      day_of_month, day_of_week, notify_days_before, notify_email,
-      auto_create, max_occurrences
-    } = req.body;
+    const imageUrl = `/lovable-uploads/${req.file.filename}`;
+    const fullUrl = getPublicUrl(req, imageUrl);
 
-    // Valida√ß√µes b√°sicas
-    if (!descricao || !categoria || !tipo || !valor || !frequency || !start_date) {
-      connection.release();
-      return res.status(400).json({
-        error: 'Campos obrigat√≥rios: descricao, categoria, tipo, valor, frequency, start_date'
-      });
-    }
+    console.log(`‚úÖ Imagem da p√°gina sobre enviada: ${req.file.filename}`);
 
-    if (valor <= 0) {
-      connection.release();
-      return res.status(400).json({ error: 'Valor deve ser maior que zero' });
-    }
+    res.json({
+      success: true,
+      imageUrl: imageUrl,
+      fullUrl: fullUrl,
+      filename: req.file.filename
+    });
+  } catch (error) {
+    console.error('‚ùå Erro no upload de imagem da p√°gina sobre:', error);
+    res.status(500).json({ error: 'Erro interno do servidor' });
+  }
+});
 
-    const tipoNormalizado = tipo.toLowerCase();
-    if (!['entrada', 'saida'].includes(tipoNormalizado)) {
-      connection.release();
-      return res.status(400).json({ error: 'Tipo deve ser "entrada" ou "saida"' });
-    }
+// Upload de imagem para membro da equipe
+app.post('/api/sobre/team/:id/image', upload.single('image'), async (req, res) => {
+  try {
+    const { id } = req.params;
+    if (!req.file) return res.status(400).json({ error: 'Nenhuma imagem foi enviada' });
 
-    const frequencies = ['daily', 'weekly', 'biweekly', 'monthly', 'quarterly', 'semiannual', 'yearly'];
-    if (!frequencies.includes(frequency)) {
-      connection.release();
-      return res.status(400).json({ error: 'Frequ√™ncia inv√°lida' });
-    }
+    const imageUrl = `/lovable-uploads/${req.file.filename}`;
+    const fullUrl = getPublicUrl(req, imageUrl);
 
-    // Calcular pr√≥xima ocorr√™ncia
-    const nextOccurrence = calculateNextOccurrence(
-      start_date,
-      frequency,
-      day_of_month,
-      day_of_week
+    // Atualizar o registro do membro da equipe
+    await pool.execute(
+      'UPDATE team_members SET image_url = ? WHERE id = ?',
+      [fullUrl, id]
     );
 
-    const id = crypto.randomUUID();
-    const safeStatus = status || 'Pendente';
-    const safeMetodoPagamento = metodo_pagamento || 'N√£o informado';
-    const safeNotifyDays = notify_days_before !== undefined ? notify_days_before : 0;
-
-    // Inserir transa√ß√£o recorrente
-    await connection.execute(`
-      INSERT INTO recurring_transactions (
-        id, descricao, categoria, tipo, valor, status, metodo_pagamento,
-        origem, observacoes, frequency, start_date, end_date, next_occurrence,
-        day_of_month, day_of_week, notify_days_before, notify_email,
-        is_active, auto_create, max_occurrences, created_by
-      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
-    `, [
-      id, descricao, categoria, tipoNormalizado, valor, safeStatus, safeMetodoPagamento,
-      origem || null, observacoes || null, frequency, start_date, end_date || null, nextOccurrence,
-      day_of_month || null, day_of_week || null, safeNotifyDays, notify_email || null,
-      true, auto_create !== false, max_occurrences || null, req.user?.email || null
-    ]);
+    console.log(`‚úÖ Imagem do membro da equipe ${id} atualizada: ${req.file.filename}`);
 
-    logger.info('Transa√ß√£o recorrente criada', { id });
     res.json({
       success: true,
-      message: 'Transa√ß√£o recorrente criada com sucesso',
-      recurring_transaction: {
-        id, descricao, categoria, tipo: tipoNormalizado, valor, status: safeStatus,
-        frequency, start_date, next_occurrence: nextOccurrence, is_active: true
-      }
+      imageUrl: imageUrl,
+      fullUrl: fullUrl,
+      filename: req.file.filename
     });
   } catch (error) {
-    logger.logError(error, req);
-    res.status(500).json({ error: 'Erro ao criar transa√ß√£o recorrente', details: error.message });
-  } finally {
-    connection.release();
+    console.error('‚ùå Erro no upload de imagem do membro da equipe:', error);
+    res.status(500).json({ error: 'Erro interno do servidor' });
   }
 });
 
-// Atualizar transa√ß√£o recorrente
-app.put('/api/financial/recurring/:id', authenticateAdmin, async (req, res) => {
-  // Obter conex√£o direta do pool (j√° configurada para rare_toy_companion)
-  const connection = await pool.getConnection();
 
+// Sitemap.xml din√¢mico
+const { generateSitemap } = require('../config/sitemapGenerator.cjs');
+
+app.get('/sitemap.xml', async (req, res) => {
   try {
-    // Garantir que estamos usando o banco correto (com query, n√£o execute)
-    await connection.query('USE `rare_toy_companion`');
+    const sitemapXml = await generateSitemap(pool);
+    res.header('Content-Type', 'application/xml');
+    res.header('Cache-Control', 'public, max-age=86400'); // Cache de 24 horas
+    res.send(sitemapXml);
+    logger.info('Sitemap gerado com sucesso');
+  } catch (error) {
+    logger.error('Erro ao gerar sitemap:', error);
+    res.status(500).send('<?xml version="1.0" encoding="UTF-8"?><urlset xmlns="http://www.sitemaps.org/schemas/sitemap/0.9"></urlset>');
+  }
+});
 
-    const { id } = req.params;
-    const {
-      descricao, categoria, tipo, valor, status, metodo_pagamento,
-      origem, observacoes, frequency, start_date, end_date,
-      day_of_month, day_of_week, notify_days_before, notify_email,
-      is_active, auto_create, max_occurrences
-    } = req.body;
+// ==================== PUSH NOTIFICATIONS API ====================
 
-    // Verificar se existe
-    const [existing] = await connection.execute(
-      'SELECT * FROM recurring_transactions WHERE id = ?',
-      [id]
-    );
+// Obter VAPID public key
+app.get('/api/push/vapid-public-key', (req, res) => {
+  const publicKey = pushNotifications.getPublicKey();
+  if (!publicKey) {
+    return res.status(503).json({ error: 'Push notifications n√£o configuradas' });
+  }
+  res.json({ publicKey });
+});
 
-    if (existing.length === 0) {
-      connection.release();
-      return res.status(404).json({ error: 'Transa√ß√£o recorrente n√£o encontrada' });
-    }
+// Inscrever em push notifications
+app.post('/api/push/subscribe', async (req, res) => {
+  try {
+    const { subscription } = req.body;
+    const userId = req.cookies?.user_id || null; // Ajustar conforme seu sistema de auth
+    const id = crypto.randomUUID();
 
-    const current = existing[0];
+    // Extrair keys da subscription
+    const endpoint = subscription.endpoint;
+    const p256dhKey = subscription.keys.p256dh;
+    const authKey = subscription.keys.auth;
 
-    // Se mudou data inicial ou frequ√™ncia, recalcular pr√≥xima ocorr√™ncia
-    let nextOccurrence = current.next_occurrence;
-    if (start_date !== current.start_date || frequency !== current.frequency ||
-      day_of_month !== current.day_of_month || day_of_week !== current.day_of_week) {
-      nextOccurrence = calculateNextOccurrence(
-        start_date || current.start_date,
-        frequency || current.frequency,
-        day_of_month !== undefined ? day_of_month : current.day_of_month,
-        day_of_week !== undefined ? day_of_week : current.day_of_week
-      );
-    }
+    // Detectar tipo de device
+    const userAgent = req.headers['user-agent'] || '';
+    let deviceType = 'desktop';
+    if (/mobile/i.test(userAgent)) deviceType = 'mobile';
+    if (/tablet|ipad/i.test(userAgent)) deviceType = 'tablet';
 
-    const tipoNormalizado = tipo ? tipo.toLowerCase() : current.tipo;
-
-    await connection.execute(`
-      UPDATE recurring_transactions 
-      SET descricao = COALESCE(?, descricao),
-          categoria = COALESCE(?, categoria),
-          tipo = COALESCE(?, tipo),
-          valor = COALESCE(?, valor),
-          status = COALESCE(?, status),
-          metodo_pagamento = COALESCE(?, metodo_pagamento),
-          origem = COALESCE(?, origem),
-          observacoes = COALESCE(?, observacoes),
-          frequency = COALESCE(?, frequency),
-          start_date = COALESCE(?, start_date),
-          end_date = ?,
-          next_occurrence = ?,
-          day_of_month = COALESCE(?, day_of_month),
-          day_of_week = COALESCE(?, day_of_week),
-          notify_days_before = COALESCE(?, notify_days_before),
-          notify_email = COALESCE(?, notify_email),
-          is_active = COALESCE(?, is_active),
-          auto_create = COALESCE(?, auto_create),
-          max_occurrences = COALESCE(?, max_occurrences),
-          updated_at = NOW()
-      WHERE id = ?
-    `, [
-      descricao, categoria, tipoNormalizado, valor, status, metodo_pagamento,
-      origem, observacoes, frequency, start_date, end_date, nextOccurrence,
-      day_of_month, day_of_week, notify_days_before, notify_email,
-      is_active, auto_create, max_occurrences, id
-    ]);
+    // Salvar no banco
+    await pool.execute(`
+      INSERT INTO push_subscriptions (id, user_id, endpoint, p256dh_key, auth_key, user_agent, device_type)
+      VALUES (?, ?, ?, ?, ?, ?, ?)
+      ON DUPLICATE KEY UPDATE 
+        p256dh_key = VALUES(p256dh_key),
+        auth_key = VALUES(auth_key),
+        is_active = TRUE,
+        updated_at = NOW()
+    `, [id, userId, endpoint, p256dhKey, authKey, userAgent, deviceType]);
 
-    logger.info('Transa√ß√£o recorrente atualizada', { id });
-    res.json({ success: true, message: 'Transa√ß√£o recorrente atualizada com sucesso' });
+    logger.info('Push subscription salva', { userId, deviceType });
+    res.json({ success: true, id });
   } catch (error) {
     logger.logError(error, req);
-    res.status(500).json({ error: 'Erro ao atualizar transa√ß√£o recorrente', details: error.message });
-  } finally {
-    if (connection) connection.release();
+    res.status(500).json({ error: 'Erro ao salvar subscription' });
   }
 });
 
-// Excluir transa√ß√£o recorrente
-app.delete('/api/financial/recurring/:id', authenticateAdmin, async (req, res) => {
-  // Obter conex√£o direta do pool (j√° configurada para rare_toy_companion)
-  const connection = await pool.getConnection();
-
+// Desinscrever
+app.post('/api/push/unsubscribe', async (req, res) => {
   try {
-    // Garantir que estamos usando o banco correto (com query, n√£o execute)
-    await connection.query('USE `rare_toy_companion`');
-
-    const { id } = req.params;
+    const { endpoint } = req.body;
 
-    const [result] = await connection.execute(
-      'DELETE FROM recurring_transactions WHERE id = ?',
-      [id]
+    await pool.execute(
+      'UPDATE push_subscriptions SET is_active = FALSE WHERE endpoint = ?',
+      [endpoint]
     );
 
-    if (result.affectedRows === 0) {
-      connection.release();
-      return res.status(404).json({ error: 'Transa√ß√£o recorrente n√£o encontrada' });
-    }
-
-    logger.info('Transa√ß√£o recorrente exclu√≠da', { id });
-    res.json({ success: true, message: 'Transa√ß√£o recorrente exclu√≠da com sucesso' });
+    logger.info('Push subscription desativada', { endpoint: endpoint.substring(0, 50) });
+    res.json({ success: true });
   } catch (error) {
     logger.logError(error, req);
-    res.status(500).json({ error: 'Erro ao excluir transa√ß√£o recorrente' });
-  } finally {
-    if (connection) connection.release();
+    res.status(500).json({ error: 'Erro ao desinscrever' });
   }
 });
 
-// Processar recorr√™ncias (executar transa√ß√µes pendentes)
-app.post('/api/financial/recurring/process', authenticateAdmin, async (req, res) => {
-  // Obter conex√£o direta do pool (j√° configurada para rare_toy_companion)
-  const connection = await pool.getConnection();
-
+// Enviar notifica√ß√£o de teste
+app.post('/api/push/test', async (req, res) => {
   try {
-    // Garantir que estamos usando o banco correto (com query, n√£o execute)
-    await connection.query('USE `rare_toy_companion`');
-
-    const today = new Date().toISOString().split('T')[0];
-
-    // Buscar recorr√™ncias ativas com pr√≥xima ocorr√™ncia hoje ou antes
-    const [recurring] = await connection.execute(`
-      SELECT * FROM recurring_transactions
-      WHERE is_active = TRUE
-        AND auto_create = TRUE
-        AND next_occurrence <= ?
-        AND (end_date IS NULL OR next_occurrence <= end_date)
-        AND (max_occurrences IS NULL OR occurrences_count < max_occurrences)
-      ORDER BY next_occurrence ASC
-    `, [today]);
-
-    const processed = [];
-    const errors = [];
-
-    for (const rec of recurring) {
-      try {
-        // Criar transa√ß√£o financeira
-        const [result] = await connection.execute(`
-          INSERT INTO financial_transactions (
-            descricao, categoria, tipo, valor, status, 
-            metodo_pagamento, data, origem, observacoes
-          ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
-        `, [
-          rec.descricao, rec.categoria, rec.tipo, rec.valor, rec.status,
-          rec.metodo_pagamento, rec.next_occurrence, rec.origem, rec.observacoes
-        ]);
-
-        const transactionId = result.insertId;
-
-        // Registrar ocorr√™ncia
-        await connection.execute(`
-          INSERT INTO recurring_transaction_occurrences (
-            id, recurring_transaction_id, financial_transaction_id,
-            scheduled_date, created_at, status
-          ) VALUES (?, ?, ?, ?, NOW(), 'created')
-        `, [crypto.randomUUID(), rec.id, transactionId, rec.next_occurrence]);
-
-        // Calcular pr√≥xima ocorr√™ncia
-        const nextOccurrence = calculateNextOccurrence(
-          rec.next_occurrence,
-          rec.frequency,
-          rec.day_of_month,
-          rec.day_of_week
-        );
+    const { userId } = req.body;
 
-        // Atualizar recorr√™ncia
-        await connection.execute(`
-          UPDATE recurring_transactions
-          SET next_occurrence = ?,
-              occurrences_count = occurrences_count + 1,
-              updated_at = NOW()
-          WHERE id = ?
-        `, [nextOccurrence, rec.id]);
-
-        processed.push({
-          recurring_id: rec.id,
-          transaction_id: transactionId,
-          date: rec.next_occurrence
-        });
+    // Buscar subscription do usu√°rio
+    const [subs] = await pool.execute(
+      'SELECT endpoint, p256dh_key, auth_key FROM push_subscriptions WHERE user_id = ? AND is_active = TRUE LIMIT 1',
+      [userId]
+    );
 
-        logger.info('Transa√ß√£o recorrente processada', {
-          recurring_id: rec.id,
-          transaction_id: transactionId
-        });
-      } catch (error) {
-        errors.push({
-          recurring_id: rec.id,
-          error: error.message
-        });
-        logger.logError(error, req);
-      }
+    if (subs.length === 0) {
+      return res.status(404).json({ error: 'Nenhuma subscription ativa encontrada' });
     }
 
-    res.json({
-      success: true,
-      processed: processed.length,
-      errors: errors.length,
-      details: { processed, errors }
-    });
-  } catch (error) {
-    logger.logError(error, req);
-    res.status(500).json({ error: 'Erro ao processar recorr√™ncias', details: error.message });
-  } finally {
-    if (connection) connection.release();
-  }
-});
-
-// Processar notifica√ß√µes de recorr√™ncias pr√≥ximas
-app.post('/api/financial/recurring/notify', authenticateAdmin, async (req, res) => {
-  const { notifyRecurringTransactions } = require('../scripts/notify-recurring-transactions.cjs');
-  const { initializeEmailService } = require('../config/emailService.cjs');
+    const sub = subs[0];
+    const subscription = {
+      endpoint: sub.endpoint,
+      keys: {
+        p256dh: sub.p256dh_key,
+        auth: sub.auth_key,
+      },
+    };
 
-  try {
-    // Inicializar servi√ßo de email se necess√°rio
-    initializeEmailService();
+    const payload = {
+      title: 'MuhlStore - Notifica√ß√£o de Teste! üéâ',
+      body: 'Suas notifica√ß√µes est√£o funcionando perfeitamente!',
+      icon: '/icon-192x192.png',
+      badge: '/icon-72x72.png',
+      data: { url: '/' },
+    };
 
-    // Processar notifica√ß√µes
-    await notifyRecurringTransactions();
+    const result = await pushNotifications.sendNotification(subscription, payload);
 
-    res.json({
-      success: true,
-      message: 'Notifica√ß√µes processadas com sucesso'
-    });
+    if (result.success) {
+      res.json({ success: true, message: 'Notifica√ß√£o de teste enviada!' });
+    } else {
+      res.status(500).json({ success: false, error: result.error });
+    }
   } catch (error) {
     logger.logError(error, req);
-    res.status(500).json({
-      error: 'Erro ao processar notifica√ß√µes',
-      details: error.message
-    });
+    res.status(500).json({ error: 'Erro ao enviar notifica√ß√£o de teste' });
   }
 });
 
-// Buscar ocorr√™ncias de uma recorr√™ncia
-app.get('/api/financial/recurring/:id/occurrences', authenticateAdmin, async (req, res) => {
-  // Obter conex√£o direta do pool (j√° configurada para rare_toy_companion)
-  const connection = await pool.getConnection();
-
+// Enviar notifica√ß√£o em massa (campanhas)
+app.post('/api/push/campaign', async (req, res) => {
   try {
-    // Garantir que estamos usando o banco correto (com query, n√£o execute)
-    await connection.query('USE `rare_toy_companion`');
+    const { title, body, targetAudience, targetUrl } = req.body;
 
-    const { id } = req.params;
-    const [rows] = await connection.execute(`
-      SELECT o.*, t.data as transaction_date, t.status as transaction_status
-      FROM recurring_transaction_occurrences o
-      LEFT JOIN financial_transactions t ON o.financial_transaction_id = t.id
-      WHERE o.recurring_transaction_id = ?
-      ORDER BY o.scheduled_date DESC
-      LIMIT 50
-    `, [id]);
+    // Buscar subscriptions ativas
+    let query = 'SELECT id, endpoint, p256dh_key, auth_key FROM push_subscriptions WHERE is_active = TRUE';
 
-    res.json({ occurrences: rows });
-  } catch (error) {
-    logger.logError(error, req);
-    res.status(500).json({ error: 'Erro ao buscar ocorr√™ncias' });
-  } finally {
-    connection.release();
-  }
-});
+    if (targetAudience === 'mobile') {
+      query += " AND device_type = 'mobile'";
+    } else if (targetAudience === 'desktop') {
+      query += " AND device_type = 'desktop'";
+    }
 
-// ==================== RELAT√ìRIOS EXECUTIVOS ====================
+    const [subs] = await pool.execute(query);
 
-// Relat√≥rio P&L (Profit & Loss)
-app.get('/api/financial/reports/pl', authenticateAdmin, async (req, res) => {
-  const connection = await pool.getConnection();
+    if (subs.length === 0) {
+      return res.status(404).json({ error: 'Nenhuma subscription ativa' });
+    }
 
-  try {
-    await connection.query('USE `rare_toy_companion`');
+    const subscriptions = subs.map(s => ({
+      endpoint: s.endpoint,
+      keys: {
+        p256dh: s.p256dh_key,
+        auth: s.auth_key,
+      },
+    }));
 
-    const { start_date, end_date } = req.query;
-    const startDate = start_date || new Date(new Date().getFullYear(), 0, 1).toISOString().split('T')[0];
-    const endDate = end_date || new Date().toISOString().split('T')[0];
+    const payload = {
+      title,
+      body,
+      icon: '/icon-192x192.png',
+      badge: '/icon-72x72.png',
+      data: { url: targetUrl || '/' },
+    };
 
-    // Receitas (entradas)
-    const [receitas] = await connection.execute(`
-      SELECT 
-        categoria,
-        SUM(valor) as total,
-        COUNT(*) as quantidade
-      FROM financial_transactions
-      WHERE tipo = 'entrada'
-        AND data BETWEEN ? AND ?
-        AND status = 'Pago'
-      GROUP BY categoria
-      ORDER BY total DESC
-    `, [startDate, endDate]);
-
-    // Despesas (sa√≠das)
-    const [despesas] = await connection.execute(`
-      SELECT 
-        categoria,
-        SUM(valor) as total,
-        COUNT(*) as quantidade
-      FROM financial_transactions
-      WHERE tipo = 'saida'
-        AND data BETWEEN ? AND ?
-        AND status = 'Pago'
-      GROUP BY categoria
-      ORDER BY total DESC
-    `, [startDate, endDate]);
-
-    // Totais
-    const [totais] = await connection.execute(`
-      SELECT 
-        COALESCE(SUM(CASE WHEN tipo = 'entrada' AND status = 'Pago' THEN valor ELSE 0 END), 0) as total_receitas,
-        COALESCE(SUM(CASE WHEN tipo = 'saida' AND status = 'Pago' THEN valor ELSE 0 END), 0) as total_despesas,
-        COALESCE(SUM(CASE WHEN tipo = 'entrada' AND status = 'Pago' THEN valor ELSE 0 END), 0) - 
-        COALESCE(SUM(CASE WHEN tipo = 'saida' AND status = 'Pago' THEN valor ELSE 0 END), 0) as lucro_liquido
-      FROM financial_transactions
-      WHERE data BETWEEN ? AND ?
-    `, [startDate, endDate]);
+    const result = await pushNotifications.sendToMultiple(subscriptions, payload);
 
-    res.json({
-      periodo: { start_date: startDate, end_date: endDate },
-      receitas: receitas.map(r => ({ ...r, total: parseFloat(r.total) })),
-      despesas: despesas.map(d => ({ ...d, total: parseFloat(d.total) })),
-      totais: {
-        total_receitas: parseFloat(totais[0].total_receitas),
-        total_despesas: parseFloat(totais[0].total_despesas),
-        lucro_liquido: parseFloat(totais[0].lucro_liquido),
-        margem_lucro: totais[0].total_receitas > 0
-          ? ((totais[0].lucro_liquido / totais[0].total_receitas) * 100).toFixed(2)
-          : 0
-      }
-    });
+    logger.info('Campanha de push enviada', result);
+    res.json({ success: true, ...result });
   } catch (error) {
     logger.logError(error, req);
-    res.status(500).json({ error: 'Erro ao gerar relat√≥rio P&L', details: error.message });
-  } finally {
-    connection.release();
+    res.status(500).json({ error: 'Erro ao enviar campanha' });
   }
 });
 
-// Relat√≥rio DRE (Demonstra√ß√£o do Resultado do Exerc√≠cio)
-app.get('/api/financial/reports/dre', authenticateAdmin, async (req, res) => {
-  const connection = await pool.getConnection();
+// ==================== CUSTOMERS API (COMPLETO E AVAN√áADO) ====================
 
+// Estat√≠sticas do usu√°rio logado (current user stats)
+app.get('/api/customers/current/stats', async (req, res) => {
   try {
-    await connection.query('USE `rare_toy_companion`');
-
-    const { start_date, end_date } = req.query;
-    const startDate = start_date || new Date(new Date().getFullYear(), 0, 1).toISOString().split('T')[0];
-    const endDate = end_date || new Date().toISOString().split('T')[0];
-
-    // Receita Bruta
-    const [receitaBruta] = await connection.execute(`
-      SELECT COALESCE(SUM(valor), 0) as total
-      FROM financial_transactions
-      WHERE tipo = 'entrada'
-        AND data BETWEEN ? AND ?
-        AND status = 'Pago'
-    `, [startDate, endDate]);
-
-    // Dedu√ß√µes (impostos, devolu√ß√µes, etc) - categorias espec√≠ficas
-    const [deducoes] = await connection.execute(`
-      SELECT COALESCE(SUM(valor), 0) as total
-      FROM financial_transactions
-      WHERE tipo = 'saida'
-        AND categoria IN ('Impostos', 'Devolu√ß√µes', 'Cancelamentos')
-        AND data BETWEEN ? AND ?
-        AND status = 'Pago'
-    `, [startDate, endDate]);
-
-    // Receita L√≠quida
-    const receitaLiquida = parseFloat(receitaBruta[0].total) - parseFloat(deducoes[0].total);
-
-    // CMV (Custo das Mercadorias Vendidas)
-    const [cmv] = await connection.execute(`
-      SELECT COALESCE(SUM(valor), 0) as total
-      FROM financial_transactions
-      WHERE tipo = 'saida'
-        AND categoria IN ('Custo de Mercadorias', 'Compras', 'Estoque')
-        AND data BETWEEN ? AND ?
-        AND status = 'Pago'
-    `, [startDate, endDate]);
-
-    // Lucro Bruto
-    const lucroBruto = receitaLiquida - parseFloat(cmv[0].total);
-
-    // Despesas Operacionais
-    const [despesasOperacionais] = await connection.execute(`
-      SELECT 
-        categoria,
-        COALESCE(SUM(valor), 0) as total
-      FROM financial_transactions
-      WHERE tipo = 'saida'
-        AND categoria NOT IN ('Custo de Mercadorias', 'Compras', 'Estoque', 'Impostos', 'Devolu√ß√µes', 'Cancelamentos')
-        AND data BETWEEN ? AND ?
-        AND status = 'Pago'
-      GROUP BY categoria
-    `, [startDate, endDate]);
-
-    const totalDespesasOperacionais = despesasOperacionais.reduce((sum, d) => sum + parseFloat(d.total), 0);
-
-    // Lucro Operacional
-    const lucroOperacional = lucroBruto - totalDespesasOperacionais;
-
-    // Receitas/Despesas N√£o Operacionais
-    const [naoOperacionais] = await connection.execute(`
-      SELECT 
-        tipo,
-        COALESCE(SUM(CASE WHEN tipo = 'entrada' THEN valor ELSE 0 END), 0) as receitas_nao_operacionais,
-        COALESCE(SUM(CASE WHEN tipo = 'saida' THEN valor ELSE 0 END), 0) as despesas_nao_operacionais
-      FROM financial_transactions
-      WHERE categoria IN ('Juros', 'Rendimentos', 'Multas', 'Descontos Financeiros')
-        AND data BETWEEN ? AND ?
-        AND status = 'Pago'
-    `, [startDate, endDate]);
-
-    const receitasNaoOp = parseFloat(naoOperacionais[0]?.receitas_nao_operacionais || 0);
-    const despesasNaoOp = parseFloat(naoOperacionais[0]?.despesas_nao_operacionais || 0);
-
-    // Lucro Antes do IR
-    const lucroAntesIR = lucroOperacional + receitasNaoOp - despesasNaoOp;
-
-    // IR e CSLL (simulado - pode ser configur√°vel)
-    const aliquotaIR = 0.15; // 15%
-    const aliquotaCSLL = 0.09; // 9%
-    const ir = lucroAntesIR > 0 ? lucroAntesIR * aliquotaIR : 0;
-    const csll = lucroAntesIR > 0 ? lucroAntesIR * aliquotaCSLL : 0;
-
-    // Lucro L√≠quido
-    const lucroLiquido = lucroAntesIR - ir - csll;
+    console.log('üìä GET /api/customers/current/stats');
 
-    res.json({
-      periodo: { start_date: startDate, end_date: endDate },
-      receita_bruta: parseFloat(receitaBruta[0].total),
-      deducoes: parseFloat(deducoes[0].total),
-      receita_liquida: receitaLiquida,
-      cmv: parseFloat(cmv[0].total),
-      lucro_bruto: lucroBruto,
-      despesas_operacionais: {
-        detalhado: despesasOperacionais.map(d => ({ categoria: d.categoria, total: parseFloat(d.total) })),
-        total: totalDespesasOperacionais
-      },
-      lucro_operacional: lucroOperacional,
-      resultado_nao_operacional: {
-        receitas: receitasNaoOp,
-        despesas: despesasNaoOp,
-        resultado: receitasNaoOp - despesasNaoOp
-      },
-      lucro_antes_ir: lucroAntesIR,
-      impostos: {
-        ir: ir,
-        csll: csll,
-        total: ir + csll
-      },
-      lucro_liquido: lucroLiquido,
-      indicadores: {
-        margem_bruta: receitaLiquida > 0 ? ((lucroBruto / receitaLiquida) * 100).toFixed(2) : 0,
-        margem_operacional: receitaLiquida > 0 ? ((lucroOperacional / receitaLiquida) * 100).toFixed(2) : 0,
-        margem_liquida: receitaLiquida > 0 ? ((lucroLiquido / receitaLiquida) * 100).toFixed(2) : 0
+    // Tentar obter o usu√°rio da sess√£o
+    let userId = null;
+    let userEmail = null;
+
+    // 1. Tentar via session_id
+    const sessionId = req.cookies?.session_id;
+    if (sessionId) {
+      try {
+        const [sessions] = await pool.execute('SELECT * FROM sessions WHERE id = ?', [sessionId]);
+        if (sessions && sessions[0]) {
+          userId = sessions[0].user_id;
+        }
+      } catch (e) {
+        console.log('‚ö†Ô∏è Erro ao verificar sess√£o:', e.message);
       }
-    });
-  } catch (error) {
-    logger.logError(error, req);
-    res.status(500).json({ error: 'Erro ao gerar relat√≥rio DRE', details: error.message });
-  } finally {
-    connection.release();
-  }
-});
+    }
 
-// An√°lise de Tend√™ncias
-app.get('/api/financial/reports/trends', authenticateAdmin, async (req, res) => {
-  const connection = await pool.getConnection();
+    // 2. Tentar via cart_id
+    if (!userId) {
+      const cartId = req.cookies?.cart_id;
+      if (cartId) {
+        try {
+          const [carts] = await pool.execute('SELECT * FROM carts WHERE id = ?', [cartId]);
+          if (carts && carts[0] && carts[0].user_id) {
+            userId = carts[0].user_id;
+          }
+        } catch (e) {
+          console.log('‚ö†Ô∏è Erro ao buscar usu√°rio pelo cart_id:', e.message);
+        }
+      }
+    }
 
-  try {
-    await connection.query('USE `rare_toy_companion`');
+    // 3. Tentar via Authorization header (JWT)
+    if (!userId) {
+      const authHeader = req.headers.authorization;
+      if (authHeader?.startsWith('Bearer ')) {
+        try {
+          const token = authHeader.split(' ')[1];
+          // Decodificar token JWT (implementar conforme necess√°rio)
+          console.log('üîë Token JWT recebido:', token.substring(0, 20) + '...');
+        } catch (e) {
+          console.log('‚ö†Ô∏è Erro ao processar JWT:', e.message);
+        }
+      }
+    }
 
-    const { months = 12 } = req.query;
-    const endDate = new Date();
-    const startDate = new Date();
-    startDate.setMonth(startDate.getMonth() - parseInt(months));
+    // 4. N√ÉO USAR FALLBACKS - Cada usu√°rio deve ter sua pr√≥pria sess√£o
+    // Removido fallbacks que permitiam acesso a dados de outros usu√°rios
 
-    // Agrupar por m√™s
-    const [monthlyData] = await connection.execute(`
-      SELECT 
-        DATE_FORMAT(data, '%Y-%m') as mes,
-        DATE_FORMAT(data, '%b/%Y') as mes_formatado,
-        SUM(CASE WHEN tipo = 'entrada' AND status = 'Pago' THEN valor ELSE 0 END) as receitas,
-        SUM(CASE WHEN tipo = 'saida' AND status = 'Pago' THEN valor ELSE 0 END) as despesas,
-        COUNT(CASE WHEN tipo = 'entrada' THEN 1 END) as qtd_receitas,
-        COUNT(CASE WHEN tipo = 'saida' THEN 1 END) as qtd_despesas
-      FROM financial_transactions
-      WHERE data >= ? AND data <= ?
-      GROUP BY DATE_FORMAT(data, '%Y-%m')
-      ORDER BY mes ASC
-    `, [startDate.toISOString().split('T')[0], endDate.toISOString().split('T')[0]]);
-
-    // Calcular tend√™ncias
-    const dadosComTendencias = monthlyData.map((mes, index) => {
-      const receitas = parseFloat(mes.receitas);
-      const despesas = parseFloat(mes.despesas);
-      const saldo = receitas - despesas;
-
-      let tendenciaReceitas = 'estavel';
-      let tendenciaDespesas = 'estavel';
-
-      if (index > 0) {
-        const mesAnterior = monthlyData[index - 1];
-        const receitasAnterior = parseFloat(mesAnterior.receitas);
-        const despesasAnterior = parseFloat(mesAnterior.despesas);
-
-        const variacaoReceitas = ((receitas - receitasAnterior) / receitasAnterior) * 100;
-        const variacaoDespesas = ((despesas - despesasAnterior) / despesasAnterior) * 100;
-
-        tendenciaReceitas = variacaoReceitas > 5 ? 'alta' : variacaoReceitas < -5 ? 'baixa' : 'estavel';
-        tendenciaDespesas = variacaoDespesas > 5 ? 'alta' : variacaoDespesas < -5 ? 'baixa' : 'estavel';
-      }
+    if (!userId) {
+      console.log('‚ùå Nenhum usu√°rio identificado');
+      return res.status(401).json({
+        error: 'N√£o autorizado - usu√°rio n√£o identificado',
+        debug: {
+          hasSessionId: !!sessionId,
+          hasCartId: !!req.cookies?.cart_id,
+          hasAuthHeader: !!req.headers.authorization,
+          environment: process.env.NODE_ENV
+        },
+        totalPedidos: 0,
+        pedidosPendentes: 0,
+        totalGasto: 0,
+        favoritos: 0,
+        enderecos: 0,
+        cupons: 0
+      });
+    }
 
-      return {
-        ...mes,
-        receitas,
-        despesas,
-        saldo,
-        tendencia_receitas: tendenciaReceitas,
-        tendencia_despesas: tendenciaDespesas
-      };
-    });
+    // Buscar estat√≠sticas do usu√°rio
+    const [orders] = await pool.execute('SELECT COUNT(*) as total FROM orders WHERE user_id = ?', [userId]);
+    const [pendingOrders] = await pool.execute('SELECT COUNT(*) as total FROM orders WHERE user_id = ? AND status IN ("pending", "processing")', [userId]);
+    const [totalSpent] = await pool.execute('SELECT SUM(total) as total FROM orders WHERE user_id = ? AND status != "cancelled"', [userId]);
+    // Buscar email do usu√°rio para favoritos
+    if (!userEmail) {
+      const [userEmailResult] = await pool.execute('SELECT email FROM users WHERE id = ?', [userId]);
+      userEmail = userEmailResult[0]?.email || userId; // Fallback para userId se for email
+    }
 
-    // Calcular m√©dias e proje√ß√µes
-    const receitasMedias = dadosComTendencias.map(d => d.receitas);
-    const despesasMedias = dadosComTendencias.map(d => d.despesas);
-    const mediaReceitas = receitasMedias.reduce((a, b) => a + b, 0) / receitasMedias.length;
-    const mediaDespesas = despesasMedias.reduce((a, b) => a + b, 0) / despesasMedias.length;
+    const [favorites] = await pool.execute('SELECT COUNT(*) as total FROM favorites WHERE user_email = ?', [userEmail]);
+    const [addresses] = await pool.execute('SELECT COUNT(*) as total FROM enderecos WHERE cliente_id = ?', [userId]);
+    const [coupons] = await pool.execute('SELECT COUNT(*) as total FROM customer_coupons WHERE customer_id = ? AND status = "active"', [userId]);
 
-    res.json({
-      periodo: { meses: parseInt(months), start_date: startDate.toISOString().split('T')[0], end_date: endDate.toISOString().split('T')[0] },
-      dados_mensais: dadosComTendencias,
-      medias: {
-        receitas: mediaReceitas,
-        despesas: mediaDespesas,
-        saldo: mediaReceitas - mediaDespesas
-      },
-      crescimento: {
-        receitas: dadosComTendencias.length > 1
-          ? ((dadosComTendencias[dadosComTendencias.length - 1].receitas - dadosComTendencias[0].receitas) / dadosComTendencias[0].receitas * 100).toFixed(2)
-          : 0,
-        despesas: dadosComTendencias.length > 1
-          ? ((dadosComTendencias[dadosComTendencias.length - 1].despesas - dadosComTendencias[0].despesas) / dadosComTendencias[0].despesas * 100).toFixed(2)
-          : 0
-      }
-    });
+    const stats = {
+      totalPedidos: orders[0]?.total || 0,
+      pedidosPendentes: pendingOrders[0]?.total || 0,
+      totalGasto: parseFloat(totalSpent[0]?.total || 0),
+      favoritos: favorites[0]?.total || 0,
+      enderecos: addresses[0]?.total || 0,
+      cupons: coupons[0]?.total || 0
+    };
+
+    console.log('‚úÖ Estat√≠sticas do usu√°rio calculadas:', stats);
+    res.json(stats);
   } catch (error) {
-    logger.logError(error, req);
-    res.status(500).json({ error: 'Erro ao gerar an√°lise de tend√™ncias', details: error.message });
-  } finally {
-    connection.release();
+    console.error('‚ùå Erro ao buscar estat√≠sticas do usu√°rio:', error);
+    res.status(500).json({
+      error: 'Erro ao buscar estat√≠sticas',
+      totalPedidos: 0,
+      pedidosPendentes: 0,
+      totalGasto: 0,
+      favoritos: 0,
+      enderecos: 0,
+      cupons: 0
+    });
   }
 });
 
-// ==================== OR√áAMENTOS E PLANEJAMENTO ====================
-
-// Listar todos os or√ßamentos
-app.get('/api/financial/budgets', authenticateAdmin, async (req, res) => {
-  const connection = await pool.getConnection();
-
+// Estat√≠sticas gerais de clientes (DEVE VIR ANTES de :userId)
+app.get('/api/customers/stats', async (req, res) => {
   try {
-    await connection.query('USE `rare_toy_companion`');
-
-    // Verificar se tabela existe e criar se necess√°rio
-    try {
-      const [tableCheck] = await connection.query(`
-        SELECT COUNT(*) as count 
-        FROM information_schema.tables 
-        WHERE table_schema = DATABASE() 
-        AND table_name = 'budgets'
-      `);
+    console.log('üìä GET /api/customers/stats');
 
-      if (tableCheck[0].count === 0) {
-        const { createBudgetsTable } = require('./scripts/create-budgets-table.cjs');
-        await createBudgetsTable();
-      }
-    } catch (createError) {
-      // Continuar mesmo se houver erro na verifica√ß√£o
-    }
+    // Buscar estat√≠sticas gerais
+    const [totalCustomers] = await pool.execute('SELECT COUNT(*) as total FROM customers');
+    const [totalOrders] = await pool.execute('SELECT COUNT(*) as total FROM orders');
+    const [totalRevenue] = await pool.execute('SELECT SUM(total) as total FROM orders WHERE status != "cancelled"');
+    const [avgOrderValue] = await pool.execute('SELECT AVG(total) as average FROM orders WHERE status != "cancelled"');
 
-    const { active_only, tipo, categoria } = req.query;
+    const stats = {
+      totalCustomers: totalCustomers[0]?.total || 0,
+      totalOrders: totalOrders[0]?.total || 0,
+      totalRevenue: parseFloat(totalRevenue[0]?.total || 0),
+      averageOrderValue: parseFloat(avgOrderValue[0]?.average || 0)
+    };
 
-    let query = `
-      SELECT 
-        id, nome, descricao, tipo, categoria, valor_orcado, valor_real,
-        data_inicio, data_fim, alerta_percentual, is_active,
-        created_at, updated_at, created_by,
-        CASE 
-          WHEN valor_orcado > 0 THEN (valor_real / valor_orcado * 100)
-          ELSE 0
-        END as percentual_atingido
-      FROM budgets
-      WHERE 1=1
-    `;
+    console.log('‚úÖ Estat√≠sticas gerais calculadas:', stats);
+    res.json(stats);
+  } catch (error) {
+    console.error('‚ùå Erro ao buscar estat√≠sticas gerais:', error);
+    res.status(500).json({
+      error: 'Erro ao buscar estat√≠sticas',
+      totalCustomers: 0,
+      totalOrders: 0,
+      totalRevenue: 0,
+      averageOrderValue: 0
+    });
+  }
+});
 
-    const params = [];
+// Buscar dados completos do cliente
+app.get('/api/customers/:userId', async (req, res) => {
+  try {
+    const { userId } = req.params;
 
-    if (active_only === 'true') {
-      query += ' AND is_active = TRUE';
-    }
+    const [users] = await pool.execute(`
+      SELECT 
+        id, nome, email, telefone, cpf, data_nascimento, avatar_url, bio, created_at,
+        (SELECT COUNT(*) FROM orders WHERE user_id = users.id) as total_orders,
+        (SELECT COALESCE(SUM(total), 0) FROM orders WHERE user_id = users.id AND status != 'cancelled') as total_spent
+      FROM users
+      WHERE id = ?
+    `, [userId]);
 
-    if (tipo) {
-      query += ' AND tipo = ?';
-      params.push(tipo);
+    if (users.length === 0) {
+      return res.status(404).json({ error: 'Cliente n√£o encontrado' });
     }
 
-    if (categoria) {
-      query += ' AND categoria = ?';
-      params.push(categoria);
-    }
-
-    query += ' ORDER BY data_inicio DESC, created_at DESC';
-
-    const [rows] = await connection.execute(query, params);
-
-    // Atualizar valores reais baseados em transa√ß√µes
-    for (const budget of rows) {
-      const [realValue] = await connection.execute(`
-        SELECT COALESCE(SUM(valor), 0) as total
-        FROM financial_transactions
-        WHERE tipo = 'saida'
-          AND categoria = ?
-          AND data BETWEEN ? AND ?
-          AND status = 'Pago'
-      `, [budget.categoria, budget.data_inicio, budget.data_fim]);
-
-      const valorReal = parseFloat(realValue[0].total);
-
-      if (valorReal !== budget.valor_real) {
-        await connection.execute(`
-          UPDATE budgets
-          SET valor_real = ?
-          WHERE id = ?
-        `, [valorReal, budget.id]);
-
-        budget.valor_real = valorReal;
-        budget.percentual_atingido = budget.valor_orcado > 0
-          ? (valorReal / budget.valor_orcado * 100).toFixed(2)
-          : 0;
-      }
-    }
+    const customer = users[0];
+    customer.loyalty_points = Math.floor(Number(customer.total_spent) / 10);
 
-    res.json({ budgets: rows, total: rows.length });
+    res.json(customer);
   } catch (error) {
     logger.logError(error, req);
-    res.status(500).json({ error: 'Erro ao buscar or√ßamentos', details: error.message });
-  } finally {
-    connection.release();
+    res.status(500).json({ error: 'Erro ao buscar cliente' });
   }
 });
 
-// Buscar or√ßamento por ID
-app.get('/api/financial/budgets/:id', authenticateAdmin, async (req, res) => {
-  const connection = await pool.getConnection();
-
+// Atualizar dados do cliente
+app.put('/api/customers/:userId', async (req, res) => {
   try {
-    await connection.query('USE `rare_toy_companion`');
-
-    const { id } = req.params;
-    const [rows] = await connection.execute(
-      'SELECT * FROM budgets WHERE id = ?',
-      [id]
-    );
+    const { userId } = req.params;
+    const { nome, telefone, cpf, data_nascimento, avatar_url, bio } = req.body;
 
-    if (rows.length === 0) {
-      return res.status(404).json({ error: 'Or√ßamento n√£o encontrado' });
-    }
+    await pool.execute(`
+      UPDATE users
+      SET nome = ?, telefone = ?, cpf = ?, data_nascimento = ?, avatar_url = ?, bio = ?, updated_at = NOW()
+      WHERE id = ?
+    `, [nome, telefone || null, cpf || null, data_nascimento || null, avatar_url || null, bio || null, userId]);
 
-    res.json({ budget: rows[0] });
+    logger.info('Cliente atualizado', { userId, nome });
+    res.json({ success: true });
   } catch (error) {
     logger.logError(error, req);
-    res.status(500).json({ error: 'Erro ao buscar or√ßamento', details: error.message });
-  } finally {
-    connection.release();
+    res.status(500).json({ error: 'Erro ao atualizar cliente' });
   }
 });
 
-// Criar or√ßamento
-app.post('/api/financial/budgets', authenticateAdmin, async (req, res) => {
-  const connection = await pool.getConnection();
-
+// Estat√≠sticas do cliente (dashboard)
+app.get('/api/customers/:userId/stats', async (req, res) => {
   try {
-    await connection.query('USE `rare_toy_companion`');
-
-    const {
-      nome, descricao, tipo, categoria, valor_orcado,
-      data_inicio, data_fim, alerta_percentual
-    } = req.body;
+    let { userId } = req.params;
 
-    if (!nome || !tipo || !valor_orcado || !data_inicio || !data_fim) {
-      connection.release();
-      return res.status(400).json({
-        error: 'Campos obrigat√≥rios: nome, tipo, valor_orcado, data_inicio, data_fim'
-      });
+    // Se userId parece ser email, buscar o ID do usu√°rio
+    if (userId.includes('@')) {
+      try {
+        const [user] = await pool.execute('SELECT id FROM users WHERE email = ?', [userId]);
+        if (user && user[0]) {
+          userId = user[0].id;
+        } else {
+          return res.status(404).json({ error: 'Usu√°rio n√£o encontrado' });
+        }
+      } catch (e) {
+        console.log('‚ö†Ô∏è Erro ao buscar usu√°rio por email:', e.message);
+        return res.status(500).json({ error: 'Erro ao buscar usu√°rio' });
+      }
     }
 
-    if (new Date(data_fim) < new Date(data_inicio)) {
-      connection.release();
-      return res.status(400).json({ error: 'Data fim deve ser posterior √† data in√≠cio' });
-    }
+    // Buscar estat√≠sticas de pedidos
+    const [orderStats] = await pool.execute(`
+      SELECT 
+        COUNT(*) as total_orders,
+        COALESCE(SUM(total), 0) as total_spent,
+        MAX(created_at) as last_order_date
+      FROM orders
+      WHERE user_id = ?
+    `, [userId]);
 
-    const id = crypto.randomUUID();
-    const safeAlertaPercentual = alerta_percentual || 80;
+    // Buscar favoritos (usar tabela favorites com email do usu√°rio)
+    const [userEmail] = await pool.execute('SELECT email FROM users WHERE id = ?', [userId]);
+    const email = userEmail[0]?.email || null;
+    const [favStats] = await pool.execute(`
+      SELECT COUNT(*) as favorite_count
+      FROM favorites
+      WHERE user_email = ?
+    `, [email]);
 
-    await connection.execute(`
-      INSERT INTO budgets (
-        id, nome, descricao, tipo, categoria, valor_orcado, valor_real,
-        data_inicio, data_fim, alerta_percentual, is_active, created_by
-      ) VALUES (?, ?, ?, ?, ?, ?, 0, ?, ?, ?, TRUE, ?)
-    `, [
-      id, nome, descricao || null, tipo, categoria || null,
-      valor_orcado, data_inicio, data_fim, safeAlertaPercentual,
-      req.user?.email || null
-    ]);
+    // Calcular pontos de fidelidade (1 ponto a cada R$ 10 gastos)
+    const loyaltyPoints = Math.floor(Number(orderStats[0].total_spent) / 10);
+    const nextReward = 100; // Pr√≥xima recompensa em 100 pontos
 
-    logger.info('Or√ßamento criado', { id, nome });
     res.json({
-      success: true,
-      message: 'Or√ßamento criado com sucesso',
-      budget: { id, nome, tipo, valor_orcado }
+      totalOrders: Number(orderStats[0].total_orders) || 0,
+      totalSpent: Number(orderStats[0].total_spent) || 0,
+      favoriteProducts: Number(favStats[0].favorite_count) || 0,
+      lastOrderDate: orderStats[0].last_order_date,
+      loyaltyPoints,
+      nextReward,
     });
   } catch (error) {
     logger.logError(error, req);
-    res.status(500).json({ error: 'Erro ao criar or√ßamento', details: error.message });
-  } finally {
-    connection.release();
+    res.status(500).json({ error: 'Erro ao buscar estat√≠sticas do cliente' });
   }
 });
 
-// Atualizar or√ßamento
-app.put('/api/financial/budgets/:id', authenticateAdmin, async (req, res) => {
-  const connection = await pool.getConnection();
-
+// Estat√≠sticas de pedidos do cliente (para aba pedidos)
+app.get('/api/customers/:userId/order-stats', async (req, res) => {
   try {
-    await connection.query('USE `rare_toy_companion`');
-
-    const { id } = req.params;
-    const {
-      nome, descricao, tipo, categoria, valor_orcado, valor_real,
-      data_inicio, data_fim, alerta_percentual, is_active
-    } = req.body;
-
-    // Verificar se existe
-    const [existing] = await connection.execute(
-      'SELECT * FROM budgets WHERE id = ?',
-      [id]
-    );
-
-    if (existing.length === 0) {
-      connection.release();
-      return res.status(404).json({ error: 'Or√ßamento n√£o encontrado' });
-    }
-
-    // Registrar hist√≥rico se valor mudou
-    if (valor_orcado !== undefined && valor_orcado !== existing[0].valor_orcado) {
-      await connection.execute(`
-        INSERT INTO budget_history (
-          id, budget_id, valor_anterior, valor_novo,
-          valor_real_anterior, valor_real_novo, changed_by
-        ) VALUES (UUID(), ?, ?, ?, ?, ?, ?)
-      `, [
-        id, existing[0].valor_orcado, valor_orcado,
-        existing[0].valor_real, valor_real !== undefined ? valor_real : existing[0].valor_real,
-        req.user?.email || null
-      ]);
-    }
-
-    // Construir query de update dinamicamente
-    const updates = [];
-    const params = [];
-
-    if (nome !== undefined) { updates.push('nome = ?'); params.push(nome); }
-    if (descricao !== undefined) { updates.push('descricao = ?'); params.push(descricao); }
-    if (tipo !== undefined) { updates.push('tipo = ?'); params.push(tipo); }
-    if (categoria !== undefined) { updates.push('categoria = ?'); params.push(categoria); }
-    if (valor_orcado !== undefined) { updates.push('valor_orcado = ?'); params.push(valor_orcado); }
-    if (valor_real !== undefined) { updates.push('valor_real = ?'); params.push(valor_real); }
-    if (data_inicio !== undefined) { updates.push('data_inicio = ?'); params.push(data_inicio); }
-    if (data_fim !== undefined) { updates.push('data_fim = ?'); params.push(data_fim); }
-    if (alerta_percentual !== undefined) { updates.push('alerta_percentual = ?'); params.push(alerta_percentual); }
-    if (is_active !== undefined) { updates.push('is_active = ?'); params.push(is_active); }
-
-    if (updates.length === 0) {
-      connection.release();
-      return res.status(400).json({ error: 'Nenhum campo para atualizar' });
-    }
-
-    updates.push('updated_at = NOW()');
-    params.push(id);
+    const { userId } = req.params;
 
-    await connection.execute(`
-      UPDATE budgets
-      SET ${updates.join(', ')}
-      WHERE id = ?
-    `, params);
+    const [stats] = await pool.execute(`
+      SELECT 
+        COUNT(*) as total,
+        SUM(CASE WHEN status = 'pending' THEN 1 ELSE 0 END) as pending,
+        SUM(CASE WHEN status = 'delivered' THEN 1 ELSE 0 END) as delivered,
+        COALESCE(SUM(CASE WHEN status != 'cancelled' THEN total ELSE 0 END), 0) as total_spent,
+        SUM(CASE WHEN created_at >= DATE_SUB(NOW(), INTERVAL 1 MONTH) THEN 1 ELSE 0 END) as last_month
+      FROM orders
+      WHERE customer_id = ? OR user_id = ?
+    `, [userId, userId]);
 
-    logger.info('Or√ßamento atualizado', { id });
-    res.json({ success: true, message: 'Or√ßamento atualizado com sucesso' });
+    res.json({
+      total: Number(stats[0].total) || 0,
+      pending: Number(stats[0].pending) || 0,
+      delivered: Number(stats[0].delivered) || 0,
+      totalSpent: Number(stats[0].total_spent) || 0,
+      lastMonth: Number(stats[0].last_month) || 0,
+    });
   } catch (error) {
     logger.logError(error, req);
-    res.status(500).json({ error: 'Erro ao atualizar or√ßamento', details: error.message });
-  } finally {
-    connection.release();
+    res.status(500).json({ error: 'Erro ao buscar estat√≠sticas de pedidos' });
   }
 });
 
-// Excluir or√ßamento
-app.delete('/api/financial/budgets/:id', authenticateAdmin, async (req, res) => {
-  const connection = await pool.getConnection();
+// ==================== ORDER STATUS API ====================
 
+// Endpoint para verificar status do pedido
+app.get('/api/orders/:orderId/status', async (req, res) => {
   try {
-    await connection.query('USE `rare_toy_companion`');
+    const { orderId } = req.params;
+    console.log(`üìä GET /api/orders/${orderId}/status`);
 
-    const { id } = req.params;
-    const [result] = await connection.execute(
-      'DELETE FROM budgets WHERE id = ?',
-      [id]
-    );
+    // Buscar status do pedido
+    const [orders] = await pool.execute(`
+      SELECT 
+        id,
+        status,
+        payment_status,
+        payment_method,
+        total,
+        created_at,
+        updated_at
+      FROM orders 
+      WHERE id = ?
+    `, [orderId]);
 
-    if (result.affectedRows === 0) {
-      connection.release();
-      return res.status(404).json({ error: 'Or√ßamento n√£o encontrado' });
+    if (orders.length === 0) {
+      return res.status(404).json({ error: 'Pedido n√£o encontrado' });
     }
 
-    logger.info('Or√ßamento exclu√≠do', { id });
-    res.json({ success: true, message: 'Or√ßamento exclu√≠do com sucesso' });
+    const order = orders[0];
+    console.log(`‚úÖ Status do pedido encontrado:`, order);
+    res.json(order);
+
   } catch (error) {
-    logger.logError(error, req);
-    res.status(500).json({ error: 'Erro ao excluir or√ßamento', details: error.message });
-  } finally {
-    connection.release();
+    console.error('‚ùå Erro ao buscar status do pedido:', error);
+    res.status(500).json({ error: 'Erro ao buscar status do pedido' });
   }
 });
 
-// Buscar alertas de or√ßamento
-app.get('/api/financial/budgets/:id/alerts', authenticateAdmin, async (req, res) => {
-  const connection = await pool.getConnection();
+// ==================== USER STATS API ====================
 
+// Endpoint para estat√≠sticas do usu√°rio
+app.get('/api/user-stats/stats/:userId', async (req, res) => {
   try {
-    await connection.query('USE `rare_toy_companion`');
+    const { userId } = req.params;
+    console.log(`üìä GET /api/user-stats/stats/${userId}`);
 
-    const { id } = req.params;
-    const [rows] = await connection.execute(
-      'SELECT * FROM budget_alerts WHERE budget_id = ? ORDER BY created_at DESC LIMIT 50',
-      [id]
-    );
+    // Buscar estat√≠sticas do usu√°rio
+    const [orders] = await pool.execute(`
+      SELECT 
+        COUNT(*) as total_pedidos,
+        COALESCE(SUM(total), 0) as total_gasto,
+        MAX(created_at) as ultimo_pedido
+      FROM orders 
+      WHERE user_id = ?
+    `, [userId]);
+
+    const stats = orders[0] || {
+      total_pedidos: 0,
+      total_gasto: 0,
+      ultimo_pedido: null
+    };
+
+    console.log(`‚úÖ Estat√≠sticas encontradas:`, stats);
+    res.json(stats);
 
-    res.json({ alerts: rows });
   } catch (error) {
-    logger.logError(error, req);
-    res.status(500).json({ error: 'Erro ao buscar alertas', details: error.message });
-  } finally {
-    connection.release();
+    console.error('‚ùå Erro ao buscar estat√≠sticas:', error);
+    res.status(500).json({ error: 'Erro ao buscar estat√≠sticas' });
   }
 });
 
-// Processar alertas de or√ßamento (verificar e criar alertas)
-app.post('/api/financial/budgets/process-alerts', authenticateAdmin, async (req, res) => {
-  const connection = await pool.getConnection();
+// ==================== TESTE E DESENVOLVIMENTO ====================
 
+// Endpoint para criar dados de teste
+app.post('/api/test/create-test-data', async (req, res) => {
   try {
-    await connection.query('USE `rare_toy_companion`');
+    console.log('üß™ Criando dados de teste...');
 
-    const [budgets] = await connection.execute(`
-      SELECT * FROM budgets
-      WHERE is_active = TRUE
-        AND CURDATE() BETWEEN data_inicio AND data_fim
-    `);
+    // Criar usu√°rio de teste se n√£o existir
+    const testEmail = 'cliente@exemplo.com';
+    const [existingUser] = await pool.execute('SELECT id FROM users WHERE email = ?', [testEmail]);
 
-    const alerts = [];
-
-    for (const budget of budgets) {
-      // Atualizar valor real
-      const [realValue] = await connection.execute(`
-        SELECT COALESCE(SUM(valor), 0) as total
-        FROM financial_transactions
-        WHERE tipo = 'saida'
-          AND categoria = ?
-          AND data BETWEEN ? AND ?
-          AND status = 'Pago'
-      `, [budget.categoria, budget.data_inicio, budget.data_fim]);
-
-      const valorReal = parseFloat(realValue[0].total);
-      const percentualAtingido = budget.valor_orcado > 0
-        ? (valorReal / budget.valor_orcado) * 100
-        : 0;
-
-      // Atualizar valor real no or√ßamento
-      await connection.execute(`
-        UPDATE budgets SET valor_real = ? WHERE id = ?
-      `, [valorReal, budget.id]);
-
-      // Verificar se precisa criar alerta
-      if (percentualAtingido >= budget.alerta_percentual) {
-        let tipoAlerta = 'alerta';
-        let mensagem = '';
-
-        if (percentualAtingido >= 100) {
-          tipoAlerta = 'extrapolado';
-          mensagem = `Or√ßamento "${budget.nome}" foi extrapolado! Utilizado ${percentualAtingido.toFixed(2)}% do valor or√ßado.`;
-        } else if (percentualAtingido >= budget.alerta_percentual) {
-          tipoAlerta = 'alerta';
-          mensagem = `Or√ßamento "${budget.nome}" atingiu ${percentualAtingido.toFixed(2)}% do valor or√ßado.`;
-        }
+    let userId;
+    if (existingUser.length === 0) {
+      const [result] = await pool.execute(`
+        INSERT INTO users (email, nome, telefone, created_at) 
+        VALUES (?, 'Cliente Exemplo', '11999999999', NOW())
+      `, [testEmail]);
+      userId = result.insertId;
+    } else {
+      userId = existingUser[0].id;
+    }
 
-        // Verificar se j√° existe alerta recente (√∫ltimas 24h)
-        const [existingAlert] = await connection.execute(`
-          SELECT id FROM budget_alerts
-          WHERE budget_id = ?
-            AND tipo = ?
-            AND created_at >= DATE_SUB(NOW(), INTERVAL 1 DAY)
-          LIMIT 1
-        `, [budget.id, tipoAlerta]);
-
-        if (existingAlert.length === 0) {
-          await connection.execute(`
-            INSERT INTO budget_alerts (
-              id, budget_id, tipo, percentual_atingido, mensagem, foi_notificado
-            ) VALUES (UUID(), ?, ?, ?, ?, FALSE)
-          `, [budget.id, tipoAlerta, percentualAtingido.toFixed(2), mensagem]);
-
-          alerts.push({ budget_id: budget.id, budget_nome: budget.nome, tipo: tipoAlerta, mensagem });
-        }
-      }
+    // Criar sess√£o de teste
+    const sessionId = 'test-session-' + Date.now();
+    await pool.execute(`
+      INSERT INTO sessions (id, user_id, expires_at) 
+      VALUES (?, ?, DATE_ADD(NOW(), INTERVAL 1 DAY))
+    `, [sessionId, userId]);
+
+    // Criar endere√ßo de teste
+    const [existingAddress] = await pool.execute('SELECT id FROM enderecos WHERE cliente_id = ?', [userId]);
+    if (existingAddress.length === 0) {
+      await pool.execute(`
+        INSERT INTO enderecos 
+        (cliente_id, nome, logradouro, numero, complemento, bairro, cidade, estado, cep, tipo, principal, created_at)
+        VALUES (?, 'Casa', 'Rua das Flores', '123', 'Apto 45', 'Centro', 'S√£o Paulo', 'SP', '01234567', 'residencial', 1, NOW())
+      `, [userId]);
     }
 
     res.json({
       success: true,
-      processed: budgets.length,
-      alerts_created: alerts.length,
-      alerts: alerts
+      userId,
+      sessionId,
+      message: 'Dados de teste criados com sucesso!'
     });
   } catch (error) {
-    logger.logError(error, req);
-    res.status(500).json({ error: 'Erro ao processar alertas', details: error.message });
-  } finally {
-    connection.release();
+    console.error('‚ùå Erro ao criar dados de teste:', error);
+    res.status(500).json({ error: 'Erro interno' });
   }
 });
 
-// Comparativo Per√≠odo a Per√≠odo
-app.get('/api/financial/reports/comparative', authenticateAdmin, async (req, res) => {
-  const connection = await pool.getConnection();
-
+// Endpoint para testar com dados de teste
+app.get('/api/test/stats', async (req, res) => {
   try {
-    await connection.query('USE `rare_toy_companion`');
-
-    const { period1_start, period1_end, period2_start, period2_end } = req.query;
+    const testEmail = 'cliente@exemplo.com';
+    const [user] = await pool.execute('SELECT id FROM users WHERE email = ?', [testEmail]);
 
-    if (!period1_start || !period1_end || !period2_start || !period2_end) {
-      return res.status(400).json({ error: 'Todos os per√≠odos devem ser informados' });
+    if (user.length === 0) {
+      return res.status(404).json({ error: 'Usu√°rio de teste n√£o encontrado' });
     }
 
-    // Per√≠odo 1
-    const [periodo1] = await connection.execute(`
-      SELECT 
-        COALESCE(SUM(CASE WHEN tipo = 'entrada' AND status = 'Pago' THEN valor ELSE 0 END), 0) as receitas,
-        COALESCE(SUM(CASE WHEN tipo = 'saida' AND status = 'Pago' THEN valor ELSE 0 END), 0) as despesas,
-        COUNT(*) as total_transacoes
-      FROM financial_transactions
-      WHERE data BETWEEN ? AND ?
-    `, [period1_start, period1_end]);
-
-    // Per√≠odo 2
-    const [periodo2] = await connection.execute(`
-      SELECT 
-        COALESCE(SUM(CASE WHEN tipo = 'entrada' AND status = 'Pago' THEN valor ELSE 0 END), 0) as receitas,
-        COALESCE(SUM(CASE WHEN tipo = 'saida' AND status = 'Pago' THEN valor ELSE 0 END), 0) as despesas,
-        COUNT(*) as total_transacoes
-      FROM financial_transactions
-      WHERE data BETWEEN ? AND ?
-    `, [period2_start, period2_end]);
-
-    const p1 = {
-      receitas: parseFloat(periodo1[0].receitas),
-      despesas: parseFloat(periodo1[0].despesas),
-      saldo: parseFloat(periodo1[0].receitas) - parseFloat(periodo1[0].despesas),
-      total_transacoes: periodo1[0].total_transacoes
-    };
+    const userId = user[0].id;
 
-    const p2 = {
-      receitas: parseFloat(periodo2[0].receitas),
-      despesas: parseFloat(periodo2[0].despesas),
-      saldo: parseFloat(periodo2[0].receitas) - parseFloat(periodo2[0].despesas),
-      total_transacoes: periodo2[0].total_transacoes
-    };
+    // Buscar estat√≠sticas
+    const [orders] = await pool.execute('SELECT COUNT(*) as total FROM orders WHERE user_id = ?', [userId]);
+    const [pendingOrders] = await pool.execute('SELECT COUNT(*) as total FROM orders WHERE user_id = ? AND status IN ("pending", "processing")', [userId]);
+    const [totalSpent] = await pool.execute('SELECT SUM(total) as total FROM orders WHERE user_id = ? AND status != "cancelled"', [userId]);
+    const [addresses] = await pool.execute('SELECT COUNT(*) as total FROM enderecos WHERE cliente_id = ?', [userId]);
 
-    // Calcular varia√ß√µes
-    const variacaoReceitas = p1.receitas > 0 ? ((p2.receitas - p1.receitas) / p1.receitas) * 100 : 0;
-    const variacaoDespesas = p1.despesas > 0 ? ((p2.despesas - p1.despesas) / p1.despesas) * 100 : 0;
-    const variacaoSaldo = p1.saldo !== 0 ? ((p2.saldo - p1.saldo) / Math.abs(p1.saldo)) * 100 : 0;
+    const stats = {
+      totalPedidos: orders[0]?.total || 0,
+      pedidosPendentes: pendingOrders[0]?.total || 0,
+      totalGasto: parseFloat(totalSpent[0]?.total || 0),
+      favoritos: 0,
+      enderecos: addresses[0]?.total || 0,
+      cupons: 0
+    };
 
-    res.json({
-      periodo1: {
-        ...p1,
-        periodo: { start: period1_start, end: period1_end }
-      },
-      periodo2: {
-        ...p2,
-        periodo: { start: period2_start, end: period2_end }
-      },
-      variacoes: {
-        receitas: {
-          absoluta: p2.receitas - p1.receitas,
-          percentual: variacaoReceitas.toFixed(2),
-          tendencia: variacaoReceitas > 0 ? 'alta' : variacaoReceitas < 0 ? 'baixa' : 'estavel'
-        },
-        despesas: {
-          absoluta: p2.despesas - p1.despesas,
-          percentual: variacaoDespesas.toFixed(2),
-          tendencia: variacaoDespesas > 0 ? 'alta' : variacaoDespesas < 0 ? 'baixa' : 'estavel'
-        },
-        saldo: {
-          absoluta: p2.saldo - p1.saldo,
-          percentual: variacaoSaldo.toFixed(2),
-          tendencia: variacaoSaldo > 0 ? 'alta' : variacaoSaldo < 0 ? 'baixa' : 'estavel'
-        }
-      }
-    });
+    res.json(stats);
   } catch (error) {
-    logger.logError(error, req);
-    res.status(500).json({ error: 'Erro ao gerar comparativo', details: error.message });
-  } finally {
-    connection.release();
+    console.error('‚ùå Erro ao buscar estat√≠sticas de teste:', error);
+    res.status(500).json({ error: 'Erro interno' });
   }
 });
 
-// ==================== TESTE DE TABELAS ====================
+// ==================== ADDRESSES API (ENDERE√áOS M√öLTIPLOS) ====================
 
-// Teste espec√≠fico para contas e cart√µes
-app.get('/api/test-contas-financial_cards', async (req, res) => {
+// Listar endere√ßos do cliente
+app.get('/api/customers/addresses', async (req, res) => {
   try {
-    console.log('üîç Testando acesso √†s tabelas financial_accounts e financial_cards...');
+    console.log('üè† GET /api/customers/addresses');
+
+    // Obter usu√°rio da sess√£o (mesma l√≥gica do stats)
+    let userId = null;
+    const sessionId = req.cookies?.session_id;
+    if (sessionId) {
+      try {
+        const [sessions] = await pool.execute('SELECT * FROM sessions WHERE id = ?', [sessionId]);
+        if (sessions && sessions[0] && sessions[0].user_email) {
+          const userEmail = sessions[0].user_email;
+          console.log('üë§ Usu√°rio logado via sess√£o:', userEmail);
+
+          // Buscar o user_id na tabela customers baseado no email
+          const [customers] = await pool.execute('SELECT id FROM customers WHERE email = ?', [userEmail]);
+          if (customers && customers[0]) {
+            userId = customers[0].id;
+            console.log('‚úÖ User ID encontrado:', userId);
+          } else {
+            console.log('‚ö†Ô∏è Cliente n√£o encontrado para email:', userEmail);
+          }
+        }
+      } catch (e) {
+        console.log('‚ö†Ô∏è Erro ao verificar sess√£o:', e.message);
+      }
+    }
 
-    // Testar financial_accounts
-    const [contasRows] = await pool.execute('SHOW TABLES LIKE "financial_accounts"');
-    console.log('Financial accounts tables found:', contasRows.length);
+    // N√ÉO USAR FALLBACKS - Cada usu√°rio deve ter sua pr√≥pria sess√£o
 
-    // Testar financial_cards
-    const [financial_cardsRows] = await pool.execute('SHOW TABLES LIKE "financial_cards"');
-    console.log('Financial cards tables found:', financial_cardsRows.length);
+    if (!userId) {
+      return res.status(401).json({ error: 'N√£o autorizado' });
+    }
 
-    // Tentar buscar dados
-    const [contasData] = await pool.execute('SELECT COUNT(*) as total FROM financial_accounts');
-    const [financial_cardsData] = await pool.execute('SELECT COUNT(*) as total FROM financial_cards');
+    // Buscar endere√ßos
+    const [addresses] = await pool.execute(`
+      SELECT * FROM enderecos 
+      WHERE cliente_id = ? 
+      ORDER BY principal DESC, created_at DESC
+    `, [userId]);
 
-    res.json({
-      success: true,
-      contas_table_exists: contasRows.length > 0,
-      financial_cards_table_exists: financial_cardsRows.length > 0,
-      contas_count: contasData[0]?.total || 0,
-      financial_cards_count: financial_cardsData[0]?.total || 0
-    });
+    res.json(addresses);
   } catch (error) {
-    console.error('‚ùå Erro no teste:', error);
-    res.json({ success: false, error: error.message });
+    console.error('‚ùå Erro ao buscar endere√ßos:', error);
+    res.status(500).json({ error: 'Erro interno' });
   }
 });
 
-// ==================== ENDPOINTS CONTAS BANC√ÅRIAS ====================
+// Criar novo endere√ßo
+app.post('/api/customers/addresses', async (req, res) => {
+  try {
+    console.log('üè† POST /api/customers/addresses');
+
+    const { nome, rua, numero, complemento, bairro, cidade, estado, cep, tipo, is_default } = req.body;
+
+    // Validar dados obrigat√≥rios
+    if (!nome || !rua || !cidade || !estado || !cep) {
+      return res.status(400).json({ error: 'Dados obrigat√≥rios n√£o fornecidos' });
+    }
+
+    // Obter usu√°rio da sess√£o
+    let userId = null;
+    const sessionId = req.cookies?.session_id;
+    if (sessionId) {
+      try {
+        const [sessions] = await pool.execute('SELECT * FROM sessions WHERE id = ?', [sessionId]);
+        if (sessions && sessions[0] && sessions[0].user_email) {
+          const userEmail = sessions[0].user_email;
+          console.log('üë§ Usu√°rio logado via sess√£o:', userEmail);
 
-// Buscar todas as contas banc√°rias
-app.get('/api/financial/contas', async (req, res) => {
-  try {
-    // Retornar dados simulados temporariamente para testar o frontend
-    const contasSimuladas = [
-      {
-        id: 1,
-        nome: 'Conta Principal',
-        banco: 'Nubank',
-        agencia: '0001',
-        conta: '12345-6',
-        tipo: 'corrente',
-        saldo: 15000.50,
-        limite: 5000.00,
-        status: 'ativo',
-        ultima_movimentacao: '2024-10-18',
-        observacoes: 'Conta principal da empresa',
-        created_at: '2024-01-15',
-        updated_at: '2024-10-18'
-      },
-      {
-        id: 2,
-        nome: 'Conta Poupan√ßa',
-        banco: 'Banco do Brasil',
-        agencia: '1234',
-        conta: '98765-4',
-        tipo: 'poupanca',
-        saldo: 25000.00,
-        limite: 0.00,
-        status: 'ativo',
-        ultima_movimentacao: '2024-10-17',
-        observacoes: 'Reserva de emerg√™ncia',
-        created_at: '2024-02-01',
-        updated_at: '2024-10-17'
+          // Buscar o user_id na tabela customers baseado no email
+          const [customers] = await pool.execute('SELECT id FROM customers WHERE email = ?', [userEmail]);
+          if (customers && customers[0]) {
+            userId = customers[0].id;
+            console.log('‚úÖ User ID encontrado:', userId);
+          } else {
+            console.log('‚ö†Ô∏è Cliente n√£o encontrado para email:', userEmail);
+          }
+        }
+      } catch (e) {
+        console.log('‚ö†Ô∏è Erro ao verificar sess√£o:', e.message);
       }
-    ];
+    }
 
-    console.log('‚úÖ Contas banc√°rias carregadas (simuladas):', contasSimuladas.length);
-    res.json({ contas: contasSimuladas, total: contasSimuladas.length });
-  } catch (error) {
-    console.error('‚ùå Erro ao buscar contas banc√°rias:', error);
-    res.status(500).json({ error: 'Erro ao buscar contas banc√°rias', details: error.message });
-  }
-});
+    // N√ÉO USAR FALLBACKS - Cada usu√°rio deve ter sua pr√≥pria sess√£o
 
-// Criar conta banc√°ria
-app.post('/api/financial/contas', async (req, res) => {
-  try {
-    const { nome, banco, agencia, conta, tipo, saldo, limite, status, observacoes } = req.body;
+    if (!userId) {
+      return res.status(401).json({ error: 'N√£o autorizado' });
+    }
 
-    if (!nome || !banco || !agencia || !conta) {
-      return res.status(400).json({ error: 'Campos obrigat√≥rios: nome, banco, agencia, conta' });
+    // Se for endere√ßo padr√£o, remover padr√£o dos outros
+    if (is_default) {
+      await pool.execute('UPDATE enderecos SET principal = 0 WHERE cliente_id = ?', [userId]);
     }
 
+    // Inserir novo endere√ßo
     const [result] = await pool.execute(`
-      INSERT INTO financial_accounts (
-        nome, banco, agencia, conta, tipo, saldo, limite, status, observacoes, ultima_movimentacao
-      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, NOW())
-    `, [nome, banco, agencia, conta, tipo || 'corrente', saldo || 0, limite || 0, status || 'ativo', observacoes || '']);
-
-    const insertedId = result.insertId;
-    console.log('‚úÖ Conta banc√°ria criada:', insertedId);
+      INSERT INTO enderecos 
+      (cliente_id, nome, logradouro, numero, complemento, bairro, cidade, estado, cep, tipo, principal, created_at)
+      VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, NOW())
+    `, [userId, nome, rua, numero, complemento, bairro, cidade, estado, cep, tipo, is_default || 0]);
 
-    res.json({
-      success: true,
-      message: 'Conta banc√°ria criada com sucesso',
-      conta: { id: insertedId, nome, banco, agencia, conta, tipo, saldo, limite, status, observacoes }
-    });
+    res.json({ success: true, id: result.insertId });
   } catch (error) {
-    console.error('‚ùå Erro ao criar conta banc√°ria:', error);
-    res.status(500).json({ error: 'Erro ao criar conta banc√°ria', details: error.message });
+    console.error('‚ùå Erro ao salvar endere√ßo:', error);
+    res.status(500).json({ error: 'Erro interno' });
   }
 });
 
-// Atualizar conta banc√°ria
-app.put('/api/financial/contas/:id', async (req, res) => {
+// Atualizar endere√ßo
+app.put('/api/customers/addresses/:id', async (req, res) => {
   try {
+    console.log('üè† PUT /api/customers/addresses/' + req.params.id);
+
     const { id } = req.params;
-    const { nome, banco, agencia, conta, tipo, saldo, limite, status, observacoes } = req.body;
+    const { nome, rua, numero, complemento, bairro, cidade, estado, cep, tipo, is_default } = req.body;
+
+    // Obter usu√°rio da sess√£o
+    let userId = null;
+    const sessionId = req.cookies?.session_id;
+    if (sessionId) {
+      try {
+        const [sessions] = await pool.execute('SELECT * FROM sessions WHERE id = ?', [sessionId]);
+        if (sessions && sessions[0] && sessions[0].user_email) {
+          const userEmail = sessions[0].user_email;
+          console.log('üë§ Usu√°rio logado via sess√£o:', userEmail);
 
-    if (!nome || !banco || !agencia || !conta) {
-      return res.status(400).json({ error: 'Campos obrigat√≥rios: nome, banco, agencia, conta' });
+          // Buscar o user_id na tabela customers baseado no email
+          const [customers] = await pool.execute('SELECT id FROM customers WHERE email = ?', [userEmail]);
+          if (customers && customers[0]) {
+            userId = customers[0].id;
+            console.log('‚úÖ User ID encontrado:', userId);
+          } else {
+            console.log('‚ö†Ô∏è Cliente n√£o encontrado para email:', userEmail);
+          }
+        }
+      } catch (e) {
+        console.log('‚ö†Ô∏è Erro ao verificar sess√£o:', e.message);
+      }
     }
 
-    const [result] = await pool.execute(`
-      UPDATE financial_accounts 
-      SET nome = ?, banco = ?, agencia = ?, conta = ?, tipo = ?, saldo = ?, limite = ?, status = ?, observacoes = ?, updated_at = NOW()
-      WHERE id = ?
-    `, [nome, banco, agencia, conta, tipo, saldo || 0, limite || 0, status, observacoes || '', id]);
+    // N√ÉO USAR FALLBACKS - Cada usu√°rio deve ter sua pr√≥pria sess√£o
 
-    if (result.affectedRows === 0) {
-      return res.status(404).json({ error: 'Conta banc√°ria n√£o encontrada' });
+    if (!userId) {
+      return res.status(401).json({ error: 'N√£o autorizado' });
     }
 
-    console.log('‚úÖ Conta banc√°ria atualizada:', id);
-    res.json({
-      success: true,
-      message: 'Conta banc√°ria atualizada com sucesso',
-      conta: { id, nome, banco, agencia, conta, tipo, saldo, limite, status, observacoes }
-    });
-  } catch (error) {
-    console.error('‚ùå Erro ao atualizar conta banc√°ria:', error);
-    res.status(500).json({ error: 'Erro ao atualizar conta banc√°ria', details: error.message });
-  }
-});
+    // Se for endere√ßo padr√£o, remover padr√£o dos outros
+    if (is_default) {
+      await pool.execute('UPDATE enderecos SET principal = 0 WHERE cliente_id = ?', [userId]);
+    }
 
-// Excluir conta banc√°ria
-app.delete('/api/financial/contas/:id', async (req, res) => {
-  try {
-    const { id } = req.params;
+    // Atualizar endere√ßo
+    await pool.execute(`
+      UPDATE enderecos 
+      SET nome = ?, logradouro = ?, numero = ?, complemento = ?, bairro = ?, 
+          cidade = ?, estado = ?, cep = ?, tipo = ?, principal = ?, updated_at = NOW()
+      WHERE id = ? AND cliente_id = ?
+    `, [nome, rua, numero, complemento, bairro, cidade, estado, cep, tipo, is_default || 0, id, userId]);
 
-    // Simular exclus√£o por enquanto (retornar sucesso)
-    console.log('‚úÖ Conta banc√°ria exclu√≠da (simulado):', id);
-    res.json({
-      success: true,
-      message: 'Conta banc√°ria exclu√≠da com sucesso'
-    });
+    res.json({ success: true });
   } catch (error) {
-    console.error('‚ùå Erro ao excluir conta banc√°ria:', error);
-    res.status(500).json({ error: 'Erro ao excluir conta banc√°ria', details: error.message });
+    console.error('‚ùå Erro ao atualizar endere√ßo:', error);
+    res.status(500).json({ error: 'Erro interno' });
   }
 });
 
-// ==================== ENDPOINT PAGAMENTO DE CONTA ====================
-// Processar pagamento de transa√ß√£o com conta banc√°ria
-app.post('/api/financial/transactions/:id/pay', async (req, res) => {
+// Deletar endere√ßo
+app.delete('/api/customers/addresses/:id', async (req, res) => {
   try {
-    const { id } = req.params;
-    const { account_id, data_pagamento, observacoes } = req.body;
+    console.log('üè† DELETE /api/customers/addresses/' + req.params.id);
 
-    if (!account_id) {
-      return res.status(400).json({ error: 'account_id √© obrigat√≥rio' });
-    }
+    const { id } = req.params;
 
-    // Buscar transa√ß√£o
-    const [transactions] = await pool.execute(
-      'SELECT * FROM financial_transactions WHERE id = ?',
-      [id]
-    );
+    // Obter usu√°rio da sess√£o
+    let userId = null;
+    const sessionId = req.cookies?.session_id;
+    if (sessionId) {
+      try {
+        const [sessions] = await pool.execute('SELECT * FROM sessions WHERE id = ?', [sessionId]);
+        if (sessions && sessions[0] && sessions[0].user_email) {
+          const userEmail = sessions[0].user_email;
+          console.log('üë§ Usu√°rio logado via sess√£o:', userEmail);
 
-    if (transactions.length === 0) {
-      return res.status(404).json({ error: 'Transa√ß√£o n√£o encontrada' });
+          // Buscar o user_id na tabela customers baseado no email
+          const [customers] = await pool.execute('SELECT id FROM customers WHERE email = ?', [userEmail]);
+          if (customers && customers[0]) {
+            userId = customers[0].id;
+            console.log('‚úÖ User ID encontrado:', userId);
+          } else {
+            console.log('‚ö†Ô∏è Cliente n√£o encontrado para email:', userEmail);
+          }
+        }
+      } catch (e) {
+        console.log('‚ö†Ô∏è Erro ao verificar sess√£o:', e.message);
+      }
     }
 
-    const transaction = transactions[0];
+    // N√ÉO USAR FALLBACKS - Cada usu√°rio deve ter sua pr√≥pria sess√£o
 
-    // Verificar se j√° est√° paga
-    if (transaction.status === 'Pago') {
-      return res.status(400).json({ error: 'Esta transa√ß√£o j√° est√° paga' });
+    if (!userId) {
+      return res.status(401).json({ error: 'N√£o autorizado' });
     }
 
-    // Buscar conta banc√°ria (tentar banco primeiro, fallback para dados simulados)
-    let account = null;
+    // Deletar endere√ßo
+    await pool.execute('DELETE FROM enderecos WHERE id = ? AND cliente_id = ?', [id, userId]);
 
-    try {
-      const [accounts] = await pool.execute(
-        'SELECT * FROM financial_accounts WHERE id = ? AND status = ?',
-        [account_id, 'ativo']
-      );
+    res.json({ success: true });
+  } catch (error) {
+    console.error('‚ùå Erro ao deletar endere√ßo:', error);
+    res.status(500).json({ error: 'Erro interno' });
+  }
+});
 
-      if (accounts.length > 0) {
-        account = accounts[0];
-      }
-    } catch (dbError) {
-      // Se a tabela n√£o existir, usar dados simulados
-      if (dbError.code === 'ER_NO_SUCH_TABLE') {
-        console.log('‚ö†Ô∏è Tabela financial_accounts n√£o existe, usando dados simulados');
-      } else {
-        throw dbError;
-      }
-    }
+// ==================== ADDRESSES API (ENDERE√áOS M√öLTIPLOS) ====================
 
-    // Se n√£o encontrou no banco, usar dados simulados
-    if (!account) {
-      const contasSimuladas = [
-        {
-          id: 1,
-          nome: 'Conta Principal',
-          banco: 'Nubank',
-          agencia: '0001',
-          conta: '12345-6',
-          tipo: 'corrente',
-          saldo: 15000.50,
-          limite: 5000.00,
-          status: 'ativo',
-          ultima_movimentacao: '2024-10-18',
-          observacoes: 'Conta principal da empresa',
-          created_at: '2024-01-15',
-          updated_at: '2024-10-18'
-        },
-        {
-          id: 2,
-          nome: 'Conta Poupan√ßa',
-          banco: 'Banco do Brasil',
-          agencia: '1234',
-          conta: '98765-4',
-          tipo: 'poupanca',
-          saldo: 25000.00,
-          limite: 0.00,
-          status: 'ativo',
-          ultima_movimentacao: '2024-10-17',
-          observacoes: 'Reserva de emerg√™ncia',
-          created_at: '2024-02-01',
-          updated_at: '2024-10-17'
-        }
-      ];
+// Debug endpoint para testar conex√£o
 
-      account = contasSimuladas.find(c => c.id === parseInt(account_id) && c.status === 'ativo');
+// Listar endere√ßos do cliente
+app.get('/api/customers/:userId/addresses', async (req, res) => {
+  try {
+    let { userId } = req.params;
+    console.log(`üìç GET /api/customers/${userId}/addresses`);
 
-      if (!account) {
-        return res.status(404).json({ error: 'Conta banc√°ria n√£o encontrada ou inativa' });
+    // Se userId parece ser email, buscar o ID do usu√°rio
+    if (userId.includes('@')) {
+      try {
+        console.log(`üîç Buscando usu√°rio por email: ${userId}`);
+        const [user] = await pool.execute('SELECT id FROM users WHERE email = ?', [userId]);
+        if (user && user[0]) {
+          userId = user[0].id;
+          console.log(`‚úÖ Usu√°rio encontrado com ID: ${userId}`);
+        } else {
+          console.log(`‚ùå Usu√°rio n√£o encontrado para email: ${userId}`);
+          return res.status(404).json({ error: 'Usu√°rio n√£o encontrado', addresses: [] });
+        }
+      } catch (e) {
+        console.error('‚ö†Ô∏è Erro ao buscar usu√°rio por email:', e);
+        return res.status(500).json({ error: 'Erro ao buscar usu√°rio', details: e.message, addresses: [] });
       }
     }
 
-    // Verificar saldo para sa√≠das
-    if (transaction.tipo === 'saida') {
-      const saldoDisponivel = parseFloat(account.saldo) + (parseFloat(account.limite) || 0);
-      if (saldoDisponivel < parseFloat(transaction.valor)) {
-        return res.status(400).json({
-          error: `Saldo insuficiente. Saldo dispon√≠vel: R$ ${saldoDisponivel.toFixed(2)}`
-        });
-      }
-    }
+    // Debug: verificar banco atual
+    console.log(`üîç Verificando banco atual...`);
+    const [dbInfo] = await pool.execute('SELECT DATABASE() as current_db');
+    console.log(`üìç Banco atual: ${dbInfo[0].current_db}`);
 
-    // Iniciar transa√ß√£o do banco de dados
-    const connection = await pool.getConnection();
-    await connection.beginTransaction();
+    // Debug: listar tabelas
+    console.log(`üîç Listando tabelas...`);
+    const [tables] = await pool.execute('SHOW TABLES');
+    console.log(`üìã Tabelas encontradas:`, tables.map(t => Object.values(t)[0]));
 
-    try {
-      const dataPagamento = data_pagamento || new Date().toISOString().split('T')[0];
-
-      // 1. Atualizar status da transa√ß√£o
-      const observacoesCompletas = observacoes
-        ? `${transaction.observacoes || ''}\n\n[Pagamento realizado via ${account.nome} - ${account.banco} em ${dataPagamento}] ${observacoes}`.trim()
-        : `${transaction.observacoes || ''}\n\n[Pagamento realizado via ${account.nome} - ${account.banco} em ${dataPagamento}]`.trim();
-
-      await connection.execute(`
-        UPDATE financial_transactions 
-        SET status = 'Pago',
-            data = ?,
-            metodo_pagamento = ?,
-            observacoes = ?,
-            updated_at = NOW()
-        WHERE id = ?
-      `, [
-        dataPagamento,
-        `Conta: ${account.nome} (${account.banco})`,
-        observacoesCompletas,
-        id
-      ]);
+    // Buscar endere√ßos
+    console.log(`üîç Buscando endere√ßos para userId: ${userId}`);
+    const [addresses] = await pool.execute(`
+      SELECT id, nome as label, cep, logradouro as endereco, numero, complemento, bairro, cidade, estado, principal as is_default, created_at, updated_at
+      FROM enderecos
+      WHERE cliente_id = ?
+      ORDER BY principal DESC, created_at DESC
+    `, [userId]);
 
-      // 2. Atualizar saldo da conta banc√°ria (apenas se tabela existir)
-      let novoSaldo;
-      if (transaction.tipo === 'saida') {
-        novoSaldo = parseFloat(account.saldo) - parseFloat(transaction.valor);
-      } else {
-        novoSaldo = parseFloat(account.saldo) + parseFloat(transaction.valor);
-      }
+    console.log(`‚úÖ Encontrados ${addresses.length} endere√ßos`);
+    res.json({ addresses: addresses || [] });
+  } catch (error) {
+    console.error('‚ùå Erro ao buscar endere√ßos:', error);
+    logger.logError(error, req);
+    res.status(500).json({
+      error: 'Erro ao buscar endere√ßos',
+      details: error.message,
+      addresses: [] // Sempre retornar array vazio em caso de erro
+    });
+  }
+});
 
-      // Tentar atualizar no banco, mas ignorar se tabela n√£o existir
-      try {
-        await connection.execute(`
-          UPDATE financial_accounts 
-          SET saldo = ?,
-              ultima_movimentacao = ?,
-              updated_at = NOW()
-          WHERE id = ?
-        `, [novoSaldo, dataPagamento, account_id]);
-      } catch (updateError) {
-        if (updateError.code !== 'ER_NO_SUCH_TABLE') {
-          throw updateError;
-        }
-        console.warn('‚ö†Ô∏è Tabela financial_accounts n√£o encontrada, saldo n√£o ser√° atualizado no banco (usando dados simulados)');
-      }
+// Criar novo endere√ßo
+app.post('/api/customers/:userId/addresses', async (req, res) => {
+  try {
+    let { userId } = req.params;
+    console.log(`üîç POST /api/customers/${userId}/addresses - Iniciando...`);
 
-      // 3. Criar registro de pagamento (se tabela existir)
+    // Se userId parece ser email, buscar o ID do usu√°rio
+    if (userId.includes('@')) {
       try {
-        await connection.execute(`
-          INSERT INTO financial_payments (
-            transaction_id, account_id, valor, data_pagamento, tipo, observacoes, created_at
-          ) VALUES (?, ?, ?, ?, ?, ?, NOW())
-        `, [
-          id,
-          account_id,
-          transaction.valor,
-          dataPagamento,
-          transaction.tipo,
-          observacoes || null
-        ]);
+        console.log(`üîç Buscando usu√°rio por email: ${userId}`);
+        const [user] = await pool.execute('SELECT id FROM users WHERE email = ?', [userId]);
+        if (user && user[0]) {
+          userId = user[0].id;
+          console.log(`‚úÖ Usu√°rio encontrado: ${userId}`);
+        } else {
+          console.log(`‚ùå Usu√°rio n√£o encontrado para email: ${userId}`);
+          return res.status(404).json({ error: 'Usu√°rio n√£o encontrado' });
+        }
       } catch (e) {
-        // Ignorar se tabela n√£o existir
-        console.warn('‚ö†Ô∏è Tabela financial_payments n√£o encontrada, pulando registro de pagamento');
+        console.log('‚ö†Ô∏è Erro ao buscar usu√°rio por email:', e.message);
+        return res.status(500).json({ error: 'Erro ao buscar usu√°rio' });
       }
+    }
 
-      // Confirmar transa√ß√£o
-      await connection.commit();
-      connection.release();
+    const { label, cep, endereco, numero, complemento, bairro, cidade, estado, is_default } = req.body;
+    const id = crypto.randomUUID();
 
-      console.log(`‚úÖ Pagamento processado: Transa√ß√£o ${id} paga via conta ${account.nome}`);
+    console.log(`üìù Dados do endere√ßo:`, { label, cep, endereco, numero, complemento, bairro, cidade, estado, is_default });
 
-      res.json({
-        success: true,
-        message: 'Pagamento processado com sucesso',
-        transaction: {
-          id: parseInt(id),
-          status: 'Pago',
-          data: dataPagamento
-        },
-        account: {
-          id: account.id,
-          nome: account.nome,
-          novo_saldo: novoSaldo
-        }
-      });
-    } catch (error) {
-      await connection.rollback();
-      connection.release();
-      throw error;
-    }
-  } catch (error) {
-    console.error('‚ùå Erro ao processar pagamento:', error);
-    res.status(500).json({
-      error: 'Erro ao processar pagamento',
-      details: error?.message || 'Erro desconhecido'
-    });
-  }
-});
+    // Verificar banco atual
+    try {
+      const [db] = await pool.execute('SELECT DATABASE() as current_db');
+      console.log(`üìç Banco atual: ${db[0].current_db}`);
+    } catch (e) {
+      console.log('‚ö†Ô∏è Erro ao verificar banco:', e.message);
+    }
 
-// ==================== ENDPOINTS CART√ïES ====================
+    // Tabela existe e est√° acess√≠vel
+    console.log(`‚úÖ Tentando inserir endere√ßo...`);
 
-// Buscar todos os cart√µes
-app.get('/api/financial/cartoes', async (req, res) => {
-  try {
-    // Retornar dados simulados temporariamente para testar o frontend
-    const cartoesSimulados = [
-      {
-        id: 1,
-        nome: 'Cart√£o Principal',
-        numero: '**** **** **** 1234',
-        bandeira: 'Visa',
-        limite: 10000.00,
-        fatura_atual: 3500.75,
-        vencimento: '2024-11-15',
-        status: 'ativo',
-        tipo: 'credito',
-        observacoes: 'Cart√£o principal da empresa',
-        created_at: '2024-01-15',
-        updated_at: '2024-10-18'
-      },
-      {
-        id: 2,
-        nome: 'Cart√£o de D√©bito',
-        numero: '**** **** **** 5678',
-        bandeira: 'Mastercard',
-        limite: 0.00,
-        fatura_atual: 0.00,
-        vencimento: '2026-12-31',
-        status: 'ativo',
-        tipo: 'debito',
-        observacoes: 'Vinculado √† conta principal',
-        created_at: '2024-03-01',
-        updated_at: '2024-10-18'
-      }
-    ];
+    // Inserir endere√ßo
+    console.log(`üíæ Inserindo novo endere√ßo...`);
+    await pool.execute(`
+      INSERT INTO enderecos (id, cliente_id, tipo, nome, logradouro, numero, complemento, bairro, cidade, estado, cep, principal)
+      VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
+    `, [id, userId, label.toLowerCase(), label, endereco, numero, complemento || null, bairro, cidade, estado, cep, is_default ? 1 : 0]);
+
+    // Se for padr√£o, remover padr√£o dos outros
+    if (is_default) {
+      console.log(`üîÑ Removendo padr√£o dos outros endere√ßos...`);
+      await pool.execute('UPDATE enderecos SET principal = 0 WHERE cliente_id = ? AND id != ?', [userId, id]);
+    }
 
-    console.log('‚úÖ Cart√µes carregados (simulados):', cartoesSimulados.length);
-    res.json({ cartoes: cartoesSimulados, total: cartoesSimulados.length });
+    console.log(`‚úÖ Endere√ßo criado para user_id=${userId}, address_id=${id}`);
+    res.json({ success: true, id });
   } catch (error) {
-    console.error('‚ùå Erro ao buscar cart√µes:', error);
-    res.status(500).json({ error: 'Erro ao buscar cart√µes', details: error.message });
+    console.error('‚ùå Erro ao criar endere√ßo:', error);
+    res.status(500).json({ error: 'Erro ao criar endere√ßo' });
   }
 });
 
-// Criar cart√£o
-app.post('/api/financial/financial_cards', async (req, res) => {
+// Atualizar endere√ßo
+app.put('/api/customers/:userId/addresses/:addressId', async (req, res) => {
   try {
-    const { nome, numero, bandeira, limite, fatura_atual, vencimento, status, tipo, observacoes } = req.body;
+    let { userId, addressId } = req.params;
 
-    if (!nome || !numero || !bandeira) {
-      return res.status(400).json({ error: 'Campos obrigat√≥rios: nome, numero, bandeira' });
+    // Converter email para userId se necess√°rio
+    if (userId.includes('@')) {
+      const [user] = await pool.execute('SELECT id FROM users WHERE email = ?', [userId]);
+      if (user && user[0]) userId = user[0].id;
+      else return res.status(404).json({ error: 'Usu√°rio n√£o encontrado' });
     }
 
-    const [result] = await pool.execute(`
-      INSERT INTO financial_cards (
-        nome, numero, bandeira, limite, fatura_atual, vencimento, status, tipo, observacoes
-      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
-    `, [nome, numero, bandeira, limite || 0, fatura_atual || 0, vencimento, status || 'ativo', tipo || 'credito', observacoes || '']);
+    const { label, cep, endereco, numero, complemento, bairro, cidade, estado, is_default } = req.body;
 
-    const insertedId = result.insertId;
-    console.log('‚úÖ Cart√£o criado:', insertedId);
+    if (is_default) {
+      await pool.execute('UPDATE enderecos SET principal = 0 WHERE cliente_id = ?', [userId]);
+    }
 
-    res.json({
-      success: true,
-      message: 'Cart√£o criado com sucesso',
-      cartao: { id: insertedId, nome, numero, bandeira, limite, fatura_atual, vencimento, status, tipo, observacoes }
-    });
+    await pool.execute(`
+      UPDATE enderecos
+      SET tipo = ?, nome = ?, cep = ?, logradouro = ?, numero = ?, complemento = ?, bairro = ?, cidade = ?, estado = ?, principal = ?, updated_at = NOW()
+      WHERE id = ? AND cliente_id = ?
+    `, [label.toLowerCase(), label, cep, endereco, numero, complemento || null, bairro, cidade, estado, is_default ? 1 : 0, addressId, userId]);
+
+    console.log(`‚úÖ Endere√ßo ${addressId} atualizado para user_id=${userId}`);
+    res.json({ success: true });
   } catch (error) {
-    console.error('‚ùå Erro ao criar cart√£o:', error);
-    res.status(500).json({ error: 'Erro ao criar cart√£o', details: error.message });
+    console.error('Erro ao atualizar endere√ßo:', error);
+    res.status(500).json({ error: 'Erro ao atualizar endere√ßo' });
   }
 });
 
-// Atualizar cart√£o
-app.put('/api/financial/financial_cards/:id', async (req, res) => {
+// Deletar endere√ßo
+app.delete('/api/customers/:userId/addresses/:addressId', async (req, res) => {
   try {
-    const { id } = req.params;
-    const { nome, numero, bandeira, limite, fatura_atual, vencimento, status, tipo, observacoes } = req.body;
+    let { userId, addressId } = req.params;
 
-    if (!nome || !numero || !bandeira) {
-      return res.status(400).json({ error: 'Campos obrigat√≥rios: nome, numero, bandeira' });
+    // Converter email para userId se necess√°rio
+    if (userId.includes('@')) {
+      const [user] = await pool.execute('SELECT id FROM users WHERE email = ?', [userId]);
+      if (user && user[0]) userId = user[0].id;
+      else return res.status(404).json({ error: 'Usu√°rio n√£o encontrado' });
     }
 
-    const [result] = await pool.execute(`
-      UPDATE financial_cards 
-      SET nome = ?, numero = ?, bandeira = ?, limite = ?, fatura_atual = ?, vencimento = ?, status = ?, tipo = ?, observacoes = ?, updated_at = NOW()
-      WHERE id = ?
-    `, [nome, numero, bandeira, limite || 0, fatura_atual || 0, vencimento, status, tipo, observacoes || '', id]);
-
-    if (result.affectedRows === 0) {
-      return res.status(404).json({ error: 'Cart√£o n√£o encontrado' });
-    }
+    await pool.execute('DELETE FROM enderecos WHERE id = ? AND cliente_id = ?', [addressId, userId]);
 
-    console.log('‚úÖ Cart√£o atualizado:', id);
-    res.json({
-      success: true,
-      message: 'Cart√£o atualizado com sucesso',
-      cartao: { id, nome, numero, bandeira, limite, fatura_atual, vencimento, status, tipo, observacoes }
-    });
+    console.log(`‚úÖ Endere√ßo ${addressId} deletado para user_id=${userId}`);
+    res.json({ success: true });
   } catch (error) {
-    console.error('‚ùå Erro ao atualizar cart√£o:', error);
-    res.status(500).json({ error: 'Erro ao atualizar cart√£o', details: error.message });
+    console.error('Erro ao deletar endere√ßo:', error);
+    res.status(500).json({ error: 'Erro ao deletar endere√ßo' });
   }
 });
 
-// Excluir cart√£o
-app.delete('/api/financial/cartoes/:id', async (req, res) => {
+// Definir endere√ßo como padr√£o
+app.patch('/api/customers/:userId/addresses/:addressId/set-default', async (req, res) => {
   try {
-    const { id } = req.params;
+    let { userId, addressId } = req.params;
 
-    // Simular exclus√£o por enquanto (retornar sucesso)
-    console.log('‚úÖ Cart√£o exclu√≠do (simulado):', id);
-    res.json({
-      success: true,
-      message: 'Cart√£o exclu√≠do com sucesso'
-    });
-  } catch (error) {
-    console.error('‚ùå Erro ao excluir cart√£o:', error);
-    res.status(500).json({ error: 'Erro ao excluir cart√£o', details: error.message });
-  }
-});
+    // Converter email para userId se necess√°rio
+    if (userId.includes('@')) {
+      const [user] = await pool.execute('SELECT id FROM users WHERE email = ?', [userId]);
+      if (user && user[0]) userId = user[0].id;
+      else return res.status(404).json({ error: 'Usu√°rio n√£o encontrado' });
+    }
 
-// Criar tabela de transa√ß√µes financeiras se n√£o existir
-// ENDPOINT DESABILITADO - Tabela financial_transactions agora usa UUID como PK
-// app.post('/api/financial/setup', async (req, res) => {
-//   try {
-//     await pool.execute(`
-//       CREATE TABLE IF NOT EXISTS financial_transactions (
-//         id INT AUTO_INCREMENT PRIMARY KEY,
-//         data DATE NOT NULL,
-//         descricao VARCHAR(255) NOT NULL,
-//         categoria VARCHAR(100) NOT NULL,
-//         tipo ENUM('Entrada', 'Sa√≠da') NOT NULL,
-//         valor DECIMAL(10,2) NOT NULL,
-//         status ENUM('Pago', 'Pendente', 'Atrasado') DEFAULT 'Pendente',
-//         metodo_pagamento VARCHAR(50),
-//         origem VARCHAR(255),
-//         observacoes TEXT,
-//         created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
-//         updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
-//       ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci
-//     `);
-
-//     // Criar tabela de transa√ß√µes de fornecedores
-//     await pool.execute(`
-//       CREATE TABLE IF NOT EXISTS supplier_transactions (
-//         id INT AUTO_INCREMENT PRIMARY KEY,
-//         supplier_id VARCHAR(100) NOT NULL,
-//         data DATE NOT NULL,
-//         descricao VARCHAR(500) NOT NULL,
-//         valor DECIMAL(10,2) NOT NULL,
-//         tipo ENUM('compra', 'pagamento', 'devolucao', 'desconto') NOT NULL,
-//         status ENUM('pendente', 'pago', 'atrasado', 'cancelado') NOT NULL,
-//         forma_pagamento VARCHAR(100),
-//         observacoes TEXT,
-//         created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
-//         updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
-//         INDEX idx_supplier_id (supplier_id),
-//         INDEX idx_data (data)
-//       ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci
-//     `);
-//     
-//     // Criar tabela de pagamentos de fornecedores
-//     await pool.execute(`
-//       CREATE TABLE IF NOT EXISTS supplier_payments (
-//         id INT AUTO_INCREMENT PRIMARY KEY,
-//         supplier_id VARCHAR(100) NOT NULL,
-//         data_vencimento DATE NOT NULL,
-//         data_pagamento DATE,
-//         valor DECIMAL(10,2) NOT NULL,
-//         status ENUM('pendente', 'pago', 'atrasado') NOT NULL,
-//         forma_pagamento VARCHAR(100),
-//         observacoes TEXT,
-//         created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
-//         updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
-//         INDEX idx_supplier_id (supplier_id),
-//         INDEX idx_vencimento (data_vencimento),
-//         INDEX idx_status (status)
-//       ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci
-//     `);
-// 
-//     logger.info('Tabelas financeiras criadas/verificadas');
-//     res.json({ success: true, message: 'Tabelas financeiras configuradas' });
-//   } catch (error) {
-//     logger.logError(error, req);
-//     res.status(500).json({ error: 'Erro ao configurar tabelas financeiras' });
-//   }
-// });
-
-// Rotas para transa√ß√µes de fornecedores
-app.get('/api/financial/suppliers/:id/transactions', async (req, res) => {
-  try {
-    const { id } = req.params;
-    const [rows] = await pool.execute(
-      'SELECT * FROM supplier_transactions WHERE supplier_id = ? ORDER BY data DESC',
-      [id]
-    );
-    res.json(rows);
+    await pool.execute('UPDATE enderecos SET principal = 0 WHERE cliente_id = ?', [userId]);
+    await pool.execute('UPDATE enderecos SET principal = 1 WHERE id = ? AND cliente_id = ?', [addressId, userId]);
+
+    console.log(`‚úÖ Endere√ßo ${addressId} definido como padr√£o para user_id=${userId}`);
+    res.json({ success: true });
   } catch (error) {
-    logger.logError(error, req);
-    res.status(500).json({ error: 'Erro ao buscar transa√ß√µes do fornecedor' });
+    console.error('Erro ao definir endere√ßo padr√£o:', error);
+    res.status(500).json({ error: 'Erro ao definir endere√ßo padr√£o' });
   }
 });
 
-app.post('/api/financial/suppliers/:id/transactions', async (req, res) => {
+// ==================== FAVORITES/WISHLIST API ====================
+
+// Listar favoritos do cliente
+app.get('/api/customers/:userId/favorites', async (req, res) => {
   try {
-    const { id } = req.params;
-    const { data, descricao, valor, tipo, status, forma_pagamento, observacoes } = req.body;
+    const { userId } = req.params;
 
-    const [result] = await pool.execute(
-      'INSERT INTO supplier_transactions (supplier_id, data, descricao, valor, tipo, status, forma_pagamento, observacoes) VALUES (?, ?, ?, ?, ?, ?, ?, ?)',
-      [id, data, descricao, valor, tipo, status || 'pendente', forma_pagamento || null, observacoes || null]
-    );
+    // Buscar email do usu√°rio
+    const [userEmail] = await pool.execute('SELECT email FROM users WHERE id = ?', [userId]);
+    const email = userEmail[0]?.email || null;
 
-    res.json({ success: true, id: result.insertId, message: 'Transa√ß√£o criada com sucesso' });
-  } catch (error) {
-    logger.logError(error, req);
-    res.status(500).json({ error: 'Erro ao criar transa√ß√£o do fornecedor' });
-  }
-});
+    if (!email) {
+      return res.json({ favorites: [] });
+    }
 
-// Rotas para pagamentos de fornecedores
-app.get('/api/financial/suppliers/:id/payments', async (req, res) => {
-  try {
-    const { id } = req.params;
-    const [rows] = await pool.execute(
-      'SELECT * FROM supplier_payments WHERE supplier_id = ? ORDER BY data_vencimento DESC',
-      [id]
-    );
-    res.json(rows);
+    const [favorites] = await pool.execute(`
+      SELECT p.*
+      FROM favorites f
+      JOIN products p ON f.product_id = p.id
+      WHERE f.user_email = ?
+      ORDER BY f.created_at DESC
+    `, [email]);
+
+    res.json({ favorites });
   } catch (error) {
     logger.logError(error, req);
-    res.status(500).json({ error: 'Erro ao buscar pagamentos do fornecedor' });
+    res.status(500).json({ error: 'Erro ao buscar favoritos' });
   }
 });
 
-app.post('/api/financial/suppliers/:id/payments', async (req, res) => {
+// Adicionar aos favoritos
+app.post('/api/customers/:userId/favorites/:productId', async (req, res) => {
   try {
-    const { id } = req.params;
-    const { data_vencimento, data_pagamento, valor, status, forma_pagamento, observacoes } = req.body;
+    const { userId, productId } = req.params;
 
-    const [result] = await pool.execute(
-      'INSERT INTO supplier_payments (supplier_id, data_vencimento, data_pagamento, valor, status, forma_pagamento, observacoes) VALUES (?, ?, ?, ?, ?, ?, ?)',
-      [id, data_vencimento, data_pagamento || null, valor, status || 'pendente', forma_pagamento || null, observacoes || null]
-    );
+    // Buscar email do usu√°rio
+    const [userEmail] = await pool.execute('SELECT email FROM users WHERE id = ?', [userId]);
+    const email = userEmail[0]?.email || null;
+
+    if (!email) {
+      return res.status(400).json({ error: 'Usu√°rio n√£o encontrado' });
+    }
+
+    const id = crypto.randomUUID();
+
+    await pool.execute(`
+      INSERT IGNORE INTO favorites (id, user_email, product_id)
+      VALUES (?, ?, ?)
+    `, [id, email, productId]);
 
-    res.json({ success: true, id: result.insertId, message: 'Pagamento registrado com sucesso' });
+    res.json({ success: true });
   } catch (error) {
     logger.logError(error, req);
-    res.status(500).json({ error: 'Erro ao registrar pagamento do fornecedor' });
+    res.status(500).json({ error: 'Erro ao adicionar favorito' });
   }
 });
 
-// Rota para zerar despesas de todos os fornecedores
-app.post('/api/financial/suppliers/reset-expenses', async (req, res) => {
+// Remover dos favoritos
+app.delete('/api/customers/:userId/favorites/:productId', async (req, res) => {
   try {
-    console.log('üîÑ Zerando despesas de fornecedores...');
+    const { userId, productId } = req.params;
 
-    // Zerar todas as despesas dos fornecedores diretamente na tabela fornecedores
-    await pool.execute(`
-      UPDATE fornecedores 
-      SET total_expenses = 0, 
-          updated_at = NOW()
-    `);
+    // Buscar email do usu√°rio
+    const [userEmail] = await pool.execute('SELECT email FROM users WHERE id = ?', [userId]);
+    const email = userEmail[0]?.email || null;
 
-    // Limpar transa√ß√µes financeiras relacionadas a fornecedores (se existirem)
-    try {
-      await pool.execute(`
-        DELETE FROM financial_transactions 
-        WHERE tipo = 'saida' 
-        AND (origem LIKE '%fornecedor%' OR origem LIKE '%supplier%')
-      `);
-    } catch (error) {
-      console.log('‚ö†Ô∏è Aviso: N√£o foi poss√≠vel limpar transa√ß√µes financeiras:', error.message);
+    if (!email) {
+      return res.status(400).json({ error: 'Usu√°rio n√£o encontrado' });
     }
 
-    console.log('‚úÖ Despesas de fornecedores zeradas com sucesso');
-    logger.info('Despesas de fornecedores zeradas');
+    await pool.execute('DELETE FROM favorites WHERE user_email = ? AND product_id = ?', [email, productId]);
 
-    res.json({
-      success: true,
-      message: 'Despesas de fornecedores zeradas com sucesso',
-      timestamp: new Date().toISOString()
-    });
+    res.json({ success: true });
   } catch (error) {
-    console.error('‚ùå ERRO ao zerar despesas:', error);
-    logger.error('Erro ao zerar despesas de fornecedores', { error: error.message });
-    res.status(500).json({
-      success: false,
-      error: 'Erro interno do servidor',
-      details: error.message
-    });
+    logger.logError(error, req);
+    res.status(500).json({ error: 'Erro ao remover favorito' });
   }
 });
 
-// Rotas duplicadas REMOVIDAS - usar as rotas principais acima (linhas 9064-9152)
+// ==================== REVIEWS API ====================
 
-// Rotas para gest√£o de valores financeiros
-app.get('/api/financial/values', async (req, res) => {
+// Listar reviews de um produto
+app.get('/api/products/:productId/reviews', async (req, res) => {
   try {
-    console.log('üîç Buscando valores financeiros...');
-
-    // Buscar valores da tabela de configura√ß√µes financeiras
-    const [rows] = await pool.execute(`
-      SELECT * FROM financial_values 
-      ORDER BY created_at DESC 
-      LIMIT 1
-    `);
-
-    if (rows.length === 0) {
-      // Se n√£o existir, retornar valores calculados
-      const [orders] = await pool.execute(`
-        SELECT SUM(total) as total FROM orders WHERE payment_status = 'paid'
-      `);
-      const [events] = await pool.execute(`
-        SELECT SUM(renda_total) as total FROM events WHERE renda_total IS NOT NULL
-      `);
-      const [suppliers] = await pool.execute(`
-        SELECT SUM(total_expenses) as total FROM suppliers WHERE total_expenses IS NOT NULL
-      `);
-
-      const revenue = (orders[0]?.total || 0) + (events[0]?.total || 0);
-      const expenses = suppliers[0]?.total || 0;
-      const profit = revenue - expenses;
-      const balance = profit * 1.2;
+    const { productId } = req.params;
+    const [reviews] = await pool.execute(`
+      SELECT 
+        r.*,
+        u.nome as user_name,
+        u.avatar_url as user_avatar,
+        EXISTS(SELECT 1 FROM orders o JOIN order_items oi ON o.id = oi.order_id WHERE o.user_id = r.user_id AND oi.product_id = r.product_id AND o.status = 'delivered') as verified_purchase
+      FROM product_reviews r
+      LEFT JOIN users u ON r.user_id = u.id
+      WHERE r.product_id = ?
+      ORDER BY r.created_at DESC
+    `, [productId]);
 
-      res.json({
-        totalRevenue: revenue,
-        totalExpenses: expenses,
-        netProfit: profit,
-        projectedBalance: balance,
-        isOverridden: false
-      });
-    } else {
-      res.json({
-        totalRevenue: rows[0].total_revenue,
-        totalExpenses: rows[0].total_expenses,
-        netProfit: rows[0].net_profit,
-        projectedBalance: rows[0].projected_balance,
-        isOverridden: rows[0].is_overridden === 1
-      });
-    }
+    res.json({ reviews });
   } catch (error) {
-    console.error('‚ùå ERRO ao buscar valores financeiros:', error);
-    res.status(500).json({ error: 'Erro ao buscar valores financeiros' });
+    logger.logError(error, req);
+    res.status(500).json({ error: 'Erro ao buscar avalia√ß√µes' });
   }
 });
 
-app.put('/api/financial/values', async (req, res) => {
+// Criar review
+app.post('/api/products/:productId/reviews', async (req, res) => {
   try {
-    const { totalRevenue, totalExpenses, netProfit, projectedBalance } = req.body;
-
-    console.log('üíæ Atualizando valores financeiros:', { totalRevenue, totalExpenses, netProfit, projectedBalance });
-
-    // Verificar se j√° existe registro
-    const [existing] = await pool.execute(`
-      SELECT id FROM financial_values 
-      ORDER BY created_at DESC 
-      LIMIT 1
-    `);
+    const { productId } = req.params;
+    const { rating, comment, user_id } = req.body;
+    const id = crypto.randomUUID();
 
-    if (existing.length > 0) {
-      // Atualizar registro existente
-      await pool.execute(`
-        UPDATE financial_values 
-        SET total_revenue = ?, total_expenses = ?, net_profit = ?, 
-            projected_balance = ?, is_overridden = 1, updated_at = ?
-        WHERE id = ?
-      `, [
-        totalRevenue, totalExpenses, netProfit, projectedBalance,
-        new Date().toISOString(), existing[0].id
-      ]);
-    } else {
-      // Criar novo registro
-      const id = crypto.randomUUID();
-      await pool.execute(`
-        INSERT INTO financial_values (
-          id, total_revenue, total_expenses, net_profit, projected_balance, 
-          is_overridden, created_at, updated_at
-        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?)
-      `, [
-        id, totalRevenue, totalExpenses, netProfit, projectedBalance,
-        1, new Date().toISOString(), new Date().toISOString()
-      ]);
-    }
+    await pool.execute(`
+      INSERT INTO product_reviews (id, product_id, user_id, rating, comment)
+      VALUES (?, ?, ?, ?, ?)
+    `, [id, productId, user_id, rating, comment]);
 
-    console.log('‚úÖ Valores financeiros atualizados com sucesso');
-    res.json({
-      success: true,
-      message: 'Valores financeiros atualizados com sucesso'
-    });
+    logger.info('Review criado', { productId, userId: user_id, rating });
+    res.json({ success: true, id });
   } catch (error) {
-    console.error('‚ùå ERRO ao atualizar valores financeiros:', error);
-    res.status(500).json({ error: 'Erro ao atualizar valores financeiros', details: error.message });
+    logger.logError(error, req);
+    res.status(500).json({ error: 'Erro ao criar avalia√ß√£o' });
   }
 });
 
-app.post('/api/financial/values/reset', async (req, res) => {
-  try {
-    console.log('üîÑ Resetando valores financeiros para calculados...');
 
-    // Calcular valores baseados nos dados reais
-    const [orders] = await pool.execute(`
-      SELECT SUM(total) as total FROM orders WHERE payment_status = 'paid'
-    `);
-    const [events] = await pool.execute(`
-      SELECT SUM(renda_total) as total FROM events WHERE renda_total IS NOT NULL
-    `);
-    const [suppliers] = await pool.execute(`
-      SELECT SUM(total_expenses) as total FROM suppliers WHERE total_expenses IS NOT NULL
-    `);
 
-    const revenue = (orders[0]?.total || 0) + (events[0]?.total || 0);
-    const expenses = suppliers[0]?.total || 0;
-    const profit = revenue - expenses;
-    const balance = profit * 1.2;
+// ==================== REVIEWS API AVAN√áADO ====================
 
-    // Atualizar ou criar registro
-    const [existing] = await pool.execute(`
-      SELECT id FROM financial_values 
-      ORDER BY created_at DESC 
-      LIMIT 1
-    `);
+// Estat√≠sticas de reviews de um produto
+app.get('/api/products/:productId/reviews/stats', async (req, res) => {
+  try {
+    const { productId } = req.params;
 
-    if (existing.length > 0) {
-      await pool.execute(`
-        UPDATE financial_values 
-        SET total_revenue = ?, total_expenses = ?, net_profit = ?, 
-            projected_balance = ?, is_overridden = 0, updated_at = ?
-        WHERE id = ?
-      `, [
-        revenue, expenses, profit, balance,
-        new Date().toISOString(), existing[0].id
-      ]);
-    } else {
-      const id = crypto.randomUUID();
-      await pool.execute(`
-        INSERT INTO financial_values (
-          id, total_revenue, total_expenses, net_profit, projected_balance, 
-          is_overridden, created_at, updated_at
-        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?)
-      `, [
-        id, revenue, expenses, profit, balance,
-        0, new Date().toISOString(), new Date().toISOString()
-      ]);
-    }
+    const [stats] = await pool.execute(`
+      SELECT 
+        COUNT(*) as total_reviews,
+        AVG(rating) as avg_rating,
+        SUM(CASE WHEN rating = 5 THEN 1 ELSE 0 END) as rating_5,
+        SUM(CASE WHEN rating = 4 THEN 1 ELSE 0 END) as rating_4,
+        SUM(CASE WHEN rating = 3 THEN 1 ELSE 0 END) as rating_3,
+        SUM(CASE WHEN rating = 2 THEN 1 ELSE 0 END) as rating_2,
+        SUM(CASE WHEN rating = 1 THEN 1 ELSE 0 END) as rating_1,
+        SUM(CASE WHEN verified_purchase = 1 THEN 1 ELSE 0 END) as verified_purchases
+      FROM product_reviews
+      WHERE product_id = ? AND status = 'approved'
+    `, [productId]);
 
-    console.log('‚úÖ Valores financeiros resetados com sucesso');
-    res.json({
-      success: true,
-      message: 'Valores resetados para os calculados automaticamente',
-      values: { totalRevenue: revenue, totalExpenses: expenses, netProfit: profit, projectedBalance: balance }
-    });
+    res.json(stats[0] || {});
   } catch (error) {
-    console.error('‚ùå ERRO ao resetar valores financeiros:', error);
-    res.status(500).json({ error: 'Erro ao resetar valores financeiros', details: error.message });
+    logger.logError(error, req);
+    res.status(500).json({ error: 'Erro ao buscar estat√≠sticas' });
   }
 });
 
-// Rota para atualizar limite de cr√©dito (simulada)
-app.put('/api/financial/suppliers/:id/credit-limit', async (req, res) => {
+// Curtir review (com tracking)
+app.post('/api/reviews/:reviewId/like', async (req, res) => {
   try {
-    const { id } = req.params;
-    const { limiteCredito } = req.body;
+    const { reviewId } = req.params;
+    const { user_id } = req.body;
+    const voteId = crypto.randomUUID();
+
+    // Inserir ou atualizar like
+    await pool.execute(`
+      INSERT INTO review_votes (id, review_id, user_id, vote_type)
+      VALUES (?, ?, ?, 'like')
+      ON DUPLICATE KEY UPDATE vote_type = 'like'
+    `, [voteId, reviewId, user_id]);
+
+    // Recalcular likes
+    const [votes] = await pool.execute(`
+      SELECT COUNT(*) as likes
+      FROM review_votes
+      WHERE review_id = ? AND vote_type = 'like'
+    `, [reviewId]);
 
-    // Simular atualiza√ß√£o - em produ√ß√£o, isso seria salvo em uma tabela de configura√ß√µes
-    console.log(`Atualizando limite de cr√©dito do fornecedor ${id} para R$ ${limiteCredito}`);
+    await pool.execute(`
+      UPDATE product_reviews
+      SET likes = ?
+      WHERE id = ?
+    `, [votes[0].likes, reviewId]);
 
-    res.json({ success: true, message: 'Limite de cr√©dito atualizado com sucesso' });
+    logger.info('Review curtido', { reviewId, userId: user_id });
+    res.json({ success: true, likes: votes[0].likes });
   } catch (error) {
     logger.logError(error, req);
-    res.status(500).json({ error: 'Erro ao atualizar limite de cr√©dito' });
+    res.status(500).json({ error: 'Erro ao curtir review' });
   }
 });
 
-// =====================================
-// Rotas de Estat√≠sticas do Usu√°rio
-// =====================================
-// app.use('/api/user-stats', require('./routes/user-stats')); // Comentado temporariamente devido a erro ES module
-
-// =====================================
-// Sincroniza√ß√£o de Carrinho
-// =====================================
-app.post('/api/cart/sync', async (req, res) => {
+// Votar em review (Generic Vote)
+app.post('/api/reviews/:reviewId/vote', async (req, res) => {
   try {
-    const sessionId = req.cookies?.session_id;
-    if (!sessionId) {
-      return res.status(400).json({ error: 'Sess√£o n√£o encontrada' });
-    }
-
-    // Buscar usu√°rio da sess√£o
-    const [session] = await pool.execute('SELECT user_email FROM sessions WHERE id = ?', [sessionId]);
-    if (!session || !session[0]) {
-      return res.status(401).json({ error: 'Sess√£o inv√°lida' });
-    }
-
-    const userEmail = session[0].user_email;
-    const [users] = await pool.execute('SELECT id FROM customers WHERE email = ?', [userEmail]);
-    if (!users || !users[0]) {
-      return res.status(404).json({ error: 'Usu√°rio n√£o encontrado' });
-    }
-
-    const userId = users[0].id;
-    const cartId = getOrCreateCartId(req, res);
+    const { reviewId } = req.params;
+    const { user_id, vote_type } = req.body;
+    const voteId = crypto.randomUUID();
 
-    // Associar carrinho ao usu√°rio
-    await pool.execute('UPDATE carts SET user_id = ? WHERE id = ?', [userId, cartId]);
+    // Inserir ou atualizar voto
+    await pool.execute(`
+      INSERT INTO review_votes (id, review_id, user_id, vote_type)
+      VALUES (?, ?, ?, ?)
+      ON DUPLICATE KEY UPDATE vote_type = VALUES(vote_type)
+    `, [voteId, reviewId, user_id, vote_type]);
 
-    res.json({ success: true, message: 'Carrinho sincronizado com sucesso' });
+    logger.info('Voto registrado', { reviewId, voteType: vote_type });
+    res.json({ success: true });
   } catch (error) {
-    console.error('Erro ao sincronizar carrinho:', error);
-    res.status(500).json({ error: 'Erro interno do servidor' });
+    logger.logError(error, req);
+    res.status(500).json({ error: 'Erro ao votar' });
   }
 });
 
-// =====================================
-// Buscar cliente por email
-// =====================================
-app.get('/api/customers/by-email/:email', async (req, res) => {
-  try {
-    const { email } = req.params;
-    const mail = String(email || '').trim().toLowerCase();
+// ==================== ADMIN REVIEWS API ====================
 
-    // Tentar em customers
-    let [customers] = await pool.execute('SELECT * FROM customers WHERE email = ? LIMIT 1', [mail]);
-    if (Array.isArray(customers) && customers[0]) {
-      return res.json(customers[0]);
-    }
+// Listar reviews pendentes (modera√ß√£o)
+app.get('/api/admin/reviews/pending', async (req, res) => {
+  try {
+    const [reviews] = await pool.execute(`
+      SELECT 
+        r.*,
+        u.nome as user_name,
+        p.nome as product_name,
+        p.imagem_url as product_image
+      FROM product_reviews r
+      LEFT JOIN users u ON r.user_id = u.id
+      LEFT JOIN produtos p ON r.product_id = p.id
+      WHERE r.status = 'pending'
+      ORDER BY r.created_at DESC
+    `);
 
-    // Se n√£o existir, tentar em users
-    const [users] = await pool.execute('SELECT id, email, nome FROM users WHERE email = ? LIMIT 1', [mail]);
-    if (Array.isArray(users) && users[0]) {
-      const user = users[0];
-      // Auto-criar cliente m√≠nimo e retornar
-      const id = user.id || require('crypto').randomUUID();
-      await pool.execute('INSERT INTO customers (id, nome, email, created_at) VALUES (?,?,?, NOW())', [id, user.nome || mail, mail]);
-      const [created] = await pool.execute('SELECT * FROM customers WHERE id = ? LIMIT 1', [id]);
-      if (Array.isArray(created) && created[0]) return res.json(created[0]);
+    // Buscar m√≠dias de cada review
+    for (let review of reviews) {
+      const [media] = await pool.execute(
+        'SELECT * FROM review_media WHERE review_id = ?',
+        [review.id]
+      );
+      review.media = media;
     }
 
-    return res.status(404).json({ error: 'Cliente n√£o encontrado' });
+    logger.info('Reviews pendentes carregados', { count: reviews.length });
+    res.json({ reviews });
   } catch (error) {
-    console.error('Erro ao buscar cliente:', error);
-    res.status(500).json({ error: 'Erro interno do servidor' });
+    logger.logError(error, req);
+    res.status(500).json({ error: 'Erro ao buscar reviews pendentes' });
   }
 });
 
+// Aprovar review
+app.post('/api/admin/reviews/:reviewId/approve', async (req, res) => {
+  try {
+    const { reviewId } = req.params;
 
+    await pool.execute(
+      'UPDATE product_reviews SET status = ?, updated_at = NOW() WHERE id = ?',
+      ['approved', reviewId]
+    );
 
-// =============================================================================
-// ENDPOINTS PARA DADOS REAIS - SISTEMA FINANCEIRO COMPLETO
-// =============================================================================
+    // Log de modera√ß√£o
+    const logId = crypto.randomUUID();
+    await pool.execute(`
+      INSERT INTO review_moderation_log (id, review_id, moderator_id, action)
+      VALUES (?, ?, ?, ?)
+    `, [logId, reviewId, 'admin-user-id', 'approve']);
 
-// CATEGORIAS
-app.get('/api/categorias', async (req, res) => {
-  try {
-    const [rows] = await pool.execute('SELECT * FROM categorias ORDER BY nome');
-    res.json({ success: true, categorias: rows });
+    logger.info('Review aprovado', { reviewId });
+    res.json({ success: true });
   } catch (error) {
     logger.logError(error, req);
-    res.status(500).json({ error: 'Erro ao buscar categorias', details: error.message });
+    res.status(500).json({ error: 'Erro ao aprovar review' });
   }
 });
 
-app.post('/api/categorias', async (req, res) => {
+// Rejeitar review
+app.post('/api/admin/reviews/:reviewId/reject', async (req, res) => {
   try {
-    const { nome, descricao, cor, icone, tipo } = req.body;
+    const { reviewId } = req.params;
+    const { reason } = req.body;
 
-    if (!nome) {
-      return res.status(400).json({ error: 'Nome da categoria √© obrigat√≥rio' });
-    }
+    await pool.execute(
+      'UPDATE product_reviews SET status = ?, moderation_reason = ?, updated_at = NOW() WHERE id = ?',
+      ['rejected', reason, reviewId]
+    );
 
-    const [result] = await pool.execute(`
-      INSERT INTO categorias (nome, descricao, cor, icone, tipo) 
+    // Log de modera√ß√£o
+    const logId = crypto.randomUUID();
+    await pool.execute(`
+      INSERT INTO review_moderation_log (id, review_id, moderator_id, action, reason)
       VALUES (?, ?, ?, ?, ?)
-    `, [nome, descricao, cor || '#3B82F6', icone || 'üìÅ', tipo || 'ambos']);
+    `, [logId, reviewId, 'admin-user-id', 'reject', reason]);
 
-    logger.info('Categoria criada', { id: result.insertId, nome });
-    res.json({ success: true, message: 'Categoria criada com sucesso', id: result.insertId });
+    logger.info('Review rejeitado', { reviewId, reason });
+    res.json({ success: true });
   } catch (error) {
     logger.logError(error, req);
-    res.status(500).json({ error: 'Erro ao criar categoria', details: error.message });
+    res.status(500).json({ error: 'Erro ao rejeitar review' });
   }
 });
 
-app.put('/api/categorias/:id', async (req, res) => {
+// Responder review (vendedor)
+app.post('/api/admin/reviews/:reviewId/response', async (req, res) => {
   try {
-    const { id } = req.params;
-    const { nome, descricao, cor, icone, tipo } = req.body;
-
-    const [result] = await pool.execute(`
-      UPDATE categorias 
-      SET nome = ?, descricao = ?, cor = ?, icone = ?, tipo = ?, atualizado_em = NOW()
-      WHERE id = ?
-    `, [nome, descricao, cor, icone, tipo, id]);
+    const { reviewId } = req.params;
+    const { response_text, admin_id } = req.body;
+    const responseId = crypto.randomUUID();
 
-    if (result.affectedRows === 0) {
-      return res.status(404).json({ error: 'Categoria n√£o encontrada' });
-    }
+    await pool.execute(`
+      INSERT INTO review_responses (id, review_id, admin_id, response_text)
+      VALUES (?, ?, ?, ?)
+    `, [responseId, reviewId, admin_id, response_text]);
 
-    logger.info('Categoria atualizada', { id, nome });
-    res.json({ success: true, message: 'Categoria atualizada com sucesso' });
+    logger.info('Resposta de review criada', { reviewId, responseId });
+    res.json({ success: true, id: responseId });
   } catch (error) {
     logger.logError(error, req);
-    res.status(500).json({ error: 'Erro ao atualizar categoria', details: error.message });
+    res.status(500).json({ error: 'Erro ao criar resposta' });
   }
 });
 
-app.delete('/api/categorias/:id', async (req, res) => {
+// Upload de m√≠dia para review (com multer)
+const reviewUpload = multer({
+  storage: multer.diskStorage({
+    destination: (req, file, cb) => {
+      const uploadPath = path.join(__dirname, '../public/lovable-uploads/reviews');
+      if (!fs.existsSync(uploadPath)) {
+        fs.mkdirSync(uploadPath, { recursive: true });
+      }
+      cb(null, uploadPath);
+    },
+    filename: (req, file, cb) => {
+      const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1E9);
+      cb(null, 'review-' + uniqueSuffix + path.extname(file.originalname));
+    }
+  }),
+  limits: { fileSize: 5 * 1024 * 1024 }, // 5MB
+  fileFilter: (req, file, cb) => {
+    if (file.mimetype.startsWith('image/')) {
+      cb(null, true);
+    } else {
+      cb(new Error('Apenas imagens s√£o permitidas'));
+    }
+  }
+});
+
+app.post('/api/reviews/:reviewId/media', reviewUpload.array('images', 5), async (req, res) => {
   try {
-    const { id } = req.params;
+    const { reviewId } = req.params;
+    const files = req.files;
 
-    const [result] = await pool.execute('DELETE FROM categorias WHERE id = ?', [id]);
+    if (!files || files.length === 0) {
+      return res.status(400).json({ error: 'Nenhum arquivo enviado' });
+    }
 
-    if (result.affectedRows === 0) {
-      return res.status(404).json({ error: 'Categoria n√£o encontrada' });
+    const mediaIds = [];
+    for (const file of files) {
+      const mediaId = crypto.randomUUID();
+      const mediaUrl = `/lovable-uploads/reviews/${file.filename}`;
+
+      await pool.execute(`
+        INSERT INTO review_media (id, review_id, media_type, media_url, file_size, thumbnail_url)
+        VALUES (?, ?, ?, ?, ?, ?)
+      `, [mediaId, reviewId, 'image', mediaUrl, file.size, mediaUrl]);
+
+      mediaIds.push(mediaId);
     }
 
-    logger.info('Categoria exclu√≠da', { id });
-    res.json({ success: true, message: 'Categoria exclu√≠da com sucesso' });
+    logger.info('M√≠dias de review adicionadas', { reviewId, count: files.length });
+    res.json({ success: true, media_ids: mediaIds });
   } catch (error) {
     logger.logError(error, req);
-    res.status(500).json({ error: 'Erro ao excluir categoria', details: error.message });
+    res.status(500).json({ error: 'Erro ao fazer upload' });
   }
 });
 
-// FORNECEDORES
-app.get('/api/fornecedores', async (req, res) => {
+// ==================== ORDERS API (AVAN√áADO) ====================
+
+// Estat√≠sticas de pedidos
+app.get('/api/orders/stats', async (req, res) => {
   try {
-    const [rows] = await pool.execute('SELECT * FROM fornecedores ORDER BY nome');
-    res.json({ success: true, fornecedores: rows });
+    const [stats] = await pool.execute(`
+      SELECT 
+        COUNT(*) as total,
+        SUM(CASE WHEN status = 'pending' THEN 1 ELSE 0 END) as pending,
+        SUM(CASE WHEN status = 'processing' THEN 1 ELSE 0 END) as processing,
+        SUM(CASE WHEN status = 'shipped' THEN 1 ELSE 0 END) as shipped,
+        SUM(CASE WHEN status = 'delivered' THEN 1 ELSE 0 END) as delivered,
+        SUM(CASE WHEN status = 'cancelled' THEN 1 ELSE 0 END) as cancelled,
+        COALESCE(SUM(CASE WHEN status != 'cancelled' THEN total ELSE 0 END), 0) as total_revenue
+      FROM orders
+    `);
+
+    res.json({
+      total: Number(stats[0].total) || 0,
+      pending: Number(stats[0].pending) || 0,
+      processing: Number(stats[0].processing) || 0,
+      shipped: Number(stats[0].shipped) || 0,
+      delivered: Number(stats[0].delivered) || 0,
+      cancelled: Number(stats[0].cancelled) || 0,
+      totalRevenue: Number(stats[0].total_revenue) || 0,
+    });
   } catch (error) {
     logger.logError(error, req);
-    res.status(500).json({ error: 'Erro ao buscar fornecedores', details: error.message });
+    res.status(500).json({ error: 'Erro ao buscar estat√≠sticas de pedidos' });
   }
 });
 
-app.post('/api/fornecedores', async (req, res) => {
-  try {
-    const { nome, cnpj, email, telefone, endereco, cidade, estado, cep, contato, tipo, status, observacoes } = req.body;
 
-    if (!nome) {
-      return res.status(400).json({ error: 'Nome do fornecedor √© obrigat√≥rio' });
-    }
 
-    const [result] = await pool.execute(`
-      INSERT INTO fornecedores (nome, cnpj, email, telefone, endereco, cidade, estado, cep, contato, tipo, status, observacoes) 
-      VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
-    `, [nome, cnpj, email, telefone, endereco, cidade, estado, cep, contato, tipo || 'outros', status || 'ativo', observacoes]);
+// Atualizar pedido (gen√©rico - para cancelar, etc)
+app.patch('/api/orders/:id', async (req, res) => {
+  try {
+    const { id } = req.params;
+    const { status } = req.body;
+
+    await pool.execute('UPDATE orders SET status = ?, updated_at = NOW() WHERE id = ?', [status, id]);
 
-    logger.info('Fornecedor criado', { id: result.insertId, nome });
-    res.json({ success: true, message: 'Fornecedor criado com sucesso', id: result.insertId });
+    logger.info('Pedido atualizado', { orderId: id, newStatus: status });
+    res.json({ success: true, message: 'Pedido atualizado com sucesso' });
   } catch (error) {
     logger.logError(error, req);
-    res.status(500).json({ error: 'Erro ao criar fornecedor', details: error.message });
+    res.status(500).json({ error: 'Erro ao atualizar pedido' });
   }
 });
 
-app.put('/api/fornecedores/:id', async (req, res) => {
+// Excluir pedido
+app.delete('/api/orders/:id', async (req, res) => {
   try {
     const { id } = req.params;
-    const { nome, cnpj, email, telefone, endereco, cidade, estado, cep, contato, tipo, status, observacoes } = req.body;
 
-    const [result] = await pool.execute(`
-      UPDATE fornecedores 
-      SET nome = ?, cnpj = ?, email = ?, telefone = ?, endereco = ?, cidade = ?, estado = ?, cep = ?, contato = ?, tipo = ?, status = ?, observacoes = ?, atualizado_em = NOW()
-      WHERE id = ?
-    `, [nome, cnpj, email, telefone, endereco, cidade, estado, cep, contato, tipo, status, observacoes, id]);
+    // Verificar se o pedido existe
+    const [order] = await pool.execute('SELECT * FROM orders WHERE id = ?', [id]);
 
-    if (result.affectedRows === 0) {
-      return res.status(404).json({ error: 'Fornecedor n√£o encontrado' });
+    if (order.length === 0) {
+      return res.status(404).json({ error: 'Pedido n√£o encontrado' });
     }
 
-    logger.info('Fornecedor atualizado', { id, nome });
-    res.json({ success: true, message: 'Fornecedor atualizado com sucesso' });
+    // Deletar itens do pedido primeiro
+    await pool.execute('DELETE FROM order_items WHERE order_id = ?', [id]);
+
+    // Deletar o pedido
+    await pool.execute('DELETE FROM orders WHERE id = ?', [id]);
+
+    logger.info('Pedido exclu√≠do', { orderId: id });
+    res.json({ success: true, message: 'Pedido exclu√≠do com sucesso' });
   } catch (error) {
     logger.logError(error, req);
-    res.status(500).json({ error: 'Erro ao atualizar fornecedor', details: error.message });
+    res.status(500).json({ error: 'Erro ao excluir pedido' });
   }
 });
 
-app.delete('/api/fornecedores/:id', async (req, res) => {
+// Reordenar (adicionar produtos do pedido ao carrinho)
+app.post('/api/orders/:id/reorder', async (req, res) => {
   try {
     const { id } = req.params;
+    const cartId = getOrCreateCartId(req, res);
 
-    const [result] = await pool.execute('DELETE FROM fornecedores WHERE id = ?', [id]);
+    // Buscar itens do pedido
+    const [orderItems] = await pool.execute(`
+      SELECT product_id, name, price, image_url, quantity
+      FROM order_items
+      WHERE order_id = ?
+    `, [id]);
 
-    if (result.affectedRows === 0) {
-      return res.status(404).json({ error: 'Fornecedor n√£o encontrado' });
+    if (orderItems.length === 0) {
+      return res.status(404).json({ error: 'Pedido n√£o encontrado' });
     }
 
-    logger.info('Fornecedor exclu√≠do', { id });
-    res.json({ success: true, message: 'Fornecedor exclu√≠do com sucesso' });
-  } catch (error) {
-    logger.logError(error, req);
-    res.status(500).json({ error: 'Erro ao excluir fornecedor', details: error.message });
-  }
-});
+    // Adicionar cada item ao carrinho
+    for (const item of orderItems) {
+      await pool.execute(`
+        INSERT INTO cart_items (cart_id, product_id, name, price, image_url, quantity)
+        VALUES (?, ?, ?, ?, ?, ?)
+        ON DUPLICATE KEY UPDATE quantity = quantity + VALUES(quantity)
+      `, [cartId, item.product_id, item.name, item.price, item.image_url, item.quantity]);
+    }
 
-// CLIENTES
-app.get('/api/clientes', async (req, res) => {
-  try {
-    const [rows] = await pool.execute('SELECT * FROM clientes ORDER BY nome');
-    res.json({ success: true, clientes: rows });
+    // Retornar carrinho atualizado
+    const [cartItems] = await pool.execute(`
+      SELECT * FROM cart_items WHERE cart_id = ? ORDER BY created_at DESC
+    `, [cartId]);
+
+    logger.info('Pedido readicionado ao carrinho', { orderId: id, itemsCount: orderItems.length });
+    res.json({ success: true, items: cartItems });
   } catch (error) {
     logger.logError(error, req);
-    res.status(500).json({ error: 'Erro ao buscar clientes', details: error.message });
+    res.status(500).json({ error: 'Erro ao reordenar' });
   }
 });
 
-app.post('/api/clientes', async (req, res) => {
+// Gerar nota fiscal (simulado)
+app.get('/api/orders/:id/invoice', async (req, res) => {
   try {
-    const { nome, cpf, email, telefone, endereco, cidade, estado, cep, data_nascimento, tipo, status, observacoes } = req.body;
+    const { id } = req.params;
 
-    if (!nome) {
-      return res.status(400).json({ error: 'Nome do cliente √© obrigat√≥rio' });
+    const [orders] = await pool.execute('SELECT * FROM orders WHERE id = ?', [id]);
+    if (orders.length === 0) {
+      return res.status(404).json({ error: 'Pedido n√£o encontrado' });
     }
 
-    const [result] = await pool.execute(`
-      INSERT INTO clientes (nome, cpf, email, telefone, endereco, cidade, estado, cep, data_nascimento, tipo, status, observacoes) 
-      VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
-    `, [nome, cpf, email, telefone, endereco, cidade, estado, cep, data_nascimento, tipo || 'pessoa_fisica', status || 'ativo', observacoes]);
+    const order = orders[0];
+
+    // Gerar PDF ou HTML simples da nota fiscal
+    const html = `
+      <!DOCTYPE html>
+      <html>
+      <head>
+        <meta charset="UTF-8">
+        <title>Nota Fiscal - Pedido #${order.id}</title>
+        <style>
+          body { font-family: Arial, sans-serif; max-width: 800px; margin: 0 auto; padding: 20px; }
+          .header { text-align: center; border-bottom: 2px solid #000; padding-bottom: 20px; margin-bottom: 20px; }
+          .info { margin: 20px 0; }
+          .total { font-size: 24px; font-weight: bold; text-align: right; margin-top: 20px; }
+        </style>
+      </head>
+      <body>
+        <div class="header">
+          <h1>NOTA FISCAL SIMPLIFICADA</h1>
+          <p>MuhlStore - Brinquedos Raros</p>
+        </div>
+        <div class="info">
+          <p><strong>Pedido:</strong> #${order.id}</p>
+          <p><strong>Data:</strong> ${new Date(order.created_at).toLocaleString('pt-BR')}</p>
+          <p><strong>Cliente:</strong> ${order.customer_name || 'N/A'}</p>
+          <p><strong>Email:</strong> ${order.customer_email || 'N/A'}</p>
+        </div>
+        <div class="total">
+          <p>TOTAL: R$ ${Number(order.total).toFixed(2)}</p>
+        </div>
+        <div style="margin-top: 40px; text-align: center; color: #666; font-size: 12px;">
+          <p>Este √© um documento simplificado. Para nota fiscal oficial, entre em contato.</p>
+        </div>
+      </body>
+      </html>
+    `;
 
-    logger.info('Cliente criado', { id: result.insertId, nome });
-    res.json({ success: true, message: 'Cliente criado com sucesso', id: result.insertId });
+    res.setHeader('Content-Type', 'text/html');
+    res.send(html);
   } catch (error) {
     logger.logError(error, req);
-    res.status(500).json({ error: 'Erro ao criar cliente', details: error.message });
+    res.status(500).json({ error: 'Erro ao gerar nota fiscal' });
   }
 });
 
-app.put('/api/clientes/:id', async (req, res) => {
+// ==================== FORNECEDORES/SUPPLIERS API ====================
+
+// Buscar todos os fornecedores
+app.get('/api/suppliers', async (req, res) => {
   try {
-    const { id } = req.params;
-    const { nome, cpf, email, telefone, endereco, cidade, estado, cep, data_nascimento, tipo, status, observacoes } = req.body;
+    console.log('üîç Iniciando busca de fornecedores...');
 
-    const [result] = await pool.execute(`
-      UPDATE clientes 
-      SET nome = ?, cpf = ?, email = ?, telefone = ?, endereco = ?, cidade = ?, estado = ?, cep = ?, data_nascimento = ?, tipo = ?, status = ?, observacoes = ?, atualizado_em = NOW()
-      WHERE id = ?
-    `, [nome, cpf, email, telefone, endereco, cidade, estado, cep, data_nascimento, tipo, status, observacoes, id]);
+    // Primeiro, verificar se a tabela existe e criar se necess√°rio
+    console.log('üìã Verificando/criando tabela fornecedores...');
+    await pool.execute(`
+      CREATE TABLE IF NOT EXISTS fornecedores (
+        id INT AUTO_INCREMENT PRIMARY KEY,
+        nome VARCHAR(255) NOT NULL,
+        email VARCHAR(255),
+        telefone VARCHAR(20),
+        endereco TEXT,
+        cnpj VARCHAR(20),
+        total_expenses DECIMAL(10,2) DEFAULT 0,
+        last_payment DATE,
+        status ENUM('ativo', 'inativo') DEFAULT 'ativo',
+        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
+        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
+      ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci
+    `);
+    console.log('‚úÖ Tabela fornecedores verificada/criada');
 
-    if (result.affectedRows === 0) {
-      return res.status(404).json({ error: 'Cliente n√£o encontrado' });
+    // Inserir dados de exemplo se a tabela estiver vazia
+    console.log('üî¢ Verificando quantidade de fornecedores...');
+    const [countRows] = await pool.execute('SELECT COUNT(*) as count FROM fornecedores');
+    console.log('üìä Quantidade atual:', countRows[0].count);
+
+    if (countRows[0].count === 0) {
+      console.log('‚ûï Inserindo dados de exemplo...');
+      await pool.execute(`
+        INSERT INTO fornecedores (nome, email, telefone, total_expenses, last_payment, status) VALUES
+        ('Brinquedos ABC Ltda', 'contato@abcbrinquedos.com', '(11) 99999-1111', 1200.00, CURDATE() - INTERVAL 1 DAY, 'ativo'),
+        ('Educacional XYZ', 'vendas@educacionalxyz.com', '(11) 99999-2222', 890.00, CURDATE() - INTERVAL 2 DAY, 'ativo'),
+        ('Distribuidora Kids', 'info@distribuidorakids.com', '(11) 99999-3333', 1560.00, CURDATE() - INTERVAL 3 DAY, 'ativo'),
+        ('Importadora Toys', 'contato@importadoratoys.com', '(11) 99999-4444', 2340.00, CURDATE() - INTERVAL 4 DAY, 'ativo')
+      `);
+      console.log('‚úÖ Dados de exemplo inseridos');
     }
 
-    logger.info('Cliente atualizado', { id, nome });
-    res.json({ success: true, message: 'Cliente atualizado com sucesso' });
+    console.log('üì• Buscando fornecedores...');
+    const [rows] = await pool.execute(`
+      SELECT 
+        id,
+        nome,
+        email,
+        telefone,
+        endereco,
+        cnpj,
+        total_expenses,
+        last_payment,
+        status,
+        created_at,
+        updated_at
+      FROM fornecedores 
+      ORDER BY nome ASC
+    `);
+
+    console.log('‚úÖ Fornecedores carregados:', rows.length);
+    logger.info('Fornecedores carregados', { count: rows.length });
+    res.json({ suppliers: rows, total: rows.length });
   } catch (error) {
+    console.error('‚ùå ERRO ao buscar fornecedores:', error);
+    console.error('‚ùå Stack:', error.stack);
     logger.logError(error, req);
-    res.status(500).json({ error: 'Erro ao atualizar cliente', details: error.message });
+    res.status(500).json({ error: 'Erro ao buscar fornecedores', details: error.message });
   }
 });
 
-app.delete('/api/clientes/:id', async (req, res) => {
+// Buscar fornecedor por ID
+app.get('/api/suppliers/:id', async (req, res) => {
   try {
     const { id } = req.params;
+    const [rows] = await pool.execute('SELECT * FROM fornecedores WHERE id = ?', [id]);
 
-    const [result] = await pool.execute('DELETE FROM clientes WHERE id = ?', [id]);
-
-    if (result.affectedRows === 0) {
-      return res.status(404).json({ error: 'Cliente n√£o encontrado' });
+    if (rows.length === 0) {
+      return res.status(404).json({ error: 'Fornecedor n√£o encontrado' });
     }
 
-    logger.info('Cliente exclu√≠do', { id });
-    res.json({ success: true, message: 'Cliente exclu√≠do com sucesso' });
+    res.json(rows[0]);
   } catch (error) {
     logger.logError(error, req);
-    res.status(500).json({ error: 'Erro ao excluir cliente', details: error.message });
-  }
-});
-
-// =============================================================================
-// ENDPOINTS PARA DADOS REAIS - SISTEMA FINANCEIRO COMPLETO
-// =============================================================================
-// (Endpoints de categorias financeiras movidos para a se√ß√£o ========== ENDPOINTS DE CATEGORIAS FINANCEIRAS ========== abaixo)
-
-// FORNECEDORES
-app.get('/api/financial/fornecedores', async (req, res) => {
-  try {
-    console.log('üîç GET /api/financial/fornecedores - Iniciando busca...');
-
-    // Garantir que estamos usando o banco correto
-    // IMPORTANTE: Sempre usar rare_toy_companion, mesmo se .env tiver outro valor
-    const dbName = 'rare_toy_companion';
-    console.log(`üìä Banco configurado (for√ßado): ${dbName}`);
-    console.log(`üìä MYSQL_DATABASE do env: ${process.env.MYSQL_DATABASE}`);
-    console.log(`üìä Pool database config: ${pool.config?.database || 'n√£o definido'}`);
-
-    let connection;
-    try {
-      // Obter conex√£o do pool
-      connection = await pool.getConnection();
-      console.log('‚úÖ Conex√£o obtida do pool');
-
-      // Buscar fornecedores usando nome completo do banco para garantir
-      // N√£o depender do banco padr√£o da conex√£o
-      const query = `SELECT * FROM \`rare_toy_companion\`.\`fornecedores\` ORDER BY nome`;
-      console.log(`üìù Executando query (for√ßando banco): ${query}`);
-      const [rows] = await connection.execute(query);
-      console.log(`‚úÖ ${rows.length} fornecedores encontrados`);
-
-      connection.release();
-      res.json({ success: true, fornecedores: rows || [] });
-    } catch (queryError) {
-      if (connection) connection.release();
-
-      console.error('‚ùå Erro ao executar query SELECT:', queryError);
-      console.error('‚ùå C√≥digo do erro:', queryError.code);
-      console.error('‚ùå SQL State:', queryError.sqlState);
-      console.error('‚ùå Mensagem:', queryError.message);
-
-      // Se for erro de tabela n√£o existe, tentar criar
-      if (queryError.code === 'ER_NO_SUCH_TABLE' || queryError.code === '42S02') {
-        console.log('üìã Tabela n√£o existe, criando...');
-        try {
-          connection = await pool.getConnection();
-          await connection.execute(`USE \`${dbName}\``);
-          await connection.execute(`
-            CREATE TABLE IF NOT EXISTS \`${dbName}\`.\`fornecedores\` (
-              id INT AUTO_INCREMENT PRIMARY KEY,
-              nome VARCHAR(255) NOT NULL,
-              email VARCHAR(255),
-              telefone VARCHAR(20),
-              endereco TEXT,
-              cnpj VARCHAR(18),
-              total_expenses DECIMAL(15,2) DEFAULT 0,
-              last_payment DATE,
-              status ENUM('ativo','inativo','pendente') DEFAULT 'ativo',
-              created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
-              updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
-            ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci
-          `);
-          console.log('‚úÖ Tabela fornecedores criada');
-          // Tentar buscar novamente
-          const [rows] = await connection.execute(`SELECT * FROM \`${dbName}\`.\`fornecedores\` ORDER BY nome`);
-          connection.release();
-          res.json({ success: true, fornecedores: rows || [] });
-          return;
-        } catch (createError) {
-          if (connection) connection.release();
-          console.error('‚ùå Erro ao criar tabela:', createError);
-          throw createError;
-        }
-      } else {
-        throw queryError;
-      }
-    }
-  } catch (error) {
-    console.error('‚ùå Erro ao buscar fornecedores:', error);
-    res.status(500).json({
-      error: 'Erro ao buscar fornecedores',
-      details: error.message,
-      code: error.code,
-      sqlState: error.sqlState
-    });
+    res.status(500).json({ error: 'Erro ao buscar fornecedor' });
   }
 });
 
-app.post('/api/financial/fornecedores', async (req, res) => {
+// Criar fornecedor
+app.post('/api/suppliers', async (req, res) => {
   try {
-    const { nome, cnpj, email, telefone, endereco, status } = req.body || {};
-
-    // Valida√ß√£o mais rigorosa
-    if (!nome || typeof nome !== 'string' || nome.trim().length === 0) {
-      return res.status(400).json({ error: 'Nome do fornecedor √© obrigat√≥rio e deve ser uma string n√£o vazia' });
-    }
-
-    const nomeLimpo = nome.trim();
-    console.log('‚ûï POST /api/financial/fornecedores - Criando fornecedor:', nomeLimpo);
-
-    // Verificar se a tabela existe e criar se necess√°rio
-    try {
-      // Verificar se a tabela existe
-      const [tables] = await pool.execute(`
-        SELECT TABLE_NAME 
-        FROM INFORMATION_SCHEMA.TABLES 
-        WHERE TABLE_SCHEMA = DATABASE() 
-        AND TABLE_NAME = 'fornecedores'
-      `);
-
-      if (tables.length === 0) {
-        console.log('üìã Criando tabela fornecedores...');
-        await pool.execute(`
-          CREATE TABLE fornecedores (
-            id INT AUTO_INCREMENT PRIMARY KEY,
-            nome VARCHAR(255) NOT NULL,
-            email VARCHAR(255),
-            telefone VARCHAR(20),
-            endereco TEXT,
-            cnpj VARCHAR(20),
-            total_expenses DECIMAL(10,2) DEFAULT 0,
-            last_payment DATE,
-            status ENUM('ativo', 'inativo') DEFAULT 'ativo',
-            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
-            updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
-          ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci
-        `);
-        console.log('‚úÖ Tabela fornecedores criada');
-      } else {
-        console.log('‚úÖ Tabela fornecedores j√° existe');
-      }
-    } catch (createError) {
-      console.error('‚ö†Ô∏è Erro ao verificar/criar tabela fornecedores:', createError.message);
-      // Se for erro de tabela j√° existe, continuar; caso contr√°rio, lan√ßar erro
-      if (!createError.message.includes('already exists') && !createError.message.includes('Duplicate')) {
-        throw createError;
-      }
-    }
-
-    // Inserir com as colunas que existem na tabela
-    // A tabela real tem: nome, cnpj, email, telefone, endereco, cidade, estado, cep, contato, tipo, observacoes, status
-    // Status pode ser: 'ativo', 'inativo', 'pendente'
-    const statusValue = status && ['ativo', 'inativo', 'pendente'].includes(status) ? status : 'ativo';
-
-    console.log('üìù Dados recebidos:', { nome, cnpj, email, telefone, endereco, status: statusValue });
-
-    try {
-      const [result] = await pool.execute(`
-      INSERT INTO fornecedores (nome, cnpj, email, telefone, endereco, status) 
-      VALUES (?, ?, ?, ?, ?, ?)
-      `, [
-        nomeLimpo,
-        cnpj ? String(cnpj).trim() || null : null,
-        email ? String(email).trim() || null : null,
-        telefone ? String(telefone).trim() || null : null,
-        endereco ? String(endereco).trim() || null : null,
-        statusValue
-      ]);
+    const { nome, cnpj, telefone, email, endereco, cidade, estado, cep, contato } = req.body;
+    const id = crypto.randomUUID();
 
-      console.log('‚úÖ Fornecedor criado com ID:', result.insertId);
-      res.json({ success: true, message: 'Fornecedor criado com sucesso', id: result.insertId });
-    } catch (insertError) {
-      console.error('‚ùå Erro SQL ao inserir fornecedor:', insertError);
-      console.error('‚ùå C√≥digo do erro:', insertError.code);
-      console.error('‚ùå Mensagem:', insertError.message);
-      throw insertError;
-    }
+    await pool.execute(`
+      INSERT INTO fornecedores (id, nome, cnpj, telefone, email, endereco, cidade, estado, cep, contato)
+      VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
+    `, [id, nome, cnpj || null, telefone || null, email || null, endereco || null, cidade || null, estado || null, cep || null, contato || null]);
 
+    logger.info('Fornecedor criado', { id, nome });
+    res.json({ success: true, id });
   } catch (error) {
-    console.error('‚ùå Erro ao criar fornecedor:', error);
-    console.error('‚ùå Stack:', error.stack);
-    res.status(500).json({
-      error: 'Erro ao criar fornecedor',
-      details: error.message,
-      code: error.code,
-      sqlState: error.sqlState
-    });
+    logger.logError(error, req);
+    res.status(500).json({ error: 'Erro ao criar fornecedor' });
   }
 });
 
-app.put('/api/financial/fornecedores/:id', async (req, res) => {
+// Atualizar fornecedor
+app.put('/api/suppliers/:id', async (req, res) => {
   try {
     const { id } = req.params;
-    const { nome, cnpj, email, telefone, endereco, status } = req.body;
-
-    console.log(`üìù Atualizando fornecedor ID: ${id}`);
+    const { nome, cnpj, telefone, email, endereco, cidade, estado, cep, contato } = req.body;
 
-    // Atualizar apenas com as colunas que o pool consegue ver
-    const [result] = await pool.execute(`
+    await pool.execute(`
       UPDATE fornecedores 
-      SET nome = ?, cnpj = ?, email = ?, telefone = ?, endereco = ?, status = ?, updated_at = NOW()
+      SET nome = ?, cnpj = ?, telefone = ?, email = ?, endereco = ?, cidade = ?, estado = ?, cep = ?, contato = ?, updated_at = NOW()
       WHERE id = ?
-    `, [nome, cnpj || null, email || null, telefone || null, endereco || null, status || 'ativo', id]);
-
-    if (result.affectedRows === 0) {
-      return res.status(404).json({ error: 'Fornecedor n√£o encontrado' });
-    }
+    `, [nome, cnpj || null, telefone || null, email || null, endereco || null, cidade || null, estado || null, cep || null, contato || null, id]);
 
-    console.log('‚úÖ Fornecedor atualizado:', { id, nome });
-    res.json({ success: true, message: 'Fornecedor atualizado com sucesso' });
+    logger.info('Fornecedor atualizado', { id, nome });
+    res.json({ success: true });
   } catch (error) {
-    console.error('‚ùå Erro ao atualizar fornecedor:', error);
-    res.status(500).json({ error: 'Erro ao atualizar fornecedor', details: error.message });
+    logger.logError(error, req);
+    res.status(500).json({ error: 'Erro ao atualizar fornecedor' });
   }
 });
 
-app.delete('/api/financial/fornecedores/:id', async (req, res) => {
+// Deletar fornecedor
+app.delete('/api/suppliers/:id', async (req, res) => {
   try {
     const { id } = req.params;
-    console.log(`üóëÔ∏è Excluindo fornecedor ID: ${id}`);
-
-    const [result] = await pool.execute('DELETE FROM fornecedores WHERE id = ?', [id]);
-    console.log(`üìä Resultado do DELETE:`, { affectedRows: result.affectedRows });
-
-    if (result.affectedRows === 0) {
-      console.log(`‚ùå Fornecedor ID ${id} n√£o encontrado`);
-      return res.status(404).json({ error: 'Fornecedor n√£o encontrado' });
-    }
+    await pool.execute('DELETE FROM fornecedores WHERE id = ?', [id]);
 
-    console.log(`‚úÖ Fornecedor ID ${id} exclu√≠do com sucesso`);
-    res.json({ success: true, message: 'Fornecedor exclu√≠do com sucesso' });
+    logger.info('Fornecedor deletado', { id });
+    res.json({ success: true });
   } catch (error) {
-    console.error('‚ùå Erro ao excluir fornecedor:', error);
-    res.status(500).json({ error: 'Erro ao excluir fornecedor', details: error.message });
+    logger.logError(error, req);
+    res.status(500).json({ error: 'Erro ao deletar fornecedor' });
   }
 });
 
-// (Endpoints de clientes movidos para a se√ß√£o ========== ENDPOINTS DE CLIENTES ========== acima)
-
-// Endpoint de teste simples
-app.get('/api/test', (req, res) => {
-  res.json({ success: true, message: 'Endpoint funcionando!' });
-});
+// ==================== MERCADO PAGO INTEGRATION ====================
+const {
+  initializeMercadoPago,
+  createPaymentPreference,
+  getPaymentInfo,
+  processWebhookNotification,
+  createPixPayment,
+} = require('../config/mercadopago.cjs');
 
-// Endpoint para testar estrutura da tabela fornecedores
-app.get('/api/test-fornecedores-structure', async (req, res) => {
-  try {
-    const [columns] = await pool.execute('SHOW COLUMNS FROM fornecedores');
-    res.json({ success: true, columns: columns.map(c => c.Field) });
-  } catch (error) {
-    res.status(500).json({ error: error.message });
-  }
-});
+// Inicializar Mercado Pago
+initializeMercadoPago();
 
-// Endpoint para testar conex√£o com banco
-app.get('/api/test-db', async (req, res) => {
-  try {
-    const [rows] = await pool.execute('SELECT DATABASE() as current_db');
-    res.json({ success: true, database: rows[0].current_db });
-  } catch (error) {
-    console.error('Erro ao testar banco:', error);
-    res.status(500).json({ error: 'Erro ao testar banco', details: error.message });
-  }
-});
+// Inicializar servi√ßo de e-mail
+initializeEmailService();
 
-// Endpoint para testar tabelas
-app.get('/api/test-tables', async (req, res) => {
-  try {
-    const [rows] = await pool.execute('SHOW TABLES LIKE "clientes"');
-    res.json({ success: true, tables: rows });
-  } catch (error) {
-    console.error('Erro ao testar tabelas:', error);
-    res.status(500).json({ error: 'Erro ao testar tabelas', details: error.message });
-  }
-});
+// Inicializar agendador de recupera√ß√£o de carrinho
+initializeScheduler(pool);
+scheduleMonthlyCleanup();
 
-// Endpoint para listar todas as tabelas
-app.get('/api/test-all-tables', async (req, res) => {
-  try {
-    const [rows] = await pool.execute('SHOW TABLES');
-    res.json({ success: true, tables: rows });
-  } catch (error) {
-    console.error('Erro ao listar tabelas:', error);
-    res.status(500).json({ error: 'Erro ao listar tabelas', details: error.message });
-  }
-});
+// Inicializar Redis (opcional - funciona sem)
+redisCache.initializeRedis();
 
-// ========== ENDPOINTS DE CATEGORIAS FINANCEIRAS ==========
-
-// Criar tabela categorias_financeiras se n√£o existir (idempotente)
-async function ensureCategoriasFinanceirasTable() {
-  await pool.execute(`
-    CREATE TABLE IF NOT EXISTS categorias_financeiras (
-      id INT AUTO_INCREMENT PRIMARY KEY,
-      nome VARCHAR(100) NOT NULL UNIQUE,
-      descricao TEXT,
-      cor VARCHAR(50) DEFAULT '#3B82F6',
-      icone VARCHAR(50) DEFAULT 'üìÅ',
-      tipo VARCHAR(20) DEFAULT 'ambos',
-      created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
-      updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
-      INDEX idx_nome (nome)
-    ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci
-  `);
-}
+// Inicializar Push Notifications
+const pushNotifications = require('../config/pushNotifications.cjs');
+pushNotifications.initializePushNotifications();
 
-// GET - Buscar todas as categorias financeiras
-app.get('/api/financial/categorias', authenticateAdmin, async (req, res) => {
+// Criar prefer√™ncia de pagamento
+app.post('/api/payments/mercadopago/create-preference', async (req, res) => {
   try {
-    await ensureCategoriasFinanceirasTable();
-    console.log('‚úÖ Buscando categorias financeiras...');
-
-    const [rows] = await pool.execute('SELECT * FROM categorias_financeiras ORDER BY nome');
-
-    console.log(`‚úÖ ${rows.length} categorias financeiras encontradas`);
-    res.json({ success: true, categorias: rows, total: rows.length });
-  } catch (error) {
-    console.error('‚ùå Erro ao buscar categorias financeiras:', error);
-    res.status(500).json({ error: 'Erro ao buscar categorias financeiras', ...(process.env.NODE_ENV !== 'production' && { details: error.message }) });
-  }
-});
+    const { items, payer, external_reference } = req.body;
 
-// POST - Criar nova categoria financeira
-app.post('/api/financial/categorias', authenticateAdmin, async (req, res) => {
-  try {
-    await ensureCategoriasFinanceirasTable();
-    const { nome, descricao, cor, icone, tipo } = req.body;
+    const result = await createPaymentPreference({
+      items,
+      payer,
+      external_reference,
+    });
 
-    if (!nome || !nome.trim()) {
-      return res.status(400).json({ error: 'Nome da categoria √© obrigat√≥rio' });
+    if (result.success) {
+      logger.info('Prefer√™ncia MP criada', { preference_id: result.preference_id });
+      res.json(result);
+    } else {
+      res.status(400).json(result);
     }
-
-    console.log('‚úÖ Criando nova categoria financeira:', nome);
-
-    const [result] = await pool.execute(`
-      INSERT INTO categorias_financeiras (nome, descricao, cor, icone, tipo)
-      VALUES (?, ?, ?, ?, ?)
-    `, [nome.trim(), descricao || null, cor || '#3B82F6', icone || 'üìÅ', tipo || 'ambos']);
-
-    console.log(`‚úÖ Categoria financeira criada com ID: ${result.insertId}`);
-    res.json({ success: true, id: result.insertId, message: 'Categoria financeira criada com sucesso' });
   } catch (error) {
-    console.error('‚ùå Erro ao criar categoria financeira:', error);
-    if (error.code === 'ER_DUP_ENTRY') {
-      return res.status(409).json({ error: 'J√° existe uma categoria com este nome' });
-    }
-    res.status(500).json({ error: 'Erro ao criar categoria financeira', ...(process.env.NODE_ENV !== 'production' && { details: error.message }) });
+    logger.logError(error, req);
+    res.status(500).json({ success: false, error: error.message });
   }
 });
 
-// PUT - Atualizar categoria financeira
-app.put('/api/financial/categorias/:id', authenticateAdmin, async (req, res) => {
+// Criar pagamento PIX via Mercado Pago
+app.post('/api/payments/mercadopago/pix', async (req, res) => {
   try {
-    await ensureCategoriasFinanceirasTable();
-    const id = req.params.id;
-    const { nome, descricao, cor, icone, tipo } = req.body;
-    if (!/^\d+$/.test(id)) {
-      return res.status(400).json({ error: 'ID inv√°lido' });
-    }
-    if (!nome || !nome.trim()) {
-      return res.status(400).json({ error: 'Nome da categoria √© obrigat√≥rio' });
-    }
-    const [result] = await pool.execute(`
-      UPDATE categorias_financeiras 
-      SET nome = ?, descricao = ?, cor = ?, icone = ?, tipo = ?
-      WHERE id = ?
-    `, [nome.trim(), descricao || null, cor || '#3B82F6', icone || 'üìÅ', tipo || 'ambos', id]);
-    if (result.affectedRows === 0) {
-      return res.status(404).json({ error: 'Categoria financeira n√£o encontrada' });
-    }
-    res.json({ success: true, message: 'Categoria financeira atualizada com sucesso' });
-  } catch (error) {
-    console.error('‚ùå Erro ao atualizar categoria financeira:', error);
-    if (error.code === 'ER_DUP_ENTRY') {
-      return res.status(409).json({ error: 'J√° existe uma categoria com este nome' });
-    }
-    res.status(500).json({ error: 'Erro ao atualizar categoria financeira', ...(process.env.NODE_ENV !== 'production' && { details: error.message }) });
-  }
-});
+    const { transaction_amount, description, payer, external_reference } = req.body;
+
+    const result = await createPixPayment({
+      transaction_amount,
+      description,
+      payer,
+      external_reference,
+    });
 
-// DELETE - Excluir categoria financeira (bloqueia se houver transa√ß√µes usando a categoria)
-app.delete('/api/financial/categorias/:id', authenticateAdmin, async (req, res) => {
-  try {
-    await ensureCategoriasFinanceirasTable();
-    const id = req.params.id;
-    if (!/^\d+$/.test(id)) {
-      return res.status(400).json({ error: 'ID inv√°lido' });
-    }
-    const [cat] = await pool.execute('SELECT nome FROM categorias_financeiras WHERE id = ?', [id]);
-    if (!cat || cat.length === 0) {
-      return res.status(404).json({ error: 'Categoria financeira n√£o encontrada' });
-    }
-    const nomeCategoria = cat[0].nome;
-    const [count] = await pool.execute(
-      'SELECT COUNT(*) as total FROM financial_transactions WHERE categoria = ?',
-      [nomeCategoria]
-    );
-    const emUso = (count[0] && count[0].total) ? Number(count[0].total) : 0;
-    if (emUso > 0) {
-      return res.status(409).json({
-        error: 'N√£o √© poss√≠vel excluir esta categoria',
-        message: `Existem ${emUso} transa√ß√£o(√µes) usando esta categoria. Altere ou remova-as antes de excluir.`
-      });
+    if (result.success) {
+      logger.info('PIX MP criado', { payment_id: result.payment_id });
+      res.json(result);
+    } else {
+      res.status(400).json(result);
     }
-    await pool.execute('DELETE FROM categorias_financeiras WHERE id = ?', [id]);
-    res.json({ success: true, message: 'Categoria financeira exclu√≠da com sucesso' });
   } catch (error) {
-    console.error('‚ùå Erro ao excluir categoria financeira:', error);
-    res.status(500).json({ error: 'Erro ao excluir categoria financeira', ...(process.env.NODE_ENV !== 'production' && { details: error.message }) });
+    logger.logError(error, req);
+    res.status(500).json({ success: false, error: error.message });
   }
 });
 
-// ========== ENDPOINTS DE CLIENTES ==========
-
-// GET - Buscar todos os clientes
-app.get('/api/financial/clientes', async (req, res) => {
+// Webhook do Mercado Pago
+app.post('/api/payments/mercadopago/webhook', async (req, res) => {
   try {
-    console.log('üë• Buscando clientes da loja (tabela customers)...');
-
-    // Criar pool tempor√°rio para acessar tabela customers
-    // SECURITY: Nunca hardcodar senhas! Use apenas vari√°veis de ambiente
-    const tempPool = mysql.createPool({
-      host: process.env.MYSQL_HOST || process.env.DB_HOST || '127.0.0.1',
-      user: process.env.MYSQL_USER || process.env.DB_USER || 'root',
-      password: process.env.MYSQL_PASSWORD || process.env.DB_PASSWORD || '',
-      database: process.env.MYSQL_DATABASE || process.env.DB_NAME || 'rare_toy_companion',
-      port: parseInt(process.env.MYSQL_PORT || process.env.DB_PORT || '3306'),
-      waitForConnections: true,
-      connectionLimit: 10,
-      queueLimit: 0
-    });
+    logger.info('Webhook MP recebido', { body: req.body, query: req.query });
 
-    // Buscar da tabela customers (clientes reais da loja)
-    const [rows] = await tempPool.execute(`
-      SELECT id, nome, email, telefone, cpf, data_nascimento,
-             endereco_rua, endereco_numero, endereco_complemento,
-             endereco_bairro, endereco_cidade, endereco_estado, endereco_cep,
-             status, total_pedidos, total_gasto, ultimo_pedido, created_at
-      FROM customers 
-      ORDER BY nome
-    `);
+    const notificationData = req.body;
+    const result = await processWebhookNotification(notificationData);
 
-    // Fechar pool tempor√°rio
-    await tempPool.end();
-
-    const clientes = rows.map(cliente => ({
-      id: cliente.id,
-      nome: cliente.nome,
-      cpf: cliente.cpf || '',
-      email: cliente.email || '',
-      telefone: cliente.telefone || '',
-      endereco: `${cliente.endereco_rua || ''} ${cliente.endereco_numero || ''} ${cliente.endereco_complemento || ''}`.trim(),
-      cidade: cliente.endereco_cidade || '',
-      estado: cliente.endereco_estado || '',
-      cep: cliente.endereco_cep || '',
-      data_nascimento: cliente.data_nascimento || '',
-      tipo: cliente.cpf ? 'pessoa_fisica' : 'pessoa_juridica',
-      status: cliente.status || 'ativo',
-      total_compras: cliente.total_pedidos || 0,
-      valor_total: parseFloat(cliente.total_gasto) || 0,
-      ultima_compra: cliente.ultimo_pedido ? new Date(cliente.ultimo_pedido).toISOString().split('T')[0] : '',
-      observacoes: `Cliente da loja - ${cliente.total_pedidos || 0} pedidos realizados`,
-      criado_em: cliente.created_at ? new Date(cliente.created_at).toISOString().split('T')[0] : new Date().toISOString().split('T')[0],
-      // Campos espec√≠ficos da loja
-      total_pedidos: cliente.total_pedidos || 0,
-      total_gasto: parseFloat(cliente.total_gasto) || 0,
-      ultimo_pedido: cliente.ultimo_pedido
-    }));
+    if (result.success && result.action_needed === 'confirm_order') {
+      // Atualizar status do pedido no banco
+      const externalRef = result.payment.external_reference;
+
+      // Aqui voc√™ pode atualizar o status do pedido no banco de dados
+      logger.info('Pedido aprovado via webhook', {
+        external_reference: externalRef,
+        payment_id: result.payment.id,
+        status: result.payment.status,
+      });
+    }
 
-    console.log(`‚úÖ ${clientes.length} clientes da loja encontrados`);
-    res.json({ success: true, clientes, total: clientes.length });
+    res.status(200).json({ success: true });
   } catch (error) {
-    console.error('‚ùå Erro ao buscar clientes da loja:', error);
-    res.status(500).json({ error: 'Erro ao buscar clientes da loja', details: error.message });
+    logger.logError(error, req);
+    res.status(500).json({ success: false, error: error.message });
   }
 });
 
-// POST - Criar novo cliente
-app.post('/api/financial/clientes', async (req, res) => {
-  // SECURITY: Nunca hardcodar senhas! Use apenas vari√°veis de ambiente
-  const tempPool = mysql.createPool({
-    host: process.env.MYSQL_HOST || process.env.DB_HOST || '127.0.0.1',
-    user: process.env.MYSQL_USER || process.env.DB_USER || 'root',
-    password: process.env.MYSQL_PASSWORD || process.env.DB_PASSWORD || '',
-    database: process.env.MYSQL_DATABASE || process.env.DB_NAME || 'rare_toy_companion',
-    port: parseInt(process.env.MYSQL_PORT || process.env.DB_PORT || '3306'),
-    waitForConnections: true,
-    connectionLimit: 10,
-    queueLimit: 0
-  });
-
+// Verificar status de pagamento
+app.get('/api/payments/mercadopago/status/:paymentId', async (req, res) => {
   try {
-    const { nome, cpf, email, telefone, endereco, cidade, estado, cep, data_nascimento, tipo, observacoes } = req.body;
-
-    console.log('‚úÖ Criando novo cliente:', nome);
-
-    const [result] = await tempPool.execute(`
-      INSERT INTO clientes (nome, cpf, email, telefone, endereco, cidade, estado, cep, data_nascimento, tipo, status, observacoes)
-      VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, 'ativo', ?)
-    `, [nome, cpf || null, email || null, telefone || null, endereco || null, cidade || null, estado || null, cep || null, data_nascimento || null, tipo || 'pessoa_fisica', observacoes || null]);
-
-    await tempPool.end();
+    const { paymentId } = req.params;
+    const result = await getPaymentInfo(paymentId);
 
-    console.log(`‚úÖ Cliente criado com ID: ${result.insertId}`);
-    res.json({ success: true, id: result.insertId, message: 'Cliente criado com sucesso' });
+    if (result.success) {
+      res.json(result);
+    } else {
+      res.status(404).json(result);
+    }
   } catch (error) {
-    console.error('‚ùå Erro ao criar cliente:', error);
-    await tempPool.end();
-    res.status(500).json({ error: 'Erro ao criar cliente', details: error.message });
+    logger.logError(error, req);
+    res.status(500).json({ success: false, error: error.message });
   }
 });
 
-// PUT - Atualizar cliente
-app.put('/api/financial/clientes/:id', async (req, res) => {
-  // SECURITY: Nunca hardcodar senhas! Use apenas vari√°veis de ambiente
-  const tempPool = mysql.createPool({
-    host: process.env.MYSQL_HOST || process.env.DB_HOST || '127.0.0.1',
-    user: process.env.MYSQL_USER || process.env.DB_USER || 'root',
-    password: process.env.MYSQL_PASSWORD || process.env.DB_PASSWORD || '',
-    database: process.env.MYSQL_DATABASE || process.env.DB_NAME || 'rare_toy_companion',
-    port: parseInt(process.env.MYSQL_PORT || process.env.DB_PORT || '3306'),
-    waitForConnections: true,
-    connectionLimit: 10,
-    queueLimit: 0
-  });
-
-  try {
-    const { id } = req.params;
-    const { nome, cpf, email, telefone, endereco, cidade, estado, cep, data_nascimento, tipo, status, observacoes } = req.body;
-
-    console.log(`‚úÖ Atualizando cliente ID: ${id}`);
-
-    await tempPool.execute(`
-      UPDATE clientes 
-      SET nome = ?, cpf = ?, email = ?, telefone = ?, endereco = ?, cidade = ?, estado = ?, cep = ?, data_nascimento = ?, tipo = ?, status = ?, observacoes = ?
-      WHERE id = ?
-    `, [nome, cpf || null, email || null, telefone || null, endereco || null, cidade || null, estado || null, cep || null, data_nascimento || null, tipo || 'pessoa_fisica', status || 'ativo', observacoes || null, id]);
+// Error handler do Sentry (deve ser depois de todas as rotas e antes de outros error handlers)
+app.use(sentry.sentryErrorHandler());
 
-    await tempPool.end();
+// Error handler global
+app.use((err, req, res, next) => {
+  logger.logError(err, req);
+  sentry.captureException(err, {
+    path: req.path,
+    method: req.method,
+    ip: req.ip,
+  });
 
-    console.log(`‚úÖ Cliente ${id} atualizado`);
-    res.json({ success: true, message: 'Cliente atualizado com sucesso' });
-  } catch (error) {
-    console.error('‚ùå Erro ao atualizar cliente:', error);
-    await tempPool.end();
-    res.status(500).json({ error: 'Erro ao atualizar cliente', details: error.message });
-  }
+  res.status(err.status || 500).json({
+    error: process.env.NODE_ENV === 'production'
+      ? 'Erro interno do servidor'
+      : err.message,
+    ...(process.env.NODE_ENV !== 'production' && { stack: err.stack }),
+  });
 });
 
-// DELETE - Excluir cliente
-app.delete('/api/financial/clientes/:id', async (req, res) => {
-  // SECURITY: Nunca hardcodar senhas! Use apenas vari√°veis de ambiente
-  const tempPool = mysql.createPool({
-    host: process.env.MYSQL_HOST || process.env.DB_HOST || '127.0.0.1',
-    user: process.env.MYSQL_USER || process.env.DB_USER || 'root',
-    password: process.env.MYSQL_PASSWORD || process.env.DB_PASSWORD || '',
-    database: process.env.MYSQL_DATABASE || process.env.DB_NAME || 'rare_toy_companion',
-    port: parseInt(process.env.MYSQL_PORT || process.env.DB_PORT || '3306'),
-    waitForConnections: true,
-    connectionLimit: 10,
-    queueLimit: 0
-  });
+// Start server
+app.listen(PORT, '0.0.0.0', () => {
+  console.log(`üöÄ Carousel API server running on port ${PORT}`);
+  console.log(`üìä Health check: http://localhost:${PORT}/api/health`);
+  console.log(`üé† Carousel API: http://localhost:${PORT}/api/carousel`);
+  console.log(`üí≥ Mercado Pago: Integrado`);
+  console.log(`üîç Sentry: ${sentry.isInitialized() ? 'Ativo' : 'Desabilitado'}`);
+  console.log(`‚ö° Redis: ${redisCache.isAvailable() ? 'Conectado' : 'Desabilitado'}`);
+});
 
-  try {
-    const { id } = req.params;
+// Graceful shutdown
+process.on('SIGINT', async () => {
+  console.log('\nüõë Shutting down server...');
 
-    console.log(`‚úÖ Excluindo cliente ID: ${id}`);
+  // Flush Sentry events
+  await sentry.flush(2000);
 
-    await tempPool.execute('DELETE FROM clientes WHERE id = ?', [id]);
-    await tempPool.end();
+  // Fechar conex√µes
+  await pool.end();
 
-    console.log(`‚úÖ Cliente ${id} exclu√≠do`);
-    res.json({ success: true, message: 'Cliente exclu√≠do com sucesso' });
-  } catch (error) {
-    console.error('‚ùå Erro ao excluir cliente:', error);
-    await tempPool.end();
-    res.status(500).json({ error: 'Erro ao excluir cliente', details: error.message });
-  }
+  console.log('‚úÖ Server shut down gracefully');
+  process.exit(0);
 });
 
-// Endpoint para testar clientes diretamente
-app.get('/api/test-clientes', async (req, res) => {
+app.get('/api/orders/:id', async (req, res) => {
   try {
-    console.log('Testando clientes...');
-    const [rows] = await pool.execute('SELECT COUNT(*) as total FROM clientes');
-    console.log('Total de clientes:', rows[0].total);
-    res.json({ success: true, total: rows[0].total });
-  } catch (error) {
-    console.error('Erro ao testar clientes:', error);
-    res.status(500).json({ error: 'Erro ao testar clientes', details: error.message });
-  }
-});
+    const { id } = req.params;
+    // Buscar pedido
+    const [orders] = await pool.execute('SELECT * FROM orders WHERE id = ?', [id]);
+    if (!Array.isArray(orders) || orders.length === 0) {
+      return res.status(404).json({ error: 'order_not_found' });
+    }
+    const order = orders[0];
 
-// Endpoint para testar com uma tabela que sabemos que funciona
-app.get('/api/test-clientes-alt', async (req, res) => {
-  try {
-    console.log('Testando clientes alternativo...');
-    const [rows] = await pool.execute('SELECT COUNT(*) as total FROM clientes');
-    console.log('Total de clientes:', rows[0].total);
-    res.json({ success: true, total: rows[0].total });
-  } catch (error) {
-    console.error('Erro ao testar clientes alternativo:', error);
-    res.status(500).json({ error: 'Erro ao testar clientes alternativo', details: error.message });
-  }
-});
+    // Buscar itens do pedido
+    let items;
+    try {
+      const [cols] = await pool.execute('DESCRIBE order_items');
+      const fields = Array.isArray(cols) ? cols.map((c) => c.Field) : [];
+      const nameCol = fields.includes('name') ? 'name' : (fields.includes('product_name') ? 'product_name' : null);
+      const imageCol = fields.includes('image_url') ? 'image_url' : (fields.includes('image') ? 'image' : null);
+      const sql = `SELECT order_id, product_id, ${nameCol || "'Produto' AS name"}, price, ${imageCol || "NULL AS image_url"}, quantity FROM order_items WHERE order_id = ?`;
+      const [rows] = await pool.execute(sql, [id]);
+      items = rows;
+    } catch {
+      const [rows] = await pool.execute('SELECT order_id, product_id, price, quantity FROM order_items WHERE order_id = ?', [id]);
+      items = rows.map((r) => ({ ...r, name: 'Produto', image_url: null }));
+    }
 
-// Endpoint para testar com uma tabela que sabemos que funciona
-app.get('/api/test-clientes-simple', async (req, res) => {
-  try {
-    console.log('Testando clientes simples...');
-    const [rows] = await pool.execute('SELECT * FROM clientes LIMIT 1');
-    console.log('Clientes encontrados:', rows.length);
-    res.json({ success: true, count: rows.length });
-  } catch (error) {
-    console.error('Erro ao testar clientes simples:', error);
-    res.status(500).json({ error: 'Erro ao testar clientes simples', details: error.message });
-  }
-});
+    // Normaliza√ß√£o b√°sica de tipos e URLs
+    let normalizedItems = (items || []).map((it) => ({
+      order_id: it.order_id,
+      product_id: it.product_id,
+      name: it.name,
+      price: Number(it.price || 0),
+      image_url: it.image_url ? getPublicUrl(req, it.image_url) : null,
+      quantity: Number(it.quantity || 1),
+    }));
 
-// Endpoint para testar com uma tabela que sabemos que funciona
-app.get('/api/test-clientes-final', async (req, res) => {
-  try {
-    console.log('Testando clientes final...');
-    const [rows] = await pool.execute('SELECT * FROM clientes');
-    console.log('Clientes encontrados:', rows.length);
-    res.json({ success: true, count: rows.length });
-  } catch (error) {
-    console.error('Erro ao testar clientes final:', error);
-    res.status(500).json({ error: 'Erro ao testar clientes final', details: error.message });
-  }
-});
+    // Enriquecer com dados de products quando faltar name/imagem
+    try {
+      const missing = normalizedItems.filter(i => !i.image_url || !i.name || i.name === 'Produto');
+      const productIds = [...new Set(missing.map(i => i.product_id))];
+      if (productIds.length > 0) {
+        const placeholders = productIds.map(() => '?').join(',');
+        // Detectar colunas reais de products
+        let pRows;
+        try {
+          const [pCols] = await pool.execute('DESCRIBE products');
+          const pFields = Array.isArray(pCols) ? pCols.map(c => c.Field) : [];
+          const nameCol = pFields.includes('nome') ? 'nome' : (pFields.includes('name') ? 'name' : null);
+          const imgCol = pFields.includes('imagem_url') ? 'imagem_url'
+            : (pFields.includes('image_url') ? 'image_url'
+              : (pFields.includes('imagemUrl') ? 'imagemUrl'
+                : (pFields.includes('image') ? 'image' : null)));
+          const selectNome = nameCol ? nameCol : "NULL";
+          const selectImg = imgCol ? imgCol : "NULL";
+          const [rows] = await pool.query(
+            `SELECT id, ${selectNome} AS nome, ${selectImg} AS imagem_url FROM produtos WHERE id IN (${placeholders})`,
+            productIds
+          );
+          pRows = rows;
+        } catch (_e) {
+          // Fallback amplo
+          const [rows] = await pool.query(
+            `SELECT id, COALESCE(nome, name) AS nome, COALESCE(imagem_url, image_url) AS imagem_url FROM produtos WHERE id IN (${placeholders})`,
+            productIds
+          );
+          pRows = rows;
+        }
+        const map = new Map((pRows || []).map(r => [String(r.id), r]));
+        normalizedItems = normalizedItems.map(i => {
+          const needsName = !i.name || i.name === 'Produto';
+          const needsImage = !i.image_url;
+          if (needsName || needsImage) {
+            const p = map.get(String(i.product_id));
+            if (p) {
+              if (needsName) i.name = p.nome || 'Produto';
+              if (needsImage) i.image_url = p.imagem_url ? getPublicUrl(req, p.imagem_url) : null;
+            }
+          }
+          return i;
+        });
+      }
+    } catch { }
 
-// Endpoint para testar com uma tabela que sabemos que funciona
-app.get('/api/test-clientes-ultimo', async (req, res) => {
-  try {
-    console.log('Testando clientes √∫ltimo...');
-    const [rows] = await pool.execute('SELECT * FROM clientes');
-    console.log('Clientes encontrados:', rows.length);
-    res.json({ success: true, count: rows.length });
-  } catch (error) {
-    console.error('Erro ao testar clientes √∫ltimo:', error);
-    res.status(500).json({ error: 'Erro ao testar clientes √∫ltimo', details: error.message });
-  }
-});
+    // Mapear campos conforme schema atual
+    const paymentMethod = order.payment_method || order.metodo_pagamento || null;
+    const shippingAddress = order.shipping_address || order.endereco || null;
+    const rawStatus = order.status;
+    let friendlyStatus = rawStatus || 'pending';
+    try {
+      if (rawStatus === 0) {
+        friendlyStatus = 'pending';
+      }
+    } catch (_e) { }
 
-// Endpoint para testar com uma tabela que sabemos que funciona
-app.get('/api/test-clientes-ultimo-alt', async (req, res) => {
-  try {
-    console.log('Testando clientes √∫ltimo alt...');
-    const [rows] = await pool.execute('SELECT * FROM clientes');
-    console.log('Clientes encontrados:', rows.length);
-    res.json({ success: true, count: rows.length });
-  } catch (error) {
-    console.error('Erro ao testar clientes √∫ltimo alt:', error);
-    res.status(500).json({ error: 'Erro ao testar clientes √∫ltimo alt', details: error.message });
+    res.json({
+      id: order.id,
+      status: friendlyStatus,
+      total: Number(order.total || 0),
+      created_at: order.created_at || null,
+      nome: order.nome || null,
+      email: order.email || null,
+      telefone: order.telefone || null,
+      endereco: shippingAddress,
+      metodo_pagamento: paymentMethod,
+      items: normalizedItems,
+    });
+  } catch (e) {
+    console.error('Order detail error', e);
+    res.status(500).json({ error: 'order_detail_failed' });
   }
 });
 
-// Endpoint para testar com uma tabela que sabemos que funciona
-app.get('/api/test-clientes-ultimo-alt2', async (req, res) => {
+app.post('/api/orders/:id/reorder', async (req, res) => {
   try {
-    console.log('Testando clientes √∫ltimo alt2...');
-    const [rows] = await pool.execute('SELECT * FROM clientes');
-    console.log('Clientes encontrados:', rows.length);
-    res.json({ success: true, count: rows.length });
-  } catch (error) {
-    console.error('Erro ao testar clientes √∫ltimo alt2:', error);
-    res.status(500).json({ error: 'Erro ao testar clientes √∫ltimo alt2', details: error.message });
-  }
-});
+    const { id } = req.params;
+    const cartId = getOrCreateCartId(req, res);
 
-// Endpoint para testar com uma tabela que sabemos que funciona
-app.get('/api/test-clientes-ultimo-alt3', async (req, res) => {
-  try {
-    console.log('Testando clientes √∫ltimo alt3...');
-    const [rows] = await pool.execute('SELECT * FROM clientes');
-    console.log('Clientes encontrados:', rows.length);
-    res.json({ success: true, count: rows.length });
-  } catch (error) {
-    console.error('Erro ao testar clientes √∫ltimo alt3:', error);
-    res.status(500).json({ error: 'Erro ao testar clientes √∫ltimo alt3', details: error.message });
-  }
-});
+    // Buscar itens do pedido
+    let items;
+    try {
+      const [cols] = await pool.execute('DESCRIBE order_items');
+      const fields = Array.isArray(cols) ? cols.map((c) => c.Field) : [];
+      const nameCol = fields.includes('name') ? 'name' : (fields.includes('product_name') ? 'product_name' : null);
+      const imageCol = fields.includes('image_url') ? 'image_url' : (fields.includes('image') ? 'image' : null);
+      const sql = `SELECT product_id, ${nameCol || "'Produto' AS name"}, price, ${imageCol || "NULL AS image_url"}, quantity FROM order_items WHERE order_id = ?`;
+      const [rows] = await pool.execute(sql, [id]);
+      items = rows;
+    } catch {
+      const [rows] = await pool.execute('SELECT product_id, price, quantity FROM order_items WHERE order_id = ?', [id]);
+      items = rows.map((r) => ({ ...r, name: 'Produto', image_url: null }));
+    }
 
-// Endpoint para testar com uma tabela que sabemos que funciona
-app.get('/api/test-clientes-ultimo-alt4', async (req, res) => {
-  try {
-    console.log('Testando clientes √∫ltimo alt4...');
-    const [rows] = await pool.execute('SELECT * FROM clientes');
-    console.log('Clientes encontrados:', rows.length);
-    res.json({ success: true, count: rows.length });
-  } catch (error) {
-    console.error('Erro ao testar clientes √∫ltimo alt4:', error);
-    res.status(500).json({ error: 'Erro ao testar clientes √∫ltimo alt4', details: error.message });
-  }
-});
+    if (!Array.isArray(items) || items.length === 0) {
+      return res.status(404).json({ error: 'order_items_not_found' });
+    }
 
-// Endpoint para testar com uma tabela que sabemos que funciona
-app.get('/api/test-clientes-ultimo-alt5', async (req, res) => {
-  try {
-    console.log('Testando clientes √∫ltimo alt5...');
-    const [rows] = await pool.execute('SELECT * FROM clientes');
-    console.log('Clientes encontrados:', rows.length);
-    res.json({ success: true, count: rows.length });
-  } catch (error) {
-    console.error('Erro ao testar clientes √∫ltimo alt5:', error);
-    res.status(500).json({ error: 'Erro ao testar clientes √∫ltimo alt5', details: error.message });
-  }
-});
+    // Inserir/atualizar no carrinho: somar quantidades se j√° existir mesmo product_id
+    for (const it of items) {
+      // Verificar se j√° existe item igual no carrinho
+      const [existing] = await pool.execute(
+        'SELECT id, quantity FROM cart_items WHERE cart_id = ? AND product_id = ? LIMIT 1',
+        [cartId, it.product_id]
+      );
 
-// Endpoint para testar a nova tabela clientes_novo
-app.get('/api/test-clientes-novo', async (req, res) => {
-  try {
-    console.log('Testando clientes_novo...');
-    const [rows] = await pool.execute('SELECT * FROM clientes_novo');
-    console.log('Clientes_novo encontrados:', rows.length);
-    res.json({ success: true, count: rows.length });
-  } catch (error) {
-    console.error('Erro ao testar clientes_novo:', error);
-    res.status(500).json({ error: 'Erro ao testar clientes_novo', details: error.message });
-  }
-});
+      if (Array.isArray(existing) && existing.length > 0) {
+        const current = existing[0];
+        await pool.execute('UPDATE cart_items SET quantity = ? WHERE id = ?', [Number(current.quantity) + Number(it.quantity || 1), current.id]);
+      } else {
+        await pool.execute(
+          'INSERT INTO cart_items (cart_id, product_id, name, price, image_url, quantity) VALUES (?,?,?,?,?,?)',
+          [cartId, it.product_id, it.name, it.price, it.image_url, it.quantity || 1]
+        );
+      }
+    }
 
-// Endpoint para testar a conex√£o com o banco e listar todas as tabelas
-app.get('/api/test-db-connection', async (req, res) => {
-  try {
-    console.log('Testando conex√£o com o banco...');
-    const [tables] = await pool.execute('SHOW TABLES');
-    console.log('Tabelas encontradas:', tables.length);
-    const tableNames = tables.map(table => Object.values(table)[0]);
-    res.json({ success: true, tables: tableNames, count: tables.length });
-  } catch (error) {
-    console.error('Erro ao testar conex√£o com o banco:', error);
-    res.status(500).json({ error: 'Erro ao testar conex√£o com o banco', details: error.message });
+    // Retornar carrinho atualizado
+    const [cart] = await pool.execute('SELECT * FROM cart_items WHERE cart_id = ?', [cartId]);
+    res.json({ items: cart });
+  } catch (e) {
+    console.error('Order reorder error', e);
+    res.status(500).json({ error: 'order_reorder_failed' });
   }
 });
 
-// Endpoint para testar diretamente a tabela clientes
-app.get('/api/test-clientes-direct', async (req, res) => {
+app.post('/api/orders/:id/resend', async (req, res) => {
   try {
-    console.log('Testando tabela clientes diretamente...');
-
-    // Criar um novo pool de conex√µes para este teste
-    // SECURITY: Nunca hardcodar senhas! Use apenas vari√°veis de ambiente
-    const testPool = mysql.createPool({
-      host: process.env.MYSQL_HOST || process.env.DB_HOST || '127.0.0.1',
-      user: process.env.MYSQL_USER || process.env.DB_USER || 'root',
-      password: process.env.MYSQL_PASSWORD || process.env.DB_PASSWORD || '',
-      database: process.env.MYSQL_DATABASE || process.env.DB_NAME || 'rare_toy_companion',
-      port: parseInt(process.env.MYSQL_PORT || process.env.DB_PORT || '3306'),
-      waitForConnections: true,
-      connectionLimit: 10,
-      queueLimit: 0
-    });
+    const { id } = req.params;
+    // Buscar pedido completo e usar email se existir
+    const [orders] = await pool.execute('SELECT * FROM orders WHERE id = ? LIMIT 1', [id]);
+    if (!Array.isArray(orders) || orders.length === 0) {
+      return res.status(404).json({ error: 'order_not_found' });
+    }
+    const order = orders[0];
 
-    const [rows] = await testPool.execute('SELECT COUNT(*) as total FROM clientes');
-    console.log('Total de clientes:', rows[0].total);
+    // Buscar itens e enriquecer nome/imagem
+    const [items] = await pool.execute('SELECT product_id, quantity, price FROM order_items WHERE order_id = ?', [id]);
+    const productIds = [...new Set((items || []).map(i => i.product_id))];
+    let productsMap = new Map();
+    if (productIds.length > 0) {
+      const placeholders = productIds.map(() => '?').join(',');
+      const [pCols] = await pool.execute('DESCRIBE products');
+      const pFields = Array.isArray(pCols) ? pCols.map(c => c.Field) : [];
+      const nameCol = pFields.includes('nome') ? 'nome' : (pFields.includes('name') ? 'name' : null);
+      const imgCol = pFields.includes('imagem_url') ? 'imagem_url'
+        : (pFields.includes('image_url') ? 'image_url'
+          : (pFields.includes('imagemUrl') ? 'imagemUrl'
+            : (pFields.includes('image') ? 'image' : null)));
+      const selectNome = nameCol ? nameCol : "NULL";
+      const selectImg = imgCol ? imgCol : "NULL";
+      const [pRows] = await pool.query(`SELECT id, ${selectNome} AS nome, ${selectImg} AS imagem_url FROM produtos WHERE id IN (${placeholders})`, productIds);
+      productsMap = new Map((pRows || []).map(r => [String(r.id), r]));
+    }
 
-    // Fechar o pool de teste
-    await testPool.end();
+    const normalizedItems = (items || []).map((it) => {
+      const p = productsMap.get(String(it.product_id));
+      return {
+        product_id: it.product_id,
+        name: p?.nome || 'Produto',
+        image_url: p?.imagem_url ? getPublicUrl(req, p.imagem_url) : null,
+        quantity: Number(it.quantity || 1),
+        price: Number(it.price || 0),
+        total: Number(it.price || 0) * Number(it.quantity || 1)
+      };
+    });
 
-    res.json({ success: true, total: rows[0].total });
-  } catch (error) {
-    console.error('Erro ao testar tabela clientes diretamente:', error);
-    res.status(500).json({ error: 'Erro ao testar tabela clientes diretamente', details: error.message, stack: error.stack });
-  }
-});
+    const total = normalizedItems.reduce((acc, i) => acc + i.total, 0);
+    const createdAt = order.created_at || new Date();
+    const paymentMethod = order.payment_method || order.metodo_pagamento || '‚Äî';
+    const html = `
+<!doctype html>
+<html><head><meta charset="utf-8"/><title>Comprovante do Pedido ${order.id}</title>
+<style>
+body{font-family:ui-sans-serif,system-ui,Arial,sans-serif;color:#111}
+.wrap{max-width:640px;margin:24px auto;padding:24px;border:1px solid #eee;border-radius:12px}
+.h{font-size:20px;font-weight:700;margin:0 0 8px}
+.muted{color:#666}
+.row{display:flex;align-items:center;gap:10px}
+.item{display:flex;gap:12px;border-top:1px solid #eee;padding:12px 0}
+.img{width:56px;height:56px;object-fit:cover;border-radius:8px;border:1px solid #ddd}
+.right{text-align:right;margin-left:auto}
+.total{font-weight:700}
+</style></head>
+<body>
+  <div class="wrap">
+    <div class="h">Comprovante do Pedido ${order.id}</div>
+    <div class="muted">Realizado em ${new Date(createdAt).toLocaleString('pt-BR')}</div>
+    <div class="muted">Pagamento: ${paymentMethod.toUpperCase()}</div>
+    <div style="margin:16px 0"></div>
+    ${normalizedItems.map(i => `
+      <div class="item">
+        ${i.image_url ? `<img class="img" src="${i.image_url}" alt="${i.name}"/>` : '<div class="img" style="background:#f6f6f6"></div>'}
+        <div>
+          <div>${i.name}</div>
+          <div class="muted">Qtd: ${i.quantity} ‚Ä¢ Unit: R$ ${i.price.toFixed(2)}</div>
+        </div>
+        <div class="right">R$ ${i.total.toFixed(2)}</div>
+      </div>
+    `).join('')}
+    <div class="item" style="border-top:2px solid #ddd"></div>
+    <div class="row">
+      <div class="muted">Total</div>
+      <div class="right total">R$ ${total.toFixed(2)}</div>
+    </div>
+  </div>
+</body></html>`;
 
-// Endpoint para testar com uma tabela que sabemos que funciona
-app.get('/api/test-fornecedores', async (req, res) => {
-  try {
-    console.log('Testando fornecedores...');
-    const [rows] = await pool.execute('SELECT COUNT(*) as total FROM fornecedores');
-    console.log('Total de fornecedores:', rows[0].total);
-    res.json({ success: true, total: rows[0].total });
-  } catch (error) {
-    console.error('Erro ao testar fornecedores:', error);
-    res.status(500).json({ error: 'Erro ao testar fornecedores', details: error.message });
-  }
-});
+    // Envio real por SMTP, se configurado
+    let sent = false;
+    try {
+      const h = process.env.SMTP_HOST;
+      const u = process.env.SMTP_USER;
+      const p = process.env.SMTP_PASS;
+      const from = process.env.SMTP_FROM || 'no-reply@localhost';
+      const to = (order.email && String(order.email)) || process.env.SMTP_TO || '';
+      if (h && u && p && from && to) {
+        const nodemailer = require('nodemailer');
+        const transporter = nodemailer.createTransport({
+          host: h,
+          port: Number(process.env.SMTP_PORT || 587),
+          secure: Boolean(process.env.SMTP_SECURE === 'true'),
+          auth: { user: u, pass: p }
+        });
+        await transporter.sendMail({
+          from,
+          to,
+          subject: `Comprovante do Pedido ${order.id}`,
+          html
+        });
+        sent = true;
+        console.log(`‚úâÔ∏è  Comprovante enviado para ${to} (pedido ${order.id})`);
+      } else {
+        console.log('‚ÑπÔ∏è SMTP n√£o configurado ou e-mail do pedido ausente. Pulando envio.');
+      }
+    } catch (err) {
+      console.error('Falha ao enviar e-mail SMTP', err);
+    }
 
-// Endpoint para testar com uma tabela que sabemos que funciona
-app.get('/api/test-categorias', async (req, res) => {
-  try {
-    console.log('Testando categorias...');
-    const [rows] = await pool.execute('SELECT COUNT(*) as total FROM categorias');
-    console.log('Total de categorias:', rows[0].total);
-    res.json({ success: true, total: rows[0].total });
-  } catch (error) {
-    console.error('Erro ao testar categorias:', error);
-    res.status(500).json({ error: 'Erro ao testar categorias', details: error.message });
+    // Retornar resultado e preview (√∫til para debug/UI)
+    console.log(`‚úâÔ∏è  Comprovante gerado para pedido ${order.id} (${normalizedItems.length} itens)`);
+    res.setHeader('Content-Type', 'application/json');
+    res.json({ ok: true, emailed: sent, preview_html: html });
+  } catch (e) {
+    console.error('Order resend error', e);
+    res.status(500).json({ error: 'order_resend_failed' });
   }
 });
 
-// Teste espec√≠fico para tabela customers
-app.get('/api/test-customers', async (req, res) => {
+app.get('/api/orders/:id/timeline', async (req, res) => {
   try {
-    console.log('üîç Testando tabela customers...');
-
-    const [columns] = await pool.execute('SHOW COLUMNS FROM customers');
-    console.log('üìã Colunas da tabela customers:', columns);
+    const { id } = req.params;
+    const [orders] = await pool.execute('SELECT id, status, created_at FROM orders WHERE id = ? LIMIT 1', [id]);
+    if (!Array.isArray(orders) || orders.length === 0) {
+      return res.status(404).json({ error: 'order_not_found' });
+    }
+    const order = orders[0];
 
-    const [rows] = await pool.execute('SELECT id, nome, email, total_pedidos, total_gasto FROM customers LIMIT 3');
-    console.log('üìä Dados da tabela customers:', rows);
+    // Timeline simples baseada no status atual
+    const createdAt = order.created_at || new Date();
+    const base = [{ status: 'criado', at: createdAt }];
+    const status = (order.status || 'criado').toLowerCase();
+    if (status === 'processando') base.push({ status: 'processando', at: createdAt });
+    if (status === 'em_transito' || status === 'em tr√¢nsito') base.push({ status: 'em_transito', at: createdAt });
+    if (status === 'entregue') base.push({ status: 'em_transito', at: createdAt }, { status: 'entregue', at: createdAt });
 
-    res.json({
-      success: true,
-      columns: columns,
-      data: rows,
-      message: 'Estrutura da tabela customers verificada'
-    });
-  } catch (error) {
-    console.error('‚ùå Erro ao verificar tabela customers:', error);
-    res.status(500).json({ error: 'Erro ao verificar tabela customers', details: error.message });
+    res.json(base);
+  } catch (e) {
+    console.error('Order timeline error', e);
+    res.status(500).json({ error: 'order_timeline_failed' });
   }
 });
 
-// ====================
-// ENDPOINTS DE CONFIGURA√á√ïES DO CLIENTE
-// ====================
-
-// Buscar configura√ß√µes do cliente
-app.get('/api/customers/:userId/settings', async (req, res) => {
+// ==========================
+// Frete: cota√ß√£o simples por CEP e subtotal
+// ==========================
+app.post('/api/shipping/quote', async (req, res) => {
   try {
-    let { userId } = req.params;
-    console.log(`üìç GET /api/customers/${userId}/settings`);
-
-    // Se userId parece ser email, buscar o ID do usu√°rio
-    if (userId.includes('@')) {
-      const [user] = await pool.execute('SELECT id FROM users WHERE email = ?', [userId]);
-      if (user && user[0]) {
-        userId = user[0].id;
-      } else {
-        return res.status(404).json({ error: 'Usu√°rio n√£o encontrado' });
-      }
+    const { cep, subtotal } = req.body || {};
+    const sub = Number(subtotal || 0);
+    // Regra simples: frete gr√°tis acima de 200; caso contr√°rio, base por regi√£o
+    if (sub >= 200) {
+      return res.json({ price: 0, estimated_days: 3, rule: 'free_over_200' });
     }
-
-    // Buscar configura√ß√µes
-    const [settings] = await pool.execute(`
-      SELECT * FROM customer_settings WHERE customer_id = ?
-    `, [userId]);
-
-    if (settings.length > 0) {
-      const setting = settings[0];
-      res.json({
-        privacy: {
-          showProfile: setting.show_profile || true,
-          showPurchaseHistory: setting.show_purchase_history || false,
-          showWishlist: setting.show_wishlist || false,
-          allowMarketing: setting.allow_marketing || true,
-          allowAnalytics: setting.allow_analytics || true,
-          allowCookies: setting.allow_cookies || true
-        },
-        preferences: {
-          language: setting.language || 'pt-BR',
-          currency: setting.currency || 'BRL',
-          theme: setting.theme || 'light',
-          emailFrequency: setting.email_frequency || 'weekly',
-          twoFactorAuth: setting.two_factor_auth || false
-        }
-      });
-    } else {
-      // Retornar valores padr√£o
-      res.json({
-        privacy: {
-          showProfile: true,
-          showPurchaseHistory: false,
-          showWishlist: false,
-          allowMarketing: true,
-          allowAnalytics: true,
-          allowCookies: true
-        },
-        preferences: {
-          language: 'pt-BR',
-          currency: 'BRL',
-          theme: 'light',
-          emailFrequency: 'weekly',
-          twoFactorAuth: false
-        }
-      });
+    // Heur√≠stica por prefixo de CEP
+    const cepStr = String(cep || '').replace(/\D/g, '');
+    const prefix = cepStr.slice(0, 2);
+    let base = 19.9; // padr√£o
+    let days = 5;
+    if (["01", "02", "03", "04", "05", "06", "07", "08", "09", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49"].includes(prefix)) { // Sudeste/Sul aproximado
+      base = 15.0; days = 4;
+    }
+    if (["50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69"].includes(prefix)) { // Centro-Oeste/Norte
+      base = 24.9; days = 7;
+    }
+    if (["70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99"].includes(prefix)) { // Nordeste/Norte
+      base = 29.9; days = 8;
     }
-  } catch (error) {
-    console.error('‚ùå Erro ao buscar configura√ß√µes:', error);
-    res.status(500).json({ error: 'Erro ao buscar configura√ß√µes' });
+    res.json({ price: Number(base.toFixed(2)), estimated_days: days, rule: 'region_base' });
+  } catch (e) {
+    console.error('Shipping quote error', e);
+    res.status(500).json({ error: 'shipping_quote_failed' });
   }
 });
 
-// Salvar configura√ß√µes do cliente
-app.put('/api/customers/:userId/settings', async (req, res) => {
+// ==========================
+// Cupons: valida√ß√£o simples
+// ==========================
+app.post('/api/coupons/validate', async (req, res) => {
   try {
-    let { userId } = req.params;
-    console.log(`üìç PUT /api/customers/${userId}/settings`);
+    const { code, subtotal } = req.body || {};
+    const normalized = String(code || '').trim().toUpperCase();
+    const sub = Number(subtotal || 0);
+    if (!normalized) return res.status(400).json({ valid: false, reason: 'empty' });
 
-    // Se userId parece ser email, buscar o ID do usu√°rio
-    if (userId.includes('@')) {
-      const [user] = await pool.execute('SELECT id FROM users WHERE email = ?', [userId]);
-      if (user && user[0]) {
-        userId = user[0].id;
-      } else {
-        return res.status(404).json({ error: 'Usu√°rio n√£o encontrado' });
+    if (normalized === 'FRETEGRATIS') {
+      if (sub >= 50) {
+        return res.json({ valid: true, type: 'shipping_free', min_subtotal: 50 });
       }
+      return res.json({ valid: false, reason: 'min_subtotal', min_subtotal: 50 });
     }
 
-    const { privacy, preferences } = req.body;
-    console.log('üìù Salvando configura√ß√µes:', { privacy, preferences });
-
-    // Verificar se j√° existe configura√ß√£o
-    const [existing] = await pool.execute(`
-      SELECT id FROM customer_settings WHERE customer_id = ?
-    `, [userId]);
+    // Percentual: PERCENT10 => 10% de desconto sobre o subtotal
+    const percentMatch = normalized.match(/^PERCENT(\d{1,2})$/);
+    if (percentMatch) {
+      const pct = Math.max(0, Math.min(90, Number(percentMatch[1])));
+      if (pct > 0) {
+        return res.json({ valid: true, type: 'percent', percent: pct });
+      }
+    }
 
-    if (existing.length > 0) {
-      // Atualizar configura√ß√µes existentes
-      await pool.execute(`
-        UPDATE customer_settings SET
-          show_profile = ?,
-          show_purchase_history = ?,
-          show_wishlist = ?,
-          allow_marketing = ?,
-          allow_analytics = ?,
-          allow_cookies = ?,
-          language = ?,
-          currency = ?,
-          theme = ?,
-          email_frequency = ?,
-          two_factor_auth = ?,
-          updated_at = NOW()
-        WHERE customer_id = ?
-      `, [
-        privacy?.showProfile || true,
-        privacy?.showPurchaseHistory || false,
-        privacy?.showWishlist || false,
-        privacy?.allowMarketing || true,
-        privacy?.allowAnalytics || true,
-        privacy?.allowCookies || true,
-        preferences?.language || 'pt-BR',
-        preferences?.currency || 'BRL',
-        preferences?.theme || 'light',
-        preferences?.emailFrequency || 'weekly',
-        preferences?.twoFactorAuth || false,
-        userId
-      ]);
-    } else {
-      // Criar novas configura√ß√µes
-      await pool.execute(`
-        INSERT INTO customer_settings (
-          customer_id,
-          show_profile,
-          show_purchase_history,
-          show_wishlist,
-          allow_marketing,
-          allow_analytics,
-          allow_cookies,
-          language,
-          currency,
-          theme,
-          email_frequency,
-          two_factor_auth,
-          created_at,
-          updated_at
-        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, NOW(), NOW())
-      `, [
-        userId,
-        privacy?.showProfile || true,
-        privacy?.showPurchaseHistory || false,
-        privacy?.showWishlist || false,
-        privacy?.allowMarketing || true,
-        privacy?.allowAnalytics || true,
-        privacy?.allowCookies || true,
-        preferences?.language || 'pt-BR',
-        preferences?.currency || 'BRL',
-        preferences?.theme || 'light',
-        preferences?.emailFrequency || 'weekly',
-        preferences?.twoFactorAuth || false
-      ]);
+    // Valor fixo: OFF50 => R$ 50,00 de desconto (limitado ao subtotal)
+    const amountMatch = normalized.match(/^OFF(\d{1,4})$/);
+    if (amountMatch) {
+      const amount = Math.max(1, Math.min(1000, Number(amountMatch[1])));
+      if (amount > 0) {
+        return res.json({ valid: true, type: 'amount', amount });
+      }
     }
 
-    console.log('‚úÖ Configura√ß√µes salvas com sucesso');
-    res.json({ success: true, message: 'Configura√ß√µes salvas com sucesso' });
-  } catch (error) {
-    console.error('‚ùå Erro ao salvar configura√ß√µes:', error);
-    res.status(500).json({ error: 'Erro ao salvar configura√ß√µes', details: error.message });
+    // Placeholder para mais cupons
+    return res.json({ valid: false, reason: 'not_found' });
+  } catch (e) {
+    console.error('Coupon validate error', e);
+    res.status(500).json({ error: 'coupon_validate_failed' });
   }
 });
 
-// Buscar prefer√™ncias de notifica√ß√£o do cliente
-app.get('/api/customers/:userId/notification-preferences', async (req, res) => {
+// ==========================
+// Conta: altera√ß√£o de senha (simulado)
+// ==========================
+app.post('/api/account/password', async (req, res) => {
   try {
-    let { userId } = req.params;
-    console.log(`üìç GET /api/customers/${userId}/notification-preferences`);
-
-    // Se userId parece ser email, buscar o ID do usu√°rio
-    if (userId.includes('@')) {
-      const [user] = await pool.execute('SELECT id FROM users WHERE email = ?', [userId]);
-      if (user && user[0]) {
-        userId = user[0].id;
-      } else {
-        return res.status(404).json({ error: 'Usu√°rio n√£o encontrado' });
-      }
-    }
-
-    // Buscar prefer√™ncias da tabela customer_settings
-    const [settings] = await pool.execute(`
-      SELECT allow_marketing, allow_analytics FROM customer_settings WHERE customer_id = ?
-    `, [userId]);
-
-    if (settings.length > 0) {
-      res.json({
-        emailNotifications: settings[0].allow_marketing || true,
-        pushNotifications: settings[0].allow_analytics || true
-      });
-    } else {
-      // Retornar valores padr√£o
-      res.json({
-        emailNotifications: true,
-        pushNotifications: true
-      });
+    const { senhaAtual, novaSenha } = req.body || {};
+    if (!novaSenha || String(novaSenha).length < 6) {
+      return res.status(400).json({ ok: false, error: 'weak_password' });
     }
-  } catch (error) {
-    console.error('‚ùå Erro ao buscar prefer√™ncias de notifica√ß√£o:', error);
-    res.json({ emailNotifications: true, pushNotifications: true });
+    // Em um cen√°rio real: validar senhaAtual contra hash do usu√°rio autenticado e persistir hash da nova senha.
+    console.log('üîê Altera√ß√£o de senha solicitada');
+    return res.json({ ok: true });
+  } catch (e) {
+    console.error('Change password error', e);
+    res.status(500).json({ ok: false, error: 'change_password_failed' });
   }
 });
 
-// Salvar prefer√™ncias de notifica√ß√£o do cliente
-app.put('/api/customers/:userId/notification-preferences', async (req, res) => {
+// ========== ENDPOINTS WHATSAPP ==========
+
+// Endpoint para obter configura√ß√µes WhatsApp
+app.get('/api/whatsapp/config', async (req, res) => {
   try {
-    let { userId } = req.params;
-    console.log(`üìç PUT /api/customers/${userId}/notification-preferences`);
+    const [settingsRows] = await pool.execute(`
+      SELECT key_name, value_text 
+      FROM settings 
+      WHERE key_name IN ('whatsapp_webhook_url', 'whatsapp_token', 'whatsapp_phone_id', 'whatsapp_webhook_secret', 'whatsapp_auto_reply', 'whatsapp_welcome_message')
+    `);
 
-    // Se userId parece ser email, buscar o ID do usu√°rio
-    if (userId.includes('@')) {
-      const [user] = await pool.execute('SELECT id FROM users WHERE email = ?', [userId]);
-      if (user && user[0]) {
-        userId = user[0].id;
-      } else {
-        return res.status(404).json({ error: 'Usu√°rio n√£o encontrado' });
+    const settings = {};
+    settingsRows.forEach(row => {
+      settings[row.key_name] = row.value_text;
+    });
+
+    res.json({
+      success: true,
+      config: {
+        webhook_url: settings.whatsapp_webhook_url || '',
+        token: settings.whatsapp_token ? '***' + settings.whatsapp_token.slice(-4) : '',
+        phone_id: settings.whatsapp_phone_id || '',
+        webhook_secret: settings.whatsapp_webhook_secret ? '***' + settings.whatsapp_webhook_secret.slice(-4) : '',
+        auto_reply: settings.whatsapp_auto_reply === 'true',
+        welcome_message: settings.whatsapp_welcome_message || 'Ol√°! Como posso ajud√°-lo hoje?'
       }
-    }
+    });
+  } catch (e) {
+    console.error('WhatsApp config error', e);
+    res.status(500).json({ error: 'config_fetch_failed' });
+  }
+});
 
-    const { emailNotifications, pushNotifications } = req.body;
-    console.log('üìù Salvando prefer√™ncias de notifica√ß√£o:', { emailNotifications, pushNotifications });
+// Endpoint para salvar configura√ß√µes WhatsApp
+app.put('/api/whatsapp/config', async (req, res) => {
+  try {
+    const { webhook_url, token, phone_id, webhook_secret, auto_reply, welcome_message } = req.body;
 
-    // Verificar se j√° existe configura√ß√£o
-    const [existing] = await pool.execute(`
-      SELECT id FROM customer_settings WHERE customer_id = ?
-    `, [userId]);
+    const settings = [
+      ['whatsapp_webhook_url', webhook_url],
+      ['whatsapp_token', token],
+      ['whatsapp_phone_id', phone_id],
+      ['whatsapp_webhook_secret', webhook_secret],
+      ['whatsapp_auto_reply', auto_reply ? 'true' : 'false'],
+      ['whatsapp_welcome_message', welcome_message]
+    ];
 
-    if (existing.length > 0) {
-      // Atualizar configura√ß√µes existentes
-      await pool.execute(`
-        UPDATE customer_settings SET
-          allow_marketing = ?,
-          allow_analytics = ?,
-          updated_at = NOW()
-        WHERE customer_id = ?
-      `, [emailNotifications ? 1 : 0, pushNotifications ? 1 : 0, userId]);
-    } else {
-      // Criar novas configura√ß√µes
-      await pool.execute(`
-        INSERT INTO customer_settings (
-          customer_id,
-          allow_marketing,
-          allow_analytics,
-          created_at,
-          updated_at
-        ) VALUES (?, ?, ?, NOW(), NOW())
-      `, [userId, emailNotifications ? 1 : 0, pushNotifications ? 1 : 0]);
+    for (const [key, value] of settings) {
+      if (value !== undefined) {
+        await pool.execute(`
+          INSERT INTO settings (key_name, value_text, updated_at) 
+          VALUES (?, ?, NOW()) 
+          ON DUPLICATE KEY UPDATE value_text = VALUES(value_text), updated_at = NOW()
+        `, [key, value]);
+      }
     }
 
-    console.log('‚úÖ Prefer√™ncias de notifica√ß√£o salvas com sucesso');
-    res.json({ success: true, message: 'Prefer√™ncias salvas com sucesso' });
-  } catch (error) {
-    console.error('‚ùå Erro ao salvar prefer√™ncias de notifica√ß√£o:', error);
-    res.status(500).json({ error: 'Erro ao salvar prefer√™ncias', details: error.message });
+    res.json({ success: true, message: 'Configura√ß√µes WhatsApp salvas com sucesso!' });
+  } catch (e) {
+    console.error('WhatsApp config save error', e);
+    res.status(500).json({ error: 'config_save_failed' });
   }
 });
 
-// Buscar sess√µes ativas do cliente
-app.get('/api/customers/:userId/sessions', async (req, res) => {
+// Endpoint para testar webhook WhatsApp
+app.post('/api/whatsapp/test-webhook', async (req, res) => {
   try {
-    let { userId } = req.params;
-    console.log(`üìç GET /api/customers/${userId}/sessions`);
-
-    // Se userId parece ser email, buscar o ID do usu√°rio
-    if (userId.includes('@')) {
-      const [user] = await pool.execute('SELECT id, email FROM users WHERE email = ?', [userId]);
-      if (user && user[0]) {
-        userId = user[0].id;
-        // Buscar sess√µes por user_id E por email
-        const [sessions] = await pool.execute(`
-          SELECT 
-            id,
-            user_id,
-            user_email,
-            created_at,
-            updated_at
-          FROM sessions 
-          WHERE user_id = ? OR user_email = ?
-          ORDER BY created_at DESC
-          LIMIT 10
-        `, [userId, user[0].email]);
+    const { webhook_url } = req.body;
 
-        return res.json({
-          sessions: sessions.map(s => ({
-            id: s.id,
-            device: 'Navegador',
-            location: 'Brasil',
-            lastActive: s.updated_at || s.created_at,
-            current: true
-          }))
-        });
-      } else {
-        return res.status(404).json({ error: 'Usu√°rio n√£o encontrado', sessions: [] });
-      }
+    if (!webhook_url) {
+      return res.status(400).json({ error: 'URL do webhook √© obrigat√≥ria' });
     }
 
-    // Buscar sess√µes por user_id
-    const [sessions] = await pool.execute(`
-      SELECT 
-        id,
-        user_id,
-        user_email,
-        created_at,
-        updated_at
-      FROM sessions 
-      WHERE user_id = ?
-      ORDER BY created_at DESC
-      LIMIT 10
-    `, [userId]);
+    // Simular teste do webhook
+    const testData = {
+      test: true,
+      message: 'Teste de webhook realizado com sucesso!',
+      timestamp: new Date().toISOString()
+    };
+
+    // Aqui voc√™ faria uma requisi√ß√£o real para testar o webhook
+    // const response = await fetch(webhook_url, { method: 'POST', body: JSON.stringify(testData) });
 
     res.json({
-      sessions: sessions.map(s => ({
-        id: s.id,
-        device: 'Navegador',
-        location: 'Brasil',
-        lastActive: s.updated_at || s.created_at,
-        current: true
-      }))
+      success: true,
+      message: 'Webhook testado com sucesso!',
+      test_data: testData
     });
-  } catch (error) {
-    console.error('‚ùå Erro ao buscar sess√µes:', error);
-    res.json({ sessions: [] });
+  } catch (e) {
+    console.error('WhatsApp webhook test error', e);
+    res.status(500).json({ error: 'webhook_test_failed' });
   }
 });
 
-// Criar tabela de configura√ß√µes do cliente se n√£o existir
-(async () => {
+// Endpoint para obter estat√≠sticas WhatsApp
+app.get('/api/whatsapp/stats', async (req, res) => {
   try {
-    await pool.execute(`
-      CREATE TABLE IF NOT EXISTS customer_settings (
-        id INT AUTO_INCREMENT PRIMARY KEY,
-        customer_id VARCHAR(191) NOT NULL,
-        show_profile TINYINT(1) DEFAULT 1,
-        show_purchase_history TINYINT(1) DEFAULT 0,
-        show_wishlist TINYINT(1) DEFAULT 0,
-        allow_marketing TINYINT(1) DEFAULT 1,
-        allow_analytics TINYINT(1) DEFAULT 1,
-        allow_cookies TINYINT(1) DEFAULT 1,
-        language VARCHAR(10) DEFAULT 'pt-BR',
-        currency VARCHAR(10) DEFAULT 'BRL',
-        theme VARCHAR(20) DEFAULT 'light',
-        email_frequency VARCHAR(20) DEFAULT 'weekly',
-        two_factor_auth TINYINT(1) DEFAULT 0,
-        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
-        updated_at DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
-        UNIQUE KEY unique_customer (customer_id)
-      ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4
+    // Verificar se a tabela existe
+    const [tableExists] = await pool.execute(`
+      SELECT COUNT(*) as count 
+      FROM information_schema.tables 
+      WHERE table_schema = DATABASE() AND table_name = 'whatsapp_messages'
     `);
-    console.log('‚úÖ Tabela customer_settings criada/verificada');
+
+    if (tableExists[0].count === 0) {
+      return res.json({
+        success: true,
+        stats: {
+          total_messages: 0,
+          incoming_messages: 0,
+          outgoing_messages: 0,
+          unique_contacts: 0,
+          messages_today: 0
+        }
+      });
+    }
+
+    const [stats] = await pool.execute(`
+      SELECT 
+        COUNT(*) as total_messages,
+        COUNT(CASE WHEN direction = 'incoming' THEN 1 END) as incoming_messages,
+        COUNT(CASE WHEN direction = 'outgoing' THEN 1 END) as outgoing_messages,
+        COUNT(DISTINCT from_phone) as unique_contacts,
+        COUNT(CASE WHEN DATE(timestamp) = CURDATE() THEN 1 END) as messages_today
+      FROM whatsapp_messages
+    `);
+
+    res.json({ success: true, stats: stats[0] });
   } catch (e) {
-    console.error('‚ùå Erro ao criar tabela customer_settings:', e);
+    console.error('WhatsApp stats error', e);
+    res.status(500).json({ error: 'stats_fetch_failed' });
   }
-})();
+});
 
-// ===================================
-// TABELAS DE CUPONS (Sistema Avan√ßado)
-// ===================================
-(async () => {
+// Endpoint para enviar mensagem WhatsApp
+app.post('/api/whatsapp/send-message', async (req, res) => {
   try {
-    await pool.query(`
-      CREATE TABLE IF NOT EXISTS coupons (
-        id VARCHAR(191) PRIMARY KEY,
-        code VARCHAR(50) NOT NULL UNIQUE,
-        name VARCHAR(255) NOT NULL,
-        description TEXT,
-        type ENUM('percentage', 'fixed_amount', 'free_shipping') NOT NULL,
-        value DECIMAL(10, 2) NOT NULL,
-        min_order_amount DECIMAL(10, 2) DEFAULT 0,
-        max_discount_amount DECIMAL(10, 2) NULL,
-        usage_limit INT NULL,
-        usage_limit_per_user INT DEFAULT 1,
-        used_count INT DEFAULT 0,
-        is_active BOOLEAN DEFAULT TRUE,
-        is_public BOOLEAN DEFAULT FALSE,
-        starts_at DATETIME NULL,
-        expires_at DATETIME NULL,
-        category VARCHAR(50) NULL COMMENT 'birthday, first_purchase, loyalty, promotion',
-        created_by VARCHAR(191) NULL,
-        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
-        updated_at DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
-        INDEX idx_code (code),
-        INDEX idx_active (is_active),
-        INDEX idx_category (category),
-        INDEX idx_expires (expires_at)
-      ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci
-    `);
-    console.log('‚úÖ Tabela coupons criada/verificada');
+    const { to, message } = req.body;
+
+    if (!to || !message) {
+      return res.status(400).json({ error: 'N√∫mero e mensagem s√£o obrigat√≥rios' });
+    }
+
+    // Buscar token WhatsApp
+    const [tokenRows] = await pool.execute('SELECT value_text FROM settings WHERE key_name = ?', ['whatsapp_token']);
+    const [phoneIdRows] = await pool.execute('SELECT value_text FROM settings WHERE key_name = ?', ['whatsapp_phone_id']);
+
+    if (tokenRows.length === 0 || phoneIdRows.length === 0) {
+      return res.status(400).json({ error: 'Token ou Phone ID do WhatsApp n√£o configurados' });
+    }
+
+    const token = tokenRows[0].value_text;
+    const phoneId = phoneIdRows[0].value_text;
+
+    // Enviar mensagem via WhatsApp API
+    const response = await fetch(`https://graph.facebook.com/v18.0/${phoneId}/messages`, {
+      method: 'POST',
+      headers: {
+        'Authorization': `Bearer ${token}`,
+        'Content-Type': 'application/json'
+      },
+      body: JSON.stringify({
+        messaging_product: 'whatsapp',
+        to: to,
+        type: 'text',
+        text: { body: message }
+      })
+    });
+
+    if (!response.ok) {
+      throw new Error('Falha ao enviar mensagem via WhatsApp API');
+    }
+
+    const result = await response.json();
+
+    res.json({
+      success: true,
+      message: 'Mensagem enviada com sucesso!',
+      whatsapp_response: result
+    });
   } catch (e) {
-    console.error('‚ùå Erro ao criar tabela coupons:', e);
+    console.error('WhatsApp send message error', e);
+    res.status(500).json({ error: 'message_send_failed' });
   }
-})();
+});
 
-(async () => {
+// Endpoint para obter mensagens WhatsApp
+app.get('/api/whatsapp/messages', async (req, res) => {
   try {
-    await pool.query(`
-      CREATE TABLE IF NOT EXISTS user_coupons (
-        id VARCHAR(191) PRIMARY KEY,
-        user_id VARCHAR(191) NOT NULL,
-        coupon_id VARCHAR(191) NOT NULL,
-        assigned_at DATETIME DEFAULT CURRENT_TIMESTAMP,
-        expires_at DATETIME NULL,
-        is_used BOOLEAN DEFAULT FALSE,
-        used_at DATETIME NULL,
-        order_id VARCHAR(191) NULL,
-        FOREIGN KEY (coupon_id) REFERENCES coupons(id) ON DELETE CASCADE,
-        INDEX idx_user (user_id),
-        INDEX idx_coupon (coupon_id),
-        INDEX idx_used (is_used),
-        UNIQUE KEY unique_user_coupon (user_id, coupon_id)
-      ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci
+    const { page = 1, limit = 50 } = req.query;
+    const offset = (page - 1) * limit;
+
+    // Verificar se a tabela existe
+    const [tableExists] = await pool.execute(`
+      SELECT COUNT(*) as count 
+      FROM information_schema.tables 
+      WHERE table_schema = DATABASE() AND table_name = 'whatsapp_messages'
     `);
-    console.log('‚úÖ Tabela user_coupons criada/verificada');
+
+    if (tableExists[0].count === 0) {
+      return res.json({
+        success: true,
+        messages: [],
+        pagination: { page: 1, limit, total: 0, pages: 0 }
+      });
+    }
+
+    const [messages] = await pool.execute(`
+      SELECT * FROM whatsapp_messages 
+      ORDER BY timestamp DESC 
+      LIMIT ? OFFSET ?
+    `, [parseInt(limit), parseInt(offset)]);
+
+    const [totalRows] = await pool.execute('SELECT COUNT(*) as total FROM whatsapp_messages');
+    const total = totalRows[0].total;
+
+    res.json({
+      success: true,
+      messages,
+      pagination: {
+        page: parseInt(page),
+        limit: parseInt(limit),
+        total,
+        pages: Math.ceil(total / limit)
+      }
+    });
   } catch (e) {
-    console.error('‚ùå Erro ao criar tabela user_coupons:', e);
+    console.error('WhatsApp messages error', e);
+    res.status(500).json({ error: 'messages_fetch_failed' });
   }
-})();
+});
 
-(async () => {
+// ==========================
+// Conta: atualiza√ß√£o de perfil (simulado)
+// ==========================
+app.post('/api/account/profile', async (req, res) => {
   try {
-    await pool.query(`
-      CREATE TABLE IF NOT EXISTS coupon_usage (
-        id VARCHAR(191) PRIMARY KEY,
-        coupon_id VARCHAR(191) NOT NULL,
-        user_id VARCHAR(191) NULL,
-        order_id VARCHAR(191) NULL,
-        discount_amount DECIMAL(10, 2) NOT NULL,
-        used_at DATETIME DEFAULT CURRENT_TIMESTAMP,
-        FOREIGN KEY (coupon_id) REFERENCES coupons(id) ON DELETE CASCADE,
-        INDEX idx_coupon (coupon_id),
-        INDEX idx_user (user_id),
-        INDEX idx_order (order_id),
-        INDEX idx_used_at (used_at)
-      ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci
-    `);
-    console.log('‚úÖ Tabela coupon_usage criada/verificada');
+    const { nome, email, telefone, avatar_url, endereco, cidade, estado, cep } = req.body || {};
+    // Em um cen√°rio real: atualizar tabela users vinculada ao auth
+    console.log('üë§ Atualiza√ß√£o de perfil:', { nome, email, telefone });
+    // Devolver os dados normalizados para o frontend atualizar contexto
+    res.json({ ok: true, user: { nome, email, telefone, avatar_url, endereco, cidade, estado, cep } });
   } catch (e) {
-    console.error('‚ùå Erro ao criar tabela coupon_usage:', e);
+    console.error('Profile update error', e);
+    res.status(500).json({ ok: false, error: 'profile_update_failed' });
   }
-})();
+});
+
+// ==========================
+// Auth simulado: me/logout para persistir sess√£o com cookie
+// ==========================
+// Endpoint /api/auth/me removido - usando o principal acima
 
-// Registrar rotas avan√ßadas de pedidos
-const adminOrdersAdvancedRouter = require('./routes/admin-orders-advanced.cjs');
-app.use('/api/admin', adminOrdersAdvancedRouter);
+// NOTA: Endpoint de login mock removido - usando apenas o sistema de sess√£o principal
 
-console.log('‚úÖ Endpoints da API para dados reais carregados com sucesso!');
+// Rota de logout removida (consolidada na primeira ocorr√™ncia)
 
-// ==================== SISTEMA DE AUTOMA√á√ÉO DE CUPONS ====================
-const couponAutomation = require('./coupon-automation.cjs');
+// ==================== NOVOS ENDPOINTS MINHA CONTA ====================
 
-// Endpoint para executar manualmente todas as automa√ß√µes
-app.post('/api/admin/coupons/run-automations', async (req, res) => {
+// Notifica√ß√µes
+app.get('/api/customers/:userId/notifications', async (req, res) => {
   try {
-    console.log('ü§ñ [API] Executando automa√ß√µes de cupons manualmente...');
-    const results = await couponAutomation.runAllAutomations(pool);
-    res.json({ success: true, results });
+    let { userId } = req.params;
+    if (userId.includes('@')) {
+      const [user] = await pool.execute('SELECT id FROM users WHERE email = ?', [userId]);
+      if (user && user[0]) userId = user[0].id;
+      else return res.status(404).json({ error: 'Usu√°rio n√£o encontrado' });
+    }
+    const [notifications] = await pool.execute('SELECT * FROM customer_notifications WHERE customer_id = ? ORDER BY created_at DESC', [userId]);
+    res.json({ notifications });
   } catch (error) {
-    console.error('‚ùå [API] Erro ao executar automa√ß√µes:', error);
-    res.status(500).json({ error: 'Erro ao executar automa√ß√µes' });
+    res.status(500).json({ error: 'Erro ao buscar notifica√ß√µes', notifications: [] });
   }
 });
 
-// Endpoint para gerar cupom de primeira compra (chamado ap√≥s criar pedido)
-app.post('/api/coupons/first-purchase/:customerId', async (req, res) => {
+// Cupons
+app.get('/api/customers/:userId/coupons', async (req, res) => {
   try {
-    const { customerId } = req.params;
-    const result = await couponAutomation.generateFirstPurchaseCoupon(pool, customerId);
-    res.json(result);
+    let { userId } = req.params;
+    if (userId.includes('@')) {
+      const [user] = await pool.execute('SELECT id FROM users WHERE email = ?', [userId]);
+      if (user && user[0]) userId = user[0].id;
+    }
+    const [coupons] = await pool.execute('SELECT * FROM customer_coupons WHERE customer_id = ? ORDER BY created_at DESC', [userId]);
+    res.json({ coupons });
   } catch (error) {
-    console.error('‚ùå [API] Erro ao gerar cupom de primeira compra:', error);
-    res.status(500).json({ error: 'Erro ao gerar cupom' });
+    res.status(500).json({ error: 'Erro ao buscar cupons', coupons: [] });
   }
 });
 
-// ==================== SUPPORT ADMIN ENDPOINTS ====================
-
-// GET FAQs
-app.get('/api/admin/suporte/faqs', authenticateAdmin, async (req, res) => {
+// Fidelidade
+app.get('/api/customers/:userId/loyalty', async (req, res) => {
   try {
-    const [rows] = await pool.execute(
-      'SELECT setting_value FROM support_settings WHERE setting_key = ?',
-      ['faqs']
-    );
-
-    const faqs = rows.length > 0 ? JSON.parse(rows[0].setting_value) : [];
-    res.json({ faqs });
+    let { userId } = req.params;
+    if (userId.includes('@')) {
+      const [user] = await pool.execute('SELECT id FROM users WHERE email = ?', [userId]);
+      if (user && user[0]) userId = user[0].id;
+    }
+    const [orders] = await pool.execute('SELECT COALESCE(SUM(total), 0) as totalSpent FROM orders WHERE user_id = ? AND status != "cancelled"', [userId]);
+    const totalSpent = Number(orders[0]?.totalSpent || 0);
+    const points = Math.floor(totalSpent / 10);
+    let level = 'Bronze', nextLevelPoints = 100;
+    if (points >= 500) { level = 'Platinum'; nextLevelPoints = 1000; }
+    else if (points >= 250) { level = 'Gold'; nextLevelPoints = 500; }
+    else if (points >= 100) { level = 'Silver'; nextLevelPoints = 250; }
+    res.json({ points, totalPoints: points, level, nextLevelPoints, couponsRedeemed: 0, totalSavings: totalSpent * 0.05 });
   } catch (error) {
-    console.error('‚ùå Erro ao buscar FAQs:', error);
-    res.status(500).json({ error: 'Erro ao buscar FAQs', faqs: [] });
+    res.status(500).json({ error: 'Erro ao buscar fidelidade' });
   }
 });
 
-// POST FAQs
-app.post('/api/admin/suporte/faqs', authenticateAdmin, async (req, res) => {
+// Reviews do cliente
+app.get('/api/customers/:userId/reviews', async (req, res) => {
   try {
-    const { faqs } = req.body;
-
-    await pool.execute(
-      `INSERT INTO support_settings (setting_key, setting_value) 
-       VALUES (?, ?) 
-       ON DUPLICATE KEY UPDATE setting_value = ?`,
-      ['faqs', JSON.stringify(faqs), JSON.stringify(faqs)]
-    );
-
-    res.json({ success: true });
+    let { userId } = req.params;
+    if (userId.includes('@')) {
+      const [user] = await pool.execute('SELECT id FROM users WHERE email = ?', [userId]);
+      if (user && user[0]) userId = user[0].id;
+    }
+    const [reviews] = await pool.execute('SELECT r.*, p.nome as product_name, p.imagem_url as product_image FROM product_reviews r LEFT JOIN products p ON r.product_id = p.id WHERE r.user_id = ? ORDER BY r.created_at DESC', [userId]);
+    res.json({ reviews: reviews.map(r => ({ ...r, product: { id: r.product_id, nome: r.product_name, imagem_url: r.product_image } })) });
   } catch (error) {
-    console.error('‚ùå Erro ao salvar FAQs:', error);
-    res.status(500).json({ error: 'Erro ao salvar FAQs' });
+    res.status(500).json({ error: 'Erro ao buscar avalia√ß√µes', reviews: [] });
   }
 });
 
-// GET Contact Info
-app.get('/api/admin/suporte/contact', authenticateAdmin, async (req, res) => {
+// Stats de reviews
+app.get('/api/customers/:userId/review-stats', async (req, res) => {
   try {
-    const [rows] = await pool.execute(
-      'SELECT setting_value FROM support_settings WHERE setting_key = ?',
-      ['contact_info']
-    );
-
-    const contact = rows.length > 0 ? JSON.parse(rows[0].setting_value) : null;
-    res.json({ contact });
+    let { userId } = req.params;
+    if (userId.includes('@')) {
+      const [user] = await pool.execute('SELECT id FROM users WHERE email = ?', [userId]);
+      if (user && user[0]) userId = user[0].id;
+    }
+    const [stats] = await pool.execute('SELECT COUNT(*) as totalReviews, AVG(rating) as averageRating, SUM(helpful_count) as helpfulVotes, SUM(CASE WHEN featured = 1 THEN 1 ELSE 0 END) as featured FROM product_reviews WHERE user_id = ?', [userId]);
+    res.json(stats[0] || { totalReviews: 0, averageRating: 0, helpfulVotes: 0, featured: 0 });
   } catch (error) {
-    console.error('‚ùå Erro ao buscar contato:', error);
-    res.status(500).json({ error: 'Erro ao buscar contato' });
+    res.status(500).json({ error: 'Erro', totalReviews: 0, averageRating: 0, helpfulVotes: 0, featured: 0 });
   }
 });
 
-// POST Contact Info
-app.post('/api/admin/suporte/contact', authenticateAdmin, async (req, res) => {
+// NOTA: Endpoints de configura√ß√µes movidos para linha ~11682 (vers√£o atualizada)
+
+// Atualizar configura√ß√µes de privacidade
+app.put('/api/customers/:userId/settings/privacy', async (req, res) => {
   try {
-    const contactInfo = req.body;
+    let { userId } = req.params;
+    console.log(`üìù PUT /api/customers/${userId}/settings/privacy`);
 
-    await pool.execute(
-      `INSERT INTO support_settings (setting_key, setting_value) 
-       VALUES (?, ?) 
-       ON DUPLICATE KEY UPDATE setting_value = ?`,
-      ['contact_info', JSON.stringify(contactInfo), JSON.stringify(contactInfo)]
-    );
+    if (userId.includes('@')) {
+      const [user] = await pool.execute('SELECT id FROM users WHERE email = ?', [userId]);
+      if (user && user[0]) userId = user[0].id;
+    }
 
-    res.json({ success: true });
-  } catch (error) {
-    console.error('‚ùå Erro ao salvar contato:', error);
-    res.status(500).json({ error: 'Erro ao salvar contato' });
-  }
-});
+    const privacySettings = req.body;
 
-// GET Store Location
-app.get('/api/admin/suporte/location', authenticateAdmin, async (req, res) => {
-  try {
-    const [rows] = await pool.execute(
-      'SELECT setting_value FROM support_settings WHERE setting_key = ?',
-      ['store_location']
-    );
+    // Verificar se j√° existe configura√ß√£o
+    const [existing] = await pool.execute('SELECT id FROM customer_settings WHERE customer_id = ?', [userId]);
+
+    if (existing.length > 0) {
+      // Atualizar
+      await pool.execute(
+        'UPDATE customer_settings SET privacy = ? WHERE customer_id = ?',
+        [JSON.stringify(privacySettings), userId]
+      );
+    } else {
+      // Criar
+      await pool.execute(
+        'INSERT INTO customer_settings (id, customer_id, privacy) VALUES (?, ?, ?)',
+        [require('crypto').randomUUID(), userId, JSON.stringify(privacySettings)]
+      );
+    }
 
-    const location = rows.length > 0 ? JSON.parse(rows[0].setting_value) : null;
-    res.json({ location });
+    console.log(`‚úÖ Configura√ß√µes de privacidade atualizadas para ${userId}`);
+    res.json({ success: true, privacy: privacySettings });
   } catch (error) {
-    console.error('‚ùå Erro ao buscar localiza√ß√£o:', error);
-    res.status(500).json({ error: 'Erro ao buscar localiza√ß√£o' });
+    console.error('‚ùå Erro ao atualizar configura√ß√µes de privacidade:', error);
+    res.status(500).json({ error: 'Erro ao atualizar configura√ß√µes' });
   }
 });
 
-// POST Store Location
-app.post('/api/admin/suporte/location', authenticateAdmin, async (req, res) => {
+// Recomenda√ß√µes
+app.get('/api/customers/:userId/recommendations', async (req, res) => {
   try {
-    const location = req.body;
+    let { userId } = req.params;
+    if (userId.includes('@')) {
+      const [user] = await pool.execute('SELECT id FROM users WHERE email = ?', [userId]);
+      if (user && user[0]) userId = user[0].id;
+    }
+    // Buscar email do usu√°rio para recommendations
+    const [userEmail] = await pool.execute('SELECT email FROM users WHERE id = ?', [userId]);
+    const email = userEmail[0]?.email || null;
 
-    await pool.execute(
-      `INSERT INTO support_settings (setting_key, setting_value) 
-       VALUES (?, ?) 
-       ON DUPLICATE KEY UPDATE setting_value = ?`,
-      ['store_location', JSON.stringify(location), JSON.stringify(location)]
-    );
+    if (!email) {
+      return res.json({ recommendations: [] });
+    }
 
-    res.json({ success: true });
+    const [products] = await pool.execute('SELECT p.* FROM products p LEFT JOIN favorites f ON p.id = f.product_id AND f.user_email = ? WHERE f.id IS NULL AND p.status = "ativo" ORDER BY p.created_at DESC LIMIT 10', [email]);
+    res.json({ recommendations: products });
   } catch (error) {
-    console.error('‚ùå Erro ao salvar localiza√ß√£o:', error);
-    res.status(500).json({ error: 'Erro ao salvar localiza√ß√£o' });
+    res.status(500).json({ error: 'Erro', recommendations: [] });
   }
 });
 
-// Public endpoint para p√°gina de suporte (sem autentica√ß√£o)
-app.get('/api/suporte/config', async (req, res) => {
+// Insights de pedidos
+app.get('/api/customers/:userId/order-insights', async (req, res) => {
   try {
-    const [faqs] = await pool.execute(
-      'SELECT setting_value FROM support_settings WHERE setting_key = ?',
-      ['faqs']
-    );
-
-    const [contact] = await pool.execute(
-      'SELECT setting_value FROM support_settings WHERE setting_key = ?',
-      ['contact_info']
-    );
-
-    const [location] = await pool.execute(
-      'SELECT setting_value FROM support_settings WHERE setting_key = ?',
-      ['store_location']
-    );
-
-    res.json({
-      faqs: faqs.length > 0 ? JSON.parse(faqs[0].setting_value) : [],
-      contactInfo: contact.length > 0 ? JSON.parse(contact[0].setting_value) : {},
-      storeLocation: location.length > 0 ? JSON.parse(location[0].setting_value) : {}
-    });
+    let { userId } = req.params;
+    if (userId.includes('@')) {
+      const [user] = await pool.execute('SELECT id FROM users WHERE email = ?', [userId]);
+      if (user && user[0]) userId = user[0].id;
+    }
+    const [orders] = await pool.execute('SELECT AVG(total) as averageOrderValue, COUNT(*) as totalOrders, SUM(CASE WHEN status != "cancelled" THEN total ELSE 0 END) as totalSpent FROM orders WHERE user_id = ?', [userId]);
+    const stats = orders[0];
+    res.json({ averageOrderValue: Number(stats.averageOrderValue || 0), mostOrderedCategory: 'Brinquedos', favoritePaymentMethod: 'PIX', orderFrequency: 30, totalSavings: Number(stats.totalSpent || 0) * 0.05 });
   } catch (error) {
-    console.error('‚ùå Erro ao buscar config de suporte:', error);
-    res.status(500).json({ error: 'Erro ao buscar configura√ß√µes' });
+    res.status(500).json({ error: 'Erro', averageOrderValue: 0, mostOrderedCategory: 'N/A', favoritePaymentMethod: 'PIX', orderFrequency: 0, totalSavings: 0 });
   }
 });
 
-// ==================== END SUPPORT ADMIN ENDPOINTS ====================
-
-// ==================== LEGAL PAGES ENDPOINTS ====================
-
-// GET all legal pages (public)
-app.get('/api/legal-pages', async (req, res) => {
+// Pendentes de avalia√ß√£o
+app.get('/api/customers/:userId/pending-reviews', async (req, res) => {
   try {
-    const [pages] = await pool.execute(
-      'SELECT id, slug, title, meta_description, is_published, updated_at FROM legal_pages WHERE is_published = TRUE ORDER BY title'
-    );
-    res.json(pages);
+    let { userId } = req.params;
+    if (userId.includes('@')) {
+      const [user] = await pool.execute('SELECT id FROM users WHERE email = ?', [userId]);
+      if (user && user[0]) userId = user[0].id;
+    }
+    const [products] = await pool.execute('SELECT DISTINCT p.id, p.nome, p.imagem_url, o.created_at as purchaseDate FROM orders o JOIN order_items oi ON o.id = oi.order_id JOIN products p ON oi.product_id = p.id LEFT JOIN product_reviews r ON r.product_id COLLATE utf8mb4_unicode_ci = p.id COLLATE utf8mb4_unicode_ci AND r.user_id COLLATE utf8mb4_unicode_ci = o.user_id COLLATE utf8mb4_unicode_ci WHERE o.user_id COLLATE utf8mb4_unicode_ci = ? COLLATE utf8mb4_unicode_ci AND o.status = "delivered" AND r.id IS NULL ORDER BY o.created_at DESC LIMIT 10', [userId]);
+    res.json({ products });
   } catch (error) {
-    console.error('‚ùå Erro ao buscar p√°ginas:', error);
-    res.status(500).json({ error: 'Erro ao buscar p√°ginas' });
+    res.status(500).json({ error: 'Erro', products: [] });
   }
 });
 
-// GET single page by slug (public)
-app.get('/api/legal-pages/:slug', async (req, res) => {
+// Estimativa de entrega
+app.post('/api/delivery-estimate', async (req, res) => {
+  const { estado } = req.body;
+  const regions = {
+    'SP': { days: '1-2', freight: '8.90', region: 'Sudeste' },
+    'RJ': { days: '1-3', freight: '9.90', region: 'Sudeste' },
+    'MG': { days: '2-4', freight: '12.90', region: 'Sudeste' },
+    'RS': { days: '3-5', freight: '15.90', region: 'Sul' },
+    'SC': { days: '3-5', freight: '14.90', region: 'Sul' },
+    'PR': { days: '2-4', freight: '13.90', region: 'Sul' },
+  };
+  res.json(regions[estado] || { days: '5-7', freight: '19.90', region: 'Outras' });
+});
+
+// ============================================
+// ROTAS DE LOGIN ADMINISTRATIVO
+// ============================================
+
+// POST /api/admin/login - Login administrativo
+app.post('/api/admin/login', async (req, res) => {
   try {
-    const { slug } = req.params;
-    const [pages] = await pool.execute(
-      'SELECT * FROM legal_pages WHERE slug = ? AND is_published = TRUE',
-      [slug]
-    );
+    const { email, senha, password } = req.body || {};
+    const mail = String(email || '').trim().toLowerCase();
+    const pass = String(password || senha || '');
 
-    if (pages.length === 0) {
-      return res.status(404).json({ error: 'P√°gina n√£o encontrada' });
+    if (!mail || !pass) {
+      return res.status(400).json({
+        ok: false,
+        error: 'missing_credentials',
+        message: 'Email e senha s√£o obrigat√≥rios'
+      });
     }
 
-    res.json(pages[0]);
-  } catch (error) {
-    console.error('‚ùå Erro ao buscar p√°gina:', error);
-    res.status(500).json({ error: 'Erro ao buscar p√°gina' });
-  }
-});
+    console.log(`üîê Tentativa de login admin: ${mail}`);
 
-// ADMIN: GET all pages (including unpublished)
-app.get('/api/admin/legal-pages', authenticateAdmin, async (req, res) => {
-  try {
-    const [pages] = await pool.execute(
-      'SELECT * FROM legal_pages ORDER BY title'
+    // Buscar usu√°rio admin
+    const [rows] = await pool.execute(
+      'SELECT id, nome, email, senha_hash, role, status FROM admin_users WHERE email = ? LIMIT 1',
+      [mail]
     );
-    res.json(pages);
-  } catch (error) {
-    console.error('‚ùå Erro ao buscar p√°ginas (admin):', error);
-    res.status(500).json({ error: 'Erro ao buscar p√°ginas' });
-  }
-});
 
-// ADMIN: GET single page by ID
-app.get('/api/admin/legal-pages/:id', authenticateAdmin, async (req, res) => {
-  try {
-    const { id } = req.params;
-    const [pages] = await pool.execute(
-      'SELECT * FROM legal_pages WHERE id = ?',
-      [id]
-    );
+    if (!Array.isArray(rows) || rows.length === 0) {
+      console.log(`‚ùå Usu√°rio admin n√£o encontrado: ${mail}`);
+      return res.status(401).json({
+        ok: false,
+        error: 'invalid_credentials',
+        message: 'Email ou senha incorretos'
+      });
+    }
+
+    const user = rows[0];
 
-    if (pages.length === 0) {
-      return res.status(404).json({ error: 'P√°gina n√£o encontrada' });
+    // Verificar se usu√°rio est√° ativo
+    if (user.status !== 'ativo') {
+      console.log(`‚ùå Usu√°rio admin inativo: ${mail}`);
+      return res.status(401).json({
+        ok: false,
+        error: 'account_inactive',
+        message: 'Conta inativa. Entre em contato com o administrador.'
+      });
     }
 
-    res.json(pages[0]);
-  } catch (error) {
-    console.error('‚ùå Erro ao buscar p√°gina (admin):', error);
-    res.status(500).json({ error: 'Erro ao buscar p√°gina' });
-  }
-});
+    // Verificar senha (SHA256 hash)
+    const crypto = require('crypto');
+    const senhaHash = crypto.createHash('sha256').update(pass).digest('hex');
+    const senhaCorreta = senhaHash === user.senha_hash;
 
-// ADMIN: UPDATE page
-app.put('/api/admin/legal-pages/:id', authenticateAdmin, async (req, res) => {
-  try {
-    const { id } = req.params;
-    const { title, content, meta_description, is_published } = req.body;
+    if (!senhaCorreta) {
+      console.log(`‚ùå Senha incorreta para: ${mail}`);
+      return res.status(401).json({
+        ok: false,
+        error: 'invalid_credentials',
+        message: 'Email ou senha incorretos'
+      });
+    }
 
-    await pool.execute(
-      `UPDATE legal_pages 
-       SET title = ?, content = ?, meta_description = ?, is_published = ?
-       WHERE id = ?`,
-      [title, content, meta_description || null, is_published, id]
+    // Gerar token JWT
+    const token = jwt.sign(
+      { id: user.id, role: user.role },
+      process.env.JWT_SECRET || 'rare-toy-secret-key-change-me',
+      { expiresIn: '7d' }
     );
 
-    console.log(`‚úÖ P√°gina ${id} atualizada`);
-    res.json({ success: true });
-  } catch (error) {
-    console.error('‚ùå Erro ao atualizar p√°gina:', error);
-    res.status(500).json({ error: 'Erro ao atualizar p√°gina' });
-  }
-});
-
-// ADMIN: CREATE page
-app.post('/api/admin/legal-pages', authenticateAdmin, async (req, res) => {
-  try {
-    const { slug, title, content, meta_description, is_published } = req.body;
+    // Salvar token no cookie
+    res.cookie('admin_token', token, {
+      httpOnly: true,
+      sameSite: 'lax',
+      secure: process.env.NODE_ENV === 'production',
+      maxAge: 1000 * 60 * 60 * 24 * 7 // 7 dias
+    });
 
-    const [result] = await pool.execute(
-      `INSERT INTO legal_pages (slug, title, content, meta_description, is_published) 
-       VALUES (?, ?, ?, ?, ?)`,
-      [slug, title, content, meta_description || null, is_published]
+    // Atualizar √∫ltimo acesso
+    await pool.execute(
+      'UPDATE admin_users SET last_access = NOW() WHERE id = ?',
+      [user.id]
     );
 
-    console.log(`‚úÖ P√°gina ${slug} criada`);
-    res.json({ success: true, id: result.insertId });
-  } catch (error) {
-    console.error('‚ùå Erro ao criar p√°gina:', error);
-    res.status(500).json({ error: 'Erro ao criar p√°gina' });
-  }
-});
-
-// ADMIN: DELETE page
-app.delete('/api/admin/legal-pages/:id', authenticateAdmin, async (req, res) => {
-  try {
-    const { id } = req.params;
+    console.log(`‚úÖ Login admin bem-sucedido: ${mail} (${user.role})`);
 
-    await pool.execute('DELETE FROM legal_pages WHERE id = ?', [id]);
+    res.json({
+      ok: true,
+      user: {
+        id: user.id,
+        nome: user.nome,
+        email: user.email,
+        role: user.role,
+        permissoes: user.permissoes ? JSON.parse(user.permissoes) : []
+      },
+      token
+    });
 
-    console.log(`‚úÖ P√°gina ${id} exclu√≠da`);
-    res.json({ success: true });
   } catch (error) {
-    console.error('‚ùå Erro ao excluir p√°gina:', error);
-    res.status(500).json({ error: 'Erro ao excluir p√°gina' });
+    console.error('‚ùå Erro no login admin:', error);
+    res.status(500).json({
+      ok: false,
+      error: 'login_failed',
+      message: 'Erro interno do servidor'
+    });
   }
 });
 
-// ==================== END LEGAL PAGES ENDPOINTS ====================
-
-// ==================== DATABASE BACKUP & RESTORE ENDPOINTS ====================
-const { exec } = require('child_process');
-const { promisify } = require('util');
-const execAsync = promisify(exec);
-
-// Diret√≥rio para armazenar backups
-const BACKUP_DIR = path.join(__dirname, '../backups');
-if (!fs.existsSync(BACKUP_DIR)) {
-  fs.mkdirSync(BACKUP_DIR, { recursive: true });
-}
-
-// GET /api/admin/database/backups - Listar todos os backups
-app.get('/api/admin/database/backups', authenticateAdmin, async (req, res) => {
+// GET /api/admin/me - Verificar sess√£o admin
+app.get('/api/admin/me', async (req, res) => {
   try {
-    const files = fs.readdirSync(BACKUP_DIR)
-      .filter(file => file.endsWith('.sql'))
-      .map(file => {
-        const filePath = path.join(BACKUP_DIR, file);
-        const stats = fs.statSync(filePath);
-        return {
-          filename: file,
-          size: stats.size,
-          created: stats.birthtime,
-          modified: stats.mtime,
-          sizeFormatted: formatBytes(stats.size)
-        };
-      })
-      .sort((a, b) => b.created - a.created);
+    const token = req.cookies?.admin_token || req.headers['x-admin-token'];
 
-    res.json({ backups: files });
-  } catch (error) {
-    console.error('‚ùå Erro ao listar backups:', error);
-    res.status(500).json({ error: 'Erro ao listar backups', message: error.message });
-  }
-});
-
-// POST /api/admin/database/backup - Criar backup do banco de dados
-app.post('/api/admin/database/backup', authenticateAdmin, async (req, res) => {
-  try {
-    const { description } = req.body || {};
-    const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
-    const dbName = process.env.MYSQL_DATABASE || process.env.DB_NAME || 'rare_toy_companion';
-    const dbUser = process.env.MYSQL_USER || process.env.DB_USER || 'root';
-    const dbPassword = process.env.MYSQL_PASSWORD || process.env.DB_PASSWORD || '';
-    const dbHost = process.env.MYSQL_HOST || process.env.DB_HOST || '127.0.0.1';
-    const dbPort = process.env.MYSQL_PORT || process.env.DB_PORT || '3306';
-
-    const backupFilename = `backup_${dbName}_${timestamp}${description ? '_' + description.replace(/[^a-zA-Z0-9]/g, '_') : ''}.sql`;
-    const backupPath = path.join(BACKUP_DIR, backupFilename);
-
-    // Comando mysqldump - usando vari√°vel de ambiente para senha (mais seguro)
-    // Montar o comando sem a senha no comando diretamente para evitar problemas
-    const dumpCommand = dbPassword
-      ? `MYSQL_PWD="${dbPassword}" mysqldump -h ${dbHost} -P ${dbPort} -u ${dbUser} --single-transaction --quick --lock-tables=false ${dbName} > "${backupPath}" 2>&1`
-      : `mysqldump -h ${dbHost} -P ${dbPort} -u ${dbUser} --single-transaction --quick --lock-tables=false ${dbName} > "${backupPath}" 2>&1`;
-
-    console.log(`üíæ Iniciando backup: ${backupFilename}`);
-    console.log(`üìä Banco: ${dbName}, Host: ${dbHost}, Porta: ${dbPort}, User: ${dbUser}`);
-
-    const { stdout, stderr } = await execAsync(dumpCommand, {
-      maxBuffer: 1024 * 1024 * 50, // 50MB buffer para bancos maiores
-      shell: '/bin/bash',
-      env: { ...process.env, MYSQL_PWD: dbPassword || '' }
-    });
+    if (!token) {
+      return res.status(401).json({
+        authenticated: false,
+        message: 'Token de admin n√£o encontrado'
+      });
+    }
 
-    // Verificar erros no stderr
-    if (stderr) {
-      // mysqldump envia warnings para stderr, mas alguns s√£o normais
-      if (stderr.includes('mysqldump: [Warning]')) {
-        console.warn('‚ö†Ô∏è Aviso no backup (n√£o cr√≠tico):', stderr);
-      } else if (stderr.includes('Access denied') || stderr.includes('ERROR')) {
-        throw new Error(`Erro de acesso ao banco: ${stderr}`);
-      } else {
-        console.warn('‚ö†Ô∏è Aviso no backup:', stderr);
-      }
+    // Verificar token JWT
+    let decoded;
+    try {
+      decoded = jwt.verify(token, process.env.JWT_SECRET || 'rare-toy-secret-key-change-me');
+    } catch (err) {
+      return res.status(401).json({
+        authenticated: false,
+        message: 'Token inv√°lido ou expirado'
+      });
     }
 
-    // Aguardar um pouco para garantir que o arquivo foi escrito
-    await new Promise(resolve => setTimeout(resolve, 500));
+    const userId = decoded.id;
 
-    // Verificar se o arquivo foi criado e n√£o est√° vazio
-    if (!fs.existsSync(backupPath)) {
-      const errorMsg = `Arquivo de backup n√£o foi criado. Comando: ${dumpCommand.replace(dbPassword || '', '***')}`;
-      console.error('‚ùå', errorMsg);
-      if (stdout) console.error('Stdout:', stdout);
-      if (stderr) console.error('Stderr:', stderr);
-      throw new Error(errorMsg);
+    if (!userId) {
+      return res.status(401).json({
+        authenticated: false,
+        message: 'Token inv√°lido'
+      });
     }
 
-    const stats = fs.statSync(backupPath);
-    if (stats.size === 0) {
-      // Tentar ler o conte√∫do para ver se h√° mensagem de erro
-      const content = fs.readFileSync(backupPath, 'utf8');
-      if (content.includes('ERROR') || content.includes('Access denied')) {
-        throw new Error(`Erro no backup: ${content}`);
-      }
+    // Buscar usu√°rio
+    const [rows] = await pool.execute(
+      'SELECT id, nome, email, role, status, permissoes FROM admin_users WHERE id = ? AND status = "ativo"',
+      [userId]
+    );
+
+    if (!Array.isArray(rows) || rows.length === 0) {
+      return res.status(401).json({
+        authenticated: false,
+        message: 'Usu√°rio n√£o encontrado ou inativo'
+      });
     }
 
-    console.log(`‚úÖ Backup criado: ${backupFilename} (${formatBytes(stats.size)})`);
+    const user = rows[0];
 
     res.json({
-      success: true,
-      backup: {
-        filename: backupFilename,
-        size: stats.size,
-        sizeFormatted: formatBytes(stats.size),
-        created: stats.birthtime,
-        path: backupPath
+      authenticated: true,
+      user: {
+        id: user.id,
+        nome: user.nome,
+        email: user.email,
+        role: user.role,
+        permissoes: user.permissoes ? JSON.parse(user.permissoes) : []
       }
     });
+
   } catch (error) {
-    console.error('‚ùå Erro ao criar backup:', error);
+    console.error('‚ùå Erro ao verificar sess√£o admin:', error);
     res.status(500).json({
-      error: 'Erro ao criar backup',
-      message: error.message,
-      details: process.env.NODE_ENV !== 'production' ? error.stack : undefined
+      authenticated: false,
+      message: 'Erro interno do servidor'
     });
   }
 });
 
-// POST /api/admin/database/restore - Restaurar backup do banco de dados
-app.post('/api/admin/database/restore', authenticateAdmin, async (req, res) => {
+// POST /api/admin/logout - Logout administrativo
+app.post('/api/admin/logout', async (req, res) => {
   try {
-    const { filename } = req.body;
-
-    if (!filename || !filename.endsWith('.sql')) {
-      return res.status(400).json({ error: 'Nome de arquivo inv√°lido' });
-    }
-
-    const backupPath = path.join(BACKUP_DIR, filename);
-
-    if (!fs.existsSync(backupPath)) {
-      return res.status(404).json({ error: 'Arquivo de backup n√£o encontrado' });
-    }
-
-    const dbName = process.env.MYSQL_DATABASE || process.env.DB_NAME || 'rare_toy_companion';
-    const dbUser = process.env.MYSQL_USER || process.env.DB_USER || 'root';
-    const dbPassword = process.env.MYSQL_PASSWORD || process.env.DB_PASSWORD || '';
-    const dbHost = process.env.MYSQL_HOST || process.env.DB_HOST || '127.0.0.1';
-    const dbPort = process.env.MYSQL_PORT || process.env.DB_PORT || '3306';
-
-    // Comando mysql para restaurar
-    const passwordArg = dbPassword ? `-p${dbPassword}` : '';
-    const restoreCommand = `mysql -h ${dbHost} -P ${dbPort} -u ${dbUser} ${passwordArg} ${dbName} < "${backupPath}" 2>&1`;
-
-    console.log(`üîÑ Iniciando restaura√ß√£o: ${filename}`);
-
-    const { stdout, stderr } = await execAsync(restoreCommand, {
-      maxBuffer: 1024 * 1024 * 10, // 10MB buffer
-      shell: '/bin/bash'
+    res.clearCookie('admin_token');
+    res.json({ ok: true, message: 'Logout realizado com sucesso' });
+  } catch (error) {
+    console.error('‚ùå Erro no logout admin:', error);
+    res.status(500).json({
+      ok: false,
+      message: 'Erro interno do servidor'
     });
+  }
+});
 
-    if (stderr && !stderr.includes('[Warning]')) {
-      console.warn('‚ö†Ô∏è Aviso na restaura√ß√£o:', stderr);
-    }
-
-    console.log(`‚úÖ Restaura√ß√£o conclu√≠da: ${filename}`);
+// ============================================
+// ROTAS DE ANALYTICS E DASHBOARD ADMIN
+app.get('/api/customers/:userId/settings', async (req, res) => {
+  try {
+    let { userId } = req.params;
+    console.log(`üìç GET /api/customers/${userId}/settings`);
 
-    // Limpar cache Redis ap√≥s restaura√ß√£o
-    if (redisCache.isAvailable()) {
-      try {
-        await redisCache.flushAll();
-        console.log('üßπ Cache Redis limpo ap√≥s restaura√ß√£o');
-      } catch (cacheError) {
-        console.warn('‚ö†Ô∏è Erro ao limpar cache Redis:', cacheError);
+    // Se userId parece ser email, buscar o ID do usu√°rio
+    if (userId.includes('@')) {
+      const [user] = await pool.execute('SELECT id FROM users WHERE email = ?', [userId]);
+      if (user && user[0]) {
+        userId = user[0].id;
+      } else {
+        return res.status(404).json({ error: 'Usu√°rio n√£o encontrado' });
       }
     }
 
-    res.json({ success: true, message: 'Backup restaurado com sucesso' });
+    // Buscar configura√ß√µes
+    const [settings] = await pool.execute(`
+      SELECT * FROM customer_settings WHERE customer_id = ?
+    `, [userId]);
+
+    if (settings.length > 0) {
+      const setting = settings[0];
+      res.json({
+        privacy: {
+          showProfile: setting.show_profile || true,
+          showPurchaseHistory: setting.show_purchase_history || false,
+          showWishlist: setting.show_wishlist || false,
+          allowMarketing: setting.allow_marketing || true,
+          allowAnalytics: setting.allow_analytics || true,
+          allowCookies: setting.allow_cookies || true
+        },
+        preferences: {
+          language: setting.language || 'pt-BR',
+          currency: setting.currency || 'BRL',
+          theme: setting.theme || 'light',
+          emailFrequency: setting.email_frequency || 'weekly',
+          twoFactorAuth: setting.two_factor_auth || false
+        }
+      });
+    } else {
+      // Retornar valores padr√£o
+      res.json({
+        privacy: {
+          showProfile: true,
+          showPurchaseHistory: false,
+          showWishlist: false,
+          allowMarketing: true,
+          allowAnalytics: true,
+          allowCookies: true
+        },
+        preferences: {
+          language: 'pt-BR',
+          currency: 'BRL',
+          theme: 'light',
+          emailFrequency: 'weekly',
+          twoFactorAuth: false
+        }
+      });
+    }
   } catch (error) {
-    console.error('‚ùå Erro ao restaurar backup:', error);
-    res.status(500).json({
-      error: 'Erro ao restaurar backup',
-      message: error.message,
-      details: process.env.NODE_ENV !== 'production' ? error.stack : undefined
-    });
+    console.error('‚ùå Erro ao buscar configura√ß√µes:', error);
+    res.status(500).json({ error: 'Erro ao buscar configura√ß√µes' });
   }
 });
 
-// DELETE /api/admin/database/backup/:filename - Deletar backup
-app.delete('/api/admin/database/backup/:filename', authenticateAdmin, async (req, res) => {
+// Salvar configura√ß√µes do cliente
+app.put('/api/customers/:userId/settings', async (req, res) => {
   try {
-    const { filename } = req.params;
+    let { userId } = req.params;
+    console.log(`üìç PUT /api/customers/${userId}/settings`);
 
-    if (!filename || !filename.endsWith('.sql')) {
-      return res.status(400).json({ error: 'Nome de arquivo inv√°lido' });
+    // Se userId parece ser email, buscar o ID do usu√°rio
+    if (userId.includes('@')) {
+      const [user] = await pool.execute('SELECT id FROM users WHERE email = ?', [userId]);
+      if (user && user[0]) {
+        userId = user[0].id;
+      } else {
+        return res.status(404).json({ error: 'Usu√°rio n√£o encontrado' });
+      }
     }
 
-    const backupPath = path.join(BACKUP_DIR, filename);
+    const { privacy, preferences } = req.body;
+    console.log('üìù Salvando configura√ß√µes:', { privacy, preferences });
+
+    // Verificar se j√° existe configura√ß√£o
+    const [existing] = await pool.execute(`
+      SELECT id FROM customer_settings WHERE customer_id = ?
+    `, [userId]);
 
-    if (!fs.existsSync(backupPath)) {
-      return res.status(404).json({ error: 'Arquivo de backup n√£o encontrado' });
+    if (existing.length > 0) {
+      // Atualizar configura√ß√µes existentes
+      await pool.execute(`
+        UPDATE customer_settings SET
+          show_profile = ?,
+          show_purchase_history = ?,
+          show_wishlist = ?,
+          allow_marketing = ?,
+          allow_analytics = ?,
+          allow_cookies = ?,
+          language = ?,
+          currency = ?,
+          theme = ?,
+          email_frequency = ?,
+          two_factor_auth = ?,
+          updated_at = NOW()
+        WHERE customer_id = ?
+      `, [
+        privacy?.showProfile || true,
+        privacy?.showPurchaseHistory || false,
+        privacy?.showWishlist || false,
+        privacy?.allowMarketing || true,
+        privacy?.allowAnalytics || true,
+        privacy?.allowCookies || true,
+        preferences?.language || 'pt-BR',
+        preferences?.currency || 'BRL',
+        preferences?.theme || 'light',
+        preferences?.emailFrequency || 'weekly',
+        preferences?.twoFactorAuth || false,
+        userId
+      ]);
+    } else {
+      // Criar novas configura√ß√µes
+      await pool.execute(`
+        INSERT INTO customer_settings (
+          customer_id,
+          show_profile,
+          show_purchase_history,
+          show_wishlist,
+          allow_marketing,
+          allow_analytics,
+          allow_cookies,
+          language,
+          currency,
+          theme,
+          email_frequency,
+          two_factor_auth,
+          created_at,
+          updated_at
+        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, NOW(), NOW())
+      `, [
+        userId,
+        privacy?.showProfile || true,
+        privacy?.showPurchaseHistory || false,
+        privacy?.showWishlist || false,
+        privacy?.allowMarketing || true,
+        privacy?.allowAnalytics || true,
+        privacy?.allowCookies || true,
+        preferences?.language || 'pt-BR',
+        preferences?.currency || 'BRL',
+        preferences?.theme || 'light',
+        preferences?.emailFrequency || 'weekly',
+        preferences?.twoFactorAuth || false
+      ]);
     }
 
-    fs.unlinkSync(backupPath);
-    console.log(`üóëÔ∏è Backup deletado: ${filename}`);
-
-    res.json({ success: true, message: 'Backup deletado com sucesso' });
+    console.log('‚úÖ Configura√ß√µes salvas com sucesso');
+    res.json({ success: true, message: 'Configura√ß√µes salvas com sucesso' });
   } catch (error) {
-    console.error('‚ùå Erro ao deletar backup:', error);
-    res.status(500).json({ error: 'Erro ao deletar backup', message: error.message });
+    console.error('‚ùå Erro ao salvar configura√ß√µes:', error);
+    res.status(500).json({ error: 'Erro ao salvar configura√ß√µes', details: error.message });
   }
 });
 
-// GET /api/admin/database/backup/download/:filename - Download backup
-app.get('/api/admin/database/backup/download/:filename', authenticateAdmin, async (req, res) => {
+// Buscar prefer√™ncias de notifica√ß√£o do cliente
+app.get('/api/customers/:userId/notification-preferences', async (req, res) => {
   try {
-    const { filename } = req.params;
-
-    if (!filename || !filename.endsWith('.sql')) {
-      return res.status(400).json({ error: 'Nome de arquivo inv√°lido' });
-    }
-
-    const backupPath = path.join(BACKUP_DIR, filename);
+    let { userId } = req.params;
+    console.log(`üìç GET /api/customers/${userId}/notification-preferences`);
 
-    if (!fs.existsSync(backupPath)) {
-      return res.status(404).json({ error: 'Arquivo de backup n√£o encontrado' });
+    // Se userId parece ser email, buscar o ID do usu√°rio
+    if (userId.includes('@')) {
+      const [user] = await pool.execute('SELECT id FROM users WHERE email = ?', [userId]);
+      if (user && user[0]) {
+        userId = user[0].id;
+      } else {
+        return res.status(404).json({ error: 'Usu√°rio n√£o encontrado' });
+      }
     }
 
-    res.setHeader('Content-Type', 'application/sql');
-    res.setHeader('Content-Disposition', `attachment; filename="${filename}"`);
-
-    const fileStream = fs.createReadStream(backupPath);
-    fileStream.pipe(res);
-  } catch (error) {
-    console.error('‚ùå Erro ao baixar backup:', error);
-    res.status(500).json({ error: 'Erro ao baixar backup', message: error.message });
-  }
-});
-
-// Fun√ß√£o auxiliar para formatar bytes
-function formatBytes(bytes) {
-  if (bytes === 0) return '0 Bytes';
-  const k = 1024;
-  const sizes = ['Bytes', 'KB', 'MB', 'GB'];
-  const i = Math.floor(Math.log(bytes) / Math.log(k));
-  return Math.round(bytes / Math.pow(k, i) * 100) / 100 + ' ' + sizes[i];
-}
-
-// ==================== END DATABASE BACKUP & RESTORE ENDPOINTS ====================
-
-// Scheduler para executar automa√ß√µes diariamente √†s 9h
-const runDailyAutomations = async () => {
-  const now = new Date();
-  const hour = now.getHours();
-
-  // Executar apenas √†s 9h da manh√£
-  if (hour === 9) {
-    console.log('‚è∞ [SCHEDULER] Hora de executar automa√ß√µes di√°rias!');
-    await couponAutomation.runAllAutomations(pool);
-  }
-};
-
-// Verificar a cada hora se √© hora de executar
-setInterval(runDailyAutomations, 60 * 60 * 1000); // A cada 1 hora
+    // Buscar prefer√™ncias da tabela customer_settings
+    const [settings] = await pool.execute(`
+      SELECT allow_marketing, allow_analytics FROM customer_settings WHERE customer_id = ?
+    `, [userId]);
 
-// Executar uma vez ao iniciar o servidor (apenas para teste)
-setTimeout(async () => {
-  console.log('üöÄ [STARTUP] Executando verifica√ß√£o inicial de cupons...');
-  try {
-    // Apenas notifica√ß√µes de cupons expirando no startup
-    await couponAutomation.notifyExpiringCoupons(pool);
-  } catch (error) {
-    console.error('‚ùå [STARTUP] Erro na verifica√ß√£o inicial:', error);
-  }
-}, 5000); // 5 segundos ap√≥s o servidor iniciar
-
-console.log('‚úÖ Sistema de automa√ß√£o de cupons carregado!');
-
-// =========================
-// Servir arquivos est√°ticos do build (AP√ìS /lovable-uploads)
-// =========================
-app.use(express.static(path.join(__dirname, '../dist'), {
-  setHeaders: (res, filePath) => {
-    // Cache control para arquivos est√°ticos
-    if (filePath.endsWith('.html')) {
-      res.setHeader('Cache-Control', 'no-cache, no-store, must-revalidate');
+    if (settings.length > 0) {
+      res.json({
+        emailNotifications: settings[0].allow_marketing || true,
+        pushNotifications: settings[0].allow_analytics || true
+      });
     } else {
-      res.setHeader('Cache-Control', 'public, max-age=31536000');
+      // Retornar valores padr√£o
+      res.json({
+        emailNotifications: true,
+        pushNotifications: true
+      });
     }
-  }
-}));
-
-// Redirecionar rotas antigas de analytics para o novo endpoint (compatibilidade)
-app.get('/analytics/dashboard', authenticateAdmin, async (req, res) => {
-  // Chamar o handler do endpoint correto
-  const originalUrl = req.url;
-  const originalPath = req.path;
-  req.url = '/api/admin/analytics/dashboard' + (req.url.includes('?') ? req.url.substring(req.url.indexOf('?')) : '');
-  req.path = '/api/admin/analytics/dashboard';
-
-  // Encontrar e chamar a rota correta
-  const route = app._router.stack.find(layer =>
-    layer.route && layer.route.path === '/api/admin/analytics/dashboard' && layer.route.methods.get
-  );
-
-  if (route) {
-    return route.route.stack[0].handle(req, res);
-  }
-
-  // Fallback: redirecionar
-  return res.redirect(301, '/api/admin/analytics/dashboard' + (originalUrl.includes('?') ? originalUrl.substring(originalUrl.indexOf('?')) : ''));
-});
-
-app.get('/analytics/vendas', authenticateAdmin, async (req, res) => {
-  req.url = '/api/admin/analytics/vendas' + (req.url.includes('?') ? req.url.substring(req.url.indexOf('?')) : '');
-  req.path = '/api/admin/analytics/vendas';
-  const route = app._router.stack.find(layer =>
-    layer.route && layer.route.path === '/api/admin/analytics/vendas' && layer.route.methods.get
-  );
-  if (route) {
-    return route.route.stack[0].handle(req, res);
-  }
-  return res.redirect(301, '/api/admin/analytics/vendas');
-});
-
-app.get('/analytics/produtos-populares', authenticateAdmin, async (req, res) => {
-  req.url = '/api/admin/analytics/produtos-populares' + (req.url.includes('?') ? req.url.substring(req.url.indexOf('?')) : '');
-  req.path = '/api/admin/analytics/produtos-populares';
-  const route = app._router.stack.find(layer =>
-    layer.route && layer.route.path === '/api/admin/analytics/produtos-populares' && layer.route.methods.get
-  );
-  if (route) {
-    return route.route.stack[0].handle(req, res);
-  }
-  return res.redirect(301, '/api/admin/analytics/produtos-populares');
-});
-
-app.get('/analytics/pedidos-recentes', authenticateAdmin, async (req, res) => {
-  req.url = '/api/admin/analytics/pedidos-recentes' + (req.url.includes('?') ? req.url.substring(req.url.indexOf('?')) : '');
-  req.path = '/api/admin/analytics/pedidos-recentes';
-  const route = app._router.stack.find(layer =>
-    layer.route && layer.route.path === '/api/admin/analytics/pedidos-recentes' && layer.route.methods.get
-  );
-  if (route) {
-    return route.route.stack[0].handle(req, res);
-  }
-  return res.redirect(301, '/api/admin/analytics/pedidos-recentes');
-});
-
-// Endpoints de analytics n√£o-admin (se necess√°rio)
-app.get('/api/analytics/realtime', authenticateAdmin, async (req, res) => {
-  try {
-    res.json({
-      activeUsers: 0,
-      pageViews: 0,
-      orders: 0,
-      revenue: 0
-    });
-  } catch (error) {
-    res.status(500).json({ error: 'Erro ao buscar dados em tempo real' });
-  }
-});
-
-app.post('/api/analytics/web-vitals', async (req, res) => {
-  // Endpoint para receber m√©tricas de performance do frontend
-  try {
-    // Log opcional das m√©tricas
-    console.log('üìä Web Vitals:', req.body);
-    res.json({ success: true });
-  } catch (error) {
-    res.status(500).json({ error: 'Erro ao processar m√©tricas' });
-  }
-});
-
-// ==========================================
-// üè∑Ô∏è ENDPOINTS DE BADGES DE PRODUTOS
-// ==========================================
-
-// GET /api/badges - Listar todos os badges dispon√≠veis
-app.get('/api/badges', async (req, res) => {
-  try {
-    console.log('üè∑Ô∏è Buscando badges...');
-
-    const [rows] = await pool.execute(
-      'SELECT * FROM product_badges WHERE ativo = 1 ORDER BY ordem ASC'
-    );
-
-    console.log(`‚úÖ ${rows.length} badges encontrados`);
-    res.json(rows);
   } catch (error) {
-    console.error('‚ùå Erro ao buscar badges:', error);
-    res.status(500).json({ error: 'Erro ao buscar badges' });
+    console.error('‚ùå Erro ao buscar prefer√™ncias de notifica√ß√£o:', error);
+    res.json({ emailNotifications: true, pushNotifications: true });
   }
 });
 
-// GET /api/produtos/:id/badges - Listar badges de um produto espec√≠fico
-app.get('/api/produtos/:id/badges', async (req, res) => {
+// Salvar prefer√™ncias de notifica√ß√£o do cliente
+app.put('/api/customers/:userId/notification-preferences', async (req, res) => {
   try {
-    const { id } = req.params;
-    console.log(`üè∑Ô∏è Buscando badges do produto ${id}...`);
+    let { userId } = req.params;
+    console.log(`üìç PUT /api/customers/${userId}/notification-preferences`);
 
-    const [rows] = await pool.execute(
-      `SELECT pb.* 
-       FROM product_badges pb
-       INNER JOIN produto_badge ppb ON pb.id = ppb.badge_id
-       WHERE ppb.produto_id = ? AND pb.ativo = 1
-       ORDER BY pb.ordem ASC`,
-      [id]
-    );
+    // Se userId parece ser email, buscar o ID do usu√°rio
+    if (userId.includes('@')) {
+      const [user] = await pool.execute('SELECT id FROM users WHERE email = ?', [userId]);
+      if (user && user[0]) {
+        userId = user[0].id;
+      } else {
+        return res.status(404).json({ error: 'Usu√°rio n√£o encontrado' });
+      }
+    }
 
-    console.log(`‚úÖ ${rows.length} badges encontrados para o produto ${id}`);
-    res.json(rows);
-  } catch (error) {
-    console.error(`‚ùå Erro ao buscar badges do produto:`, error);
-    res.status(500).json({ error: 'Erro ao buscar badges do produto' });
-  }
-});
+    const { emailNotifications, pushNotifications } = req.body;
+    console.log('üìù Salvando prefer√™ncias de notifica√ß√£o:', { emailNotifications, pushNotifications });
 
-// POST /api/produtos/:id/badges - Adicionar badge a um produto
-app.post('/api/produtos/:id/badges', async (req, res) => {
-  try {
-    const { id } = req.params;
-    const { badge_id } = req.body;
+    // Verificar se j√° existe configura√ß√£o
+    const [existing] = await pool.execute(`
+      SELECT id FROM customer_settings WHERE customer_id = ?
+    `, [userId]);
 
-    if (!badge_id) {
-      return res.status(400).json({ error: 'badge_id √© obrigat√≥rio' });
+    if (existing.length > 0) {
+      // Atualizar configura√ß√µes existentes
+      await pool.execute(`
+        UPDATE customer_settings SET
+          allow_marketing = ?,
+          allow_analytics = ?,
+          updated_at = NOW()
+        WHERE customer_id = ?
+      `, [emailNotifications ? 1 : 0, pushNotifications ? 1 : 0, userId]);
+    } else {
+      // Criar novas configura√ß√µes
+      await pool.execute(`
+        INSERT INTO customer_settings (
+          customer_id,
+          allow_marketing,
+          allow_analytics,
+          created_at,
+          updated_at
+        ) VALUES (?, ?, ?, NOW(), NOW())
+      `, [userId, emailNotifications ? 1 : 0, pushNotifications ? 1 : 0]);
     }
 
-    console.log(`üè∑Ô∏è Adicionando badge ${badge_id} ao produto ${id}...`);
-
-    await pool.execute(
-      'INSERT IGNORE INTO produto_badge (produto_id, badge_id) VALUES (?, ?)',
-      [id, badge_id]
-    );
-
-    console.log(`‚úÖ Badge adicionado ao produto ${id}`);
-    res.json({ success: true, message: 'Badge adicionado' });
+    console.log('‚úÖ Prefer√™ncias de notifica√ß√£o salvas com sucesso');
+    res.json({ success: true, message: 'Prefer√™ncias salvas com sucesso' });
   } catch (error) {
-    console.error(`‚ùå Erro ao adicionar badge ao produto:`, error);
-    res.status(500).json({ error: 'Erro ao adicionar badge' });
+    console.error('‚ùå Erro ao salvar prefer√™ncias de notifica√ß√£o:', error);
+    res.status(500).json({ error: 'Erro ao salvar prefer√™ncias', details: error.message });
   }
 });
 
-// DELETE /api/produtos/:id/badges/:badge_id - Remover badge de um produto
-app.delete('/api/produtos/:id/badges/:badge_id', async (req, res) => {
+// Buscar sess√µes ativas do cliente
+app.get('/api/customers/:userId/sessions', async (req, res) => {
   try {
-    const { id, badge_id } = req.params;
-
-    console.log(`üè∑Ô∏è Removendo badge ${badge_id} do produto ${id}...`);
-
-    await pool.execute(
-      'DELETE FROM produto_badge WHERE produto_id = ? AND badge_id = ?',
-      [id, badge_id]
-    );
-
-    console.log(`‚úÖ Badge removido do produto ${id}`);
-    res.json({ success: true, message: 'Badge removido' });
-  } catch (error) {
-    console.error(`‚ùå Erro ao remover badge do produto:`, error);
-    res.status(500).json({ error: 'Erro ao remover badge' });
-  }
-});
+    let { userId } = req.params;
+    console.log(`üìç GET /api/customers/${userId}/sessions`);
 
-// PUT /api/produtos/:id/condicao - Atualizar condi√ß√£o do produto
-app.put('/api/produtos/:id/condicao', async (req, res) => {
-  try {
-    const { id } = req.params;
-    const { condicao } = req.body;
+    // Se userId parece ser email, buscar o ID do usu√°rio
+    if (userId.includes('@')) {
+      const [user] = await pool.execute('SELECT id, email FROM users WHERE email = ?', [userId]);
+      if (user && user[0]) {
+        userId = user[0].id;
+        // Buscar sess√µes por user_id E por email
+        const [sessions] = await pool.execute(`
+          SELECT 
+            id,
+            user_id,
+            user_email,
+            created_at,
+            updated_at
+          FROM sessions 
+          WHERE user_id = ? OR user_email = ?
+          ORDER BY created_at DESC
+          LIMIT 10
+        `, [userId, user[0].email]);
 
-    const condicoesValidas = ['novo', 'seminovo', 'colecionavel', 'usado'];
-    if (!condicao || !condicoesValidas.includes(condicao)) {
-      return res.status(400).json({
-        error: 'Condi√ß√£o inv√°lida. Use: novo, seminovo, colecionavel ou usado'
-      });
+        return res.json({
+          sessions: sessions.map(s => ({
+            id: s.id,
+            device: 'Navegador',
+            location: 'Brasil',
+            lastActive: s.updated_at || s.created_at,
+            current: true
+          }))
+        });
+      } else {
+        return res.status(404).json({ error: 'Usu√°rio n√£o encontrado', sessions: [] });
+      }
     }
 
-    console.log(`üè∑Ô∏è Atualizando condi√ß√£o do produto ${id} para: ${condicao}...`);
-
-    await pool.execute(
-      'UPDATE produtos SET condicao = ? WHERE id = ?',
-      [condicao, id]
-    );
+    // Buscar sess√µes por user_id
+    const [sessions] = await pool.execute(`
+      SELECT 
+        id,
+        user_id,
+        user_email,
+        created_at,
+        updated_at
+      FROM sessions 
+      WHERE user_id = ?
+      ORDER BY created_at DESC
+      LIMIT 10
+    `, [userId]);
 
-    console.log(`‚úÖ Condi√ß√£o do produto ${id} atualizada`);
-    res.json({ success: true, message: 'Condi√ß√£o atualizada', condicao });
+    res.json({
+      sessions: sessions.map(s => ({
+        id: s.id,
+        device: 'Navegador',
+        location: 'Brasil',
+        lastActive: s.updated_at || s.created_at,
+        current: true
+      }))
+    });
   } catch (error) {
-    console.error(`‚ùå Erro ao atualizar condi√ß√£o do produto:`, error);
-    res.status(500).json({ error: 'Erro ao atualizar condi√ß√£o' });
+    console.error('‚ùå Erro ao buscar sess√µes:', error);
+    res.json({ sessions: [] });
   }
 });
 
-// Fallback para SPA - todas as rotas n√£o encontradas v√£o para index.html
-// IMPORTANTE: Esta rota deve vir DEPOIS de todas as outras rotas espec√≠ficas
-// Usar app.use ao inv√©s de app.get('*') para evitar erro de path regex
-app.use((req, res, next) => {
-  // Ignorar rotas de API, uploads e arquivos est√°ticos
-  if (req.path.startsWith('/api') ||
-    req.path.startsWith('/lovable-uploads') ||
-    req.path.startsWith('/uploads') ||
-    req.path.startsWith('/icon') ||
-    req.path.startsWith('/pwa-icon') ||
-    req.path.startsWith('/sw.js') ||
-    req.path.startsWith('/manifest.json') ||
-    req.path.startsWith('/assets/') ||
-    req.path.endsWith('.js') ||
-    req.path.endsWith('.css') ||
-    req.path.endsWith('.png') ||
-    req.path.endsWith('.jpg') ||
-    req.path.endsWith('.jpeg') ||
-    req.path.endsWith('.gif') ||
-    req.path.endsWith('.webp') ||
-    req.path.endsWith('.svg') ||
-    req.path.endsWith('.ico')) {
-    // Se for uma rota que n√£o deve ser servida como SPA, retornar 404
-    console.log(`‚ö†Ô∏è [SPA Fallback] Rota n√£o encontrada: ${req.path}`);
-    return res.status(404).send('Not Found');
+// Criar tabela de configura√ß√µes do cliente se n√£o existir
+(async () => {
+  try {
+    await pool.execute(`
+      CREATE TABLE IF NOT EXISTS customer_settings (
+        id INT AUTO_INCREMENT PRIMARY KEY,
+        customer_id VARCHAR(191) NOT NULL,
+        show_profile TINYINT(1) DEFAULT 1,
+        show_purchase_history TINYINT(1) DEFAULT 0,
+        show_wishlist TINYINT(1) DEFAULT 0,
+        allow_marketing TINYINT(1) DEFAULT 1,
+        allow_analytics TINYINT(1) DEFAULT 1,
+        allow_cookies TINYINT(1) DEFAULT 1,
+        language VARCHAR(10) DEFAULT 'pt-BR',
+        currency VARCHAR(10) DEFAULT 'BRL',
+        theme VARCHAR(20) DEFAULT 'light',
+        email_frequency VARCHAR(20) DEFAULT 'weekly',
+        two_factor_auth TINYINT(1) DEFAULT 0,
+        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
+        updated_at DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
+        UNIQUE KEY unique_customer (customer_id)
+      ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4
+    `);
+    console.log('‚úÖ Tabela customer_settings criada/verificada');
+  } catch (e) {
+    console.error('‚ùå Erro ao criar tabela customer_settings:', e);
   }
+})();
 
-  // Para todas as outras rotas, servir index.html
-  const indexPath = path.join(__dirname, '../dist', 'index.html');
-  if (fs.existsSync(indexPath)) {
-    console.log(`üìÑ [SPA Fallback] Servindo index.html para: ${req.path}`);
-    return res.sendFile(indexPath);
-  } else {
-    console.warn(`‚ö†Ô∏è [SPA Fallback] index.html n√£o encontrado em: ${indexPath}`);
-    return res.status(404).send('Not Found');
-  }
-});
+console.log('‚úÖ Endpoints da API para dados reais carregados com sucesso!');
 
